<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <head>
	<meta name="generator" content="Hugo 0.144.2">
    
      <meta name="theme" content='FixIt v0.3.17-8b402129'>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>Shino Channel</title><meta name="author" content="Shino">
<meta name="description" content="">
  <meta itemprop="name" content="Shino Channel">
  <meta itemprop="datePublished" content="2024-09-22T19:55:39+08:00">
  <meta itemprop="dateModified" content="2024-09-22T19:55:39+08:00">
  <meta itemprop="image" content="https://www.sh1no.icu/avr.png"><meta property="og:url" content="https://www.sh1no.icu/">
  <meta property="og:site_name" content="Shino Channel">
  <meta property="og:title" content="Shino Channel">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="website">
    <meta property="og:image" content="https://www.sh1no.icu/avr.png">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://www.sh1no.icu/avr.png">
  <meta name="twitter:title" content="Shino Channel">
      <meta name="twitter:site" content="@ShinoLeah">
<meta name="twitter:creator" content="@ShinoLeah" /><meta name="application-name" content="Shino Channel">
<meta name="apple-mobile-web-app-title" content="Shino Channel"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" type="text/html" href="https://www.sh1no.icu/" title="Shino Channel" /><link rel="alternate" type="application/rss+xml" href="https://www.sh1no.icu/index.xml" title="Shino Channel"><link rel="search" type="application/json" href="https://www.sh1no.icu/search.json" title="Shino Channel"><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/lib/fontawesome-free/all.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" href="/lib/animate/animate.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "WebSite",
    "url": "https:\/\/www.sh1no.icu\/","inLanguage": "zh-CN","author": {
        "@type": "Person",
        "name": "Shino"
      },"name": "Shino Channel"
  }
  </script><script src="/js/head/color-scheme.min.js"></script></head>
  <body data-header-desktop="sticky" data-header-mobile="auto"><div class="wrapper" data-page-style="normal"><header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper">
    <div class="header-title">
      <a href="/" title="Shino Channel"><span class="header-title-text">Shino</span></a><span class="header-subtitle"></span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a class="menu-link" href="https://www.youtube.com/@anoofficialchannel" rel="noopener noreferrer" target="_blank"></a></li><li class="menu-item">
              <a class="menu-link" href="https://www.nu1l.com/" title="Nu1L" rel="noopener noreferrer" target="_blank"><i class="fa-solid fa-paperclip fa-fw fa-sm" aria-hidden="true"></i> Nu1L</a></li><li class="menu-item">
              <a class="menu-link" href="https://cnss.io/" title="CNSS" rel="noopener noreferrer" target="_blank"><i class="fa-solid fa-paperclip fa-fw fa-sm" aria-hidden="true"></i> CNSS</a></li><li class="menu-item">
              <a class="menu-link" href="/posts/friends/" title="About"><i class="fa-solid fa-user-group fa-fw fa-sm" aria-hidden="true"></i> About</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id="search-desktop">
            <input type="text" placeholder="Search..." id="search-input-desktop">
            <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="Search">
              <i class="fa-solid fa-search fa-fw" aria-hidden="true"></i>
            </a>
            <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="Clear">
              <i class="fa-solid fa-times-circle fa-fw" aria-hidden="true"></i>
            </a>
            <span class="search-button search-loading" id="search-loading-desktop">
              <i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
            </span>
          </li><li class="menu-item theme-switch" title="Switch Theme">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li></ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/" title="Shino Channel"><span class="header-title-text">Shino</span></a><span class="header-subtitle"></span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li class="search-wrapper">
            <div class="search mobile" id="search-mobile">
              <input type="text" placeholder="Search..." id="search-input-mobile">
              <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="Search">
                <i class="fa-solid fa-search fa-fw" aria-hidden="true"></i>
              </a>
              <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="Clear">
                <i class="fa-solid fa-times-circle fa-fw" aria-hidden="true"></i>
              </a>
              <span class="search-button search-loading" id="search-loading-mobile">
                <i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
              </span>
            </div>
            <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
              Cancel
            </a>
          </li><li class="menu-item"><a class="menu-link" href="https://www.youtube.com/@anoofficialchannel" rel="noopener noreferrer" target="_blank"></a></li><li class="menu-item"><a class="menu-link" href="https://www.nu1l.com/" title="Nu1L" rel="noopener noreferrer" target="_blank"><i class="fa-solid fa-paperclip fa-fw fa-sm" aria-hidden="true"></i> Nu1L</a></li><li class="menu-item"><a class="menu-link" href="https://cnss.io/" title="CNSS" rel="noopener noreferrer" target="_blank"><i class="fa-solid fa-paperclip fa-fw fa-sm" aria-hidden="true"></i> CNSS</a></li><li class="menu-item"><a class="menu-link" href="/posts/friends/" title="About"><i class="fa-solid fa-user-group fa-fw fa-sm" aria-hidden="true"></i> About</a></li><li class="menu-item menu-system">
          <span class="menu-system-item theme-switch" title="Switch Theme"><i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i></span></li>
      </ul>
    </nav>
  </div>
</header><div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
  </div>
  <div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
  </div><main class="container"><div class="page home posts"><div class="home-profile"><div class="home-avatar"><a href="https://www.youtube.com/@anoofficialchannel" rel="noopener noreferrer" target="_blank"><img loading="lazy" src="/avr.png" alt="Shino" data-title="Shino" width="96" height="96" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></div><h1 class="home-title">Shino Channel</h1><p class="home-subtitle"><span class="d-none">$ sudo echo Shino &gt;&gt; YourHeart</span><span class="typeit"><template>$ sudo echo Shino >> YourHeart</template></span></p><div class="links"><a href="https://github.com/Sh11no" title="GitHub"target="_blank" rel="external nofollow noopener noreferrer me"><i class="fa-brands fa-github-alt fa-fw" aria-hidden="true"></i>
    </a><a href="https://twitter.com/ShinoLeah" title="X"target="_blank" rel="external nofollow noopener noreferrer me"><i class="fa-brands fa-x-twitter fa-fw" aria-hidden="true"></i>
    </a><a href="https://steamcommunity.com/id/noshiko" title="Steam"target="_blank" rel="external nofollow noopener noreferrer me"><i class="fa-brands fa-steam fa-fw" aria-hidden="true"></i>
    </a><a href="https://space.bilibili.com/96243678" title="bilibili"target="_blank" rel="external nofollow noopener noreferrer me"><i class="fa-brands fa-bilibili" aria-hidden="true"></i>
    </a><a href="mailto:akalineblog@163.com" title="Email"target="_blank" rel="external nofollow noopener noreferrer me"><i class="fa-regular fa-envelope fa-fw" aria-hidden="true"></i>
    </a></div></div>
<article class="single summary" itemscope itemtype="http://schema.org/Article"><h2 class="single-title" itemprop="name headline"><a href="/posts/go-auth/">使用Go&#43;Gin&#43;Redis实现一个简单的登录注册系统</a>
  </h2><div class="post-meta"><span class="post-author"><span class="author"><img loading="lazy" src="/avr.png" alt="Shino" data-title="Shino" width="20" height="20" class="avatar" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/>&nbsp;Shino</span></span>&nbsp;<span class="post-publish" title='2022-03-29 21:02:13'>published on <time datetime="2022-03-29">2022-03-29</time></span></div><div class="content">简易前端我们先随便写一个简单的前端页面，放在工作目录下./templates文件夹中。
</div><div class="post-footer">
    <a href="/posts/go-auth/">Read More</a></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h2 class="single-title" itemprop="name headline"><a href="/posts/templates/">板子 (Ver.诗乃)</a>
  </h2><div class="post-meta"><span class="post-author"><span class="author"><img loading="lazy" src="/avr.png" alt="Shino" data-title="Shino" width="20" height="20" class="avatar" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/>&nbsp;Shino</span></span>&nbsp;<span class="post-publish" title='2022-03-09 18:26:20'>published on <time datetime="2022-03-09">2022-03-09</time></span></div><div class="content">Tarjan&amp;Topo1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void tarjan(int u) { dfn[u] = low[u] = ++tim; ins[u] = 1; stac[++top] = u; for(int v, i = h[u]; ~i; i = e[i].next) if(!dfn[(v = e[i].to)]) { tarjan(v); low[u] = min(low[u], low[v]); } else if(ins[v]) low[u] = min(low[u], low[v]); if(low[u] == dfn[u]) { int y; while(y = stac[top--]) { sd[y] = u; ins[y] = 0; if(u == y) break; p[u] += p[y]; } } } void topo() { queue &lt;int&gt; q; for(int i = 1; i &lt;= n; ++i) if(sd[i] == i &amp;&amp; !in[i]) q.push(i), dis[i] = p[i]; while(!q.empty()) { int u = q.front(); q.pop(); for(int v, i = h[u]; ~i; i = e[i].next) { v = e[i].to; dis[v] = max(dis[v], dis[u] + p[v]); --in[v]; if(!in[v]) q.push(v); } } int ans = 0; for(int i = 1; i &lt;= n; ++i) ans = max(ans, dis[i]); printf(&#34;%d\n&#34;, ans); } ST1 2 3 4 5 6 7 8 9 void ST_Build() { for(int j = 1; j &lt;= 21; ++j) for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) st[i][j] = max(st[i][j-1], st[i+(1&lt;&lt;(j-1))][j-1]); } int ST_query(int l, int r) { int k = lg2[r-l+1]; return max(st[l][k], st[r-(1&lt;&lt;k)+1][k]); } ST-BlackMagic1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 struct RMQ { #define L(x) ((x-1)*siz+1) #define R(x) std::min(n, x*siz+1) #define bl(x) ((x-1)/siz+1) const int MAXB = 2050, siz = 50; int prf[MAXN], suf[MAXN], n, st[MAXB][13], lg2[MAXN], a[MAXN]; void init(int *s, int _n, int k) { n = _n; for(int i = 1; i &lt;= n; ++i) a[i] = s[i] % k, st[bl(i)][0] = min(st[bl(i)][0], a[i]); for(int i = 1; i &lt;= bl(n); ++i) { prf[L(i)] = a[L(i)]; suf[R(i)] = a[R(i)]; for(int j = L(i)+1; j &lt;= R(i); ++j) prf[j] = min(prf[j-1], a[j]); for(int j = R(i)-1; j &gt;= L(i); --j) suf[j] = min(suf[j+1], a[j]); } for(int j = 1; j &lt;= 12; ++j) for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= bl(n); ++i) st[i][j] = min(st[i][j-1], st[i+(1&lt;&lt;(j-1))][j-1]); } int QST(int l, int r) { if(l &gt; r) return 0; int k = lg2[r-l+1]; return min(st[l][k], st[r-(1&lt;&lt;k)+1][k]); } int query(int l, int r) { if(bl(l) == bl(r)) { int res = 0; for(int i = l; i &lt;= r; ++i) res = max(res, a[i]); return res; } else return min(min(prf[r], suf[l]), QST(bl(l)+1, bl(r)-1)); } } ST; Manacher1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void Manacher() { int mr = 0, mid; for(int i = 0; i &lt; n; ++i) { p[i] = i &lt; mr ? min(p[(mid &lt;&lt; 1) - i], p[mid] + mid - i) : 1; for(; s[i-p[i]] == s[i+p[i]]; ++p[i]); if(p[i] + i &gt; mr) mr = i + p[i], mid = i; } } int main() { scanf(&#34;%s&#34;, a); _n = strlen(a); s[0] = s[1] = &#39;#&#39;; n = 1; for(int i = 0; i &lt; _n; ++i) s[++n] = a[i], s[++n] = &#39;#&#39;; s[++n] = 0; Manacher(); for(int i = 0; i &lt; n; ++i) ans = max(ans, p[i]); printf(&#34;%d\n&#34;, ans-1); } 线性基1 2 3 4 5 6 7 8 9 10 11 for(int i = 1; i &lt;= n; ++i) { read(a); for(int j = 50; j &gt;= 0; --j) { if((a &gt;&gt; j) &amp; 1) { if(!p[j]) {p[j] = a; break;} a ^= p[j]; } } } for(int i = 50; i &gt;= 0; --i) if(p[i]) ans = max(ans, ans ^ p[i]); 线性逆元1 2 3 inv[1] = 1; for(int i = 2; i &lt;= n; ++i) inv[i] = 1ll * (P - P / i) % P * inv[P % i]	% P; 后缀数组1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void getSA() { for(int i = 1; i &lt;= n; ++i) ++c[x[i] = s[i]]; for(int i = 1; i &lt;= m; ++i) c[i] += c[i-1]; for(int i = n; i &gt;= 1; --i) sa[c[x[i]]--] = i; for(int k = 1; k &lt;= n; k &lt;&lt;= 1) { int num = 0; for(int i = n - k + 1; i &lt;= n; ++i) y[++num] = i; for(int i = 1; i &lt;= n; ++i) if(sa[i] &gt; k) y[++num] = sa[i] - k; memset(c, 0, sizeof c); for(int i = 1; i &lt;= n; ++i) ++c[x[i]]; for(int i = 1; i &lt;= m; ++i) c[i] += c[i-1]; for(int i = n; i &gt;= 1; --i) sa[c[x[y[i]]]--] = y[i], y[i] = 0; swap(x, y); x[sa[1]] = 1; num = 0; for(int i = 1; i &lt;= n; ++i) x[sa[i]] = (y[sa[i-1]] == y[sa[i]] &amp;&amp; y[sa[i-1]+k] == y[sa[i]+k]) ? num : ++num; if(num == n) break; m = num; } } 点分治1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 void getroot(int u, int p, int S) { siz[u] = 1, f[u] = 0; for(int v, i = h[u]; ~i; i = e[i].next) if((v = e[i].to) != p &amp;&amp; !vis[v]) getroot(v, u, S), siz[u] += siz[v], f[u] = max(f[u], siz[v]); f[u] = max(f[u], S - siz[u]); rt = f[u] &lt; f[rt] ? u : rt; } void getdis(int u, int p) { stk[++top] = dis[u]; for(int v, i = h[u]; ~i; i = e[i].next) if((v = e[i].to) != p &amp;&amp; !vis[v]) dis[v] = dis[u] + e[i].w, getdis(v, u); } void solve(int u, int w, int t) { top = 0, dis[u] = w, getdis(u, 0); for(int i = 1; i &lt;= top; ++i) for(int j = 1; j &lt;= top; ++j) if(i != j) ans[stk[i] + stk[j]] += t; } void devide(int u) { solve(u, 0, 1); vis[u] = 1; for(int v, i = h[u]; ~i; i = e[i].next) if(!vis[(v = e[i].to)]) { solve(v, e[i].w, -1), rt = 0, f[0] = n; getroot(v, u, siz[u]), devide(rt); } } 线段树1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #define L(u) (u&lt;&lt;1) #define R(u) (u&lt;&lt;1|1) #define mid ((l+r)&gt;&gt;1) void PU(int u) {t[u] = (t[L(u)] + t[R(u)]) % P;} void ADD(int u, int l, int r, int k) { t[u] += (r - l + 1) * k % P; t[u] %= P; add[u] = (add[u] + k) % P; } void MUL(int u, int l, int r, int k) { t[u] = t[u] * k % P; add[u] = add[u] * k % P; mul[u] = mul[u] * k % P; } void PD(int u, int l, int r) { MUL(L(u), l, mid, mul[u]); MUL(R(u), mid+1, r, mul[u]); mul[u] = 1; ADD(L(u), l, mid, add[u]); ADD(R(u), mid+1, r, add[u]); add[u] = 0; } void build(int u, int l, int r) { mul[u] = 1; if(l == r) {t[u] = a[l]; return;} build(L(u), l, mid); build(R(u), mid+1, r); PU(u); } void MA(int u, int l, int r, int tl, int tr, int k) { if(tr &lt; l || tl &gt; r) return; if(tl &lt;= l &amp;&amp; r &lt;= tr) {ADD(u, l, r, k); return;} PD(u, l, r); MA(L(u), l, mid, tl, tr, k); MA(R(u), mid+1, r, tl, tr, k); PU(u); } void MM(int u, int l, int r, int tl, int tr, int k) { if(tr &lt; l || tl &gt; r) return; if(tl &lt;= l &amp;&amp; r &lt;= tr) {MUL(u, l, r, k); return;} PD(u, l, r); MM(L(u), l, mid, tl, tr, k); MM(R(u), mid+1, r, tl, tr, k); PU(u); } int Q(int u, int l, int r, int tl, int tr) { if(tr &lt; l || tl &gt; r) return 0; if(tl &lt;= l &amp;&amp; r &lt;= tr) return t[u]; PD(u, l, r); return (Q(L(u), l, mid, tl, tr) + Q(R(u), mid+1, r, tl, tr)) % P; } 三分1 2 3 4 5 while(fabs(r-l) &gt;= eps) { double mid = (l + r) / 2; if(f(mid - eps) &lt; f(mid + eps)) l = mid; else r = mid; } 树状数组1 2 void U(int x, int k) {for(; x &lt;= n; t[x] += k, x += x&amp;-x);} int Q(int x) {int w = 0; for(; x; w += t[x], x -= x&amp;-x); return w;} 高斯消元1 2 3 4 5 6 7 8 9 10 11 12 13 for(int i = 1; i &lt;= n; ++i) { int p = i; for(int j = i + 1; j &lt;= n; ++j) if(fabs(a[j][i]) &gt; fabs(a[p][i])) p = j; if(a[p][i] == 0) {puts(&#34;No Solution&#34;); return 0;} for(int j = 1; j &lt;= n+1; ++j) swap(a[i][j], a[p][j]); for(int j = 1; j &lt;= n; ++j) { if(i == j) continue; double t = a[j][i] / a[i][i]; for(int k = i; k &lt;= n+1; ++k) a[j][k] -= a[i][k] * t; } } for(int i = 1; i &lt;= n; ++i) printf(&#34;%.2lf\n&#34;, a[i][n+1] / a[i][i]); 最小生成树&amp;并查集1 2 3 4 5 6 7 8 9 10 11 12 int findfa(int x) {return x == fa[x] ? x : fa[x] = findfa(fa[x]);} int main() { for(int i = 1; i &lt;= n; ++i) fa[i] = i; sort(e+1, e+m+1); for(int i = 1; i &lt;= m; ++i) { int x = findfa(e[i].u), y = findfa(e[i].v); if(x == y) continue; ans += e[i].w; ++cnt; if(cnt == n-1) break; fa[x] = y; } } DINIC1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 bool bfs() { memset(d, -1, sizeof d); queue &lt;int&gt; q; q.push(s); d[s] = 0; while(!q.empty()) { int u = q.front(); q.pop(); for(int v, i = h[u]; ~i; i = e[i].next) if(d[v = e[i].to] == -1 &amp;&amp; e[i].w &gt; 0) d[v] = d[u] + 1, q.push(v); } return d[t] != -1; } int dfs(int u, int f) { int r = 0; if(u == t) return f; for(int v, i = h[u]; ~i &amp;&amp; r &lt; f; i = e[i].next) if(d[(v = e[i].to)] == d[u] + 1 &amp;&amp; e[i].w &gt; 0) { int x = dfs(v, min(e[i].w, f-r)); e[i].w -= x; e[i^1].w += x; r += x; } if(!r) d[u] = -1; return r; } int dinic() { int x, ans = 0; while(bfs()) while(x = dfs(s, 1e9)) ans += x; return ans; } 线性筛1 2 3 4 5 6 7 for(int i = 2; i &lt;= n; ++i) { if(!notp[i]) p[++cntp] = i; for(int j = 1; 1ll*i*p[j] &lt;= n &amp;&amp; j &lt;= cntp; ++j) { notp[i*p[j]] = 1; if(i % p[j] == 0) break; } } 左偏树1 2 3 4 5 6 7 8 9 10 11 12 13 14 int F(int x) {return x == fa[x] ? x : fa[x] = F(fa[x]);} int Merge(int x, int y) { if(x*y == 0) return x+y; if(v[x] &gt; v[y] || (v[x] == v[y] &amp;&amp; x &gt; y)) swap(x, y); R(x) = Merge(R(x), y); fa[R(x)] = fa[L(x)] = x; if(dis[R(x)] &gt; dis[L(x)]) swap(L(x), R(x)); dis[x] = dis[R(x)] + 1; return x; } int Top(int x) {return del[x] ? -1 : v[x];} void Pop(int x) { if(del[x]) return; del[x] = 1; fa[L(x)] = L(x); fa[R(x)] = R(x); fa[x] = Merge(L(x), R(x)); } LCT1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 bool nroot(int x) {return ch[fa[x]][0] == x || ch[fa[x]][1] == x;} void pushup(int x) {sumx[x] = sumx[ch[x][1]] ^ sumx[ch[x][0]] ^ val[x];} void pushr(int x) {swap(ch[x][1], ch[x][0]); rot[x] ^= 1;} void pushdown(int x) {if(rot[x]) {if(ch[x][0]) pushr(ch[x][0]); if(ch[x][1]) pushr(ch[x][1]); rot[x] = 0;}} void rotate(int x) { int y = fa[x], z = fa[y], k = (x == ch[y][1]); if(nroot(y)) ch[z][(y == ch[z][1])] = x; fa[x] = z; ch[y][k] = ch[x][k^1]; if(ch[x][k^1]) fa[ch[x][k^1]] = y; ch[x][k^1] = y; fa[y] = x; pushup(y); } void splay(int x) { int y = x, z = 0; st[++z] = y; while(nroot(y)) st[++z] = y = fa[y]; while(z) pushdown(st[z--]); for(int y; nroot(x); rotate(x)) if(nroot(y = fa[x])) rotate((y == ch[fa[y]][0]) ^ (x == ch[y][0]) ? x : y); pushup(x); } void access(int x) {for(int y = 0; x; x = fa[y = x]) splay(x), ch[x][1] = y, pushup(x);} void makeroot(int x) {access(x); splay(x); pushr(x);} int findroot(int x) {access(x); splay(x); for(; ch[x][0]; x = ch[x][0]) pushdown(x); splay(x); return x;} void spilit(int x, int y) {makeroot(x); access(y); splay(y);} void link(int x, int y) {makeroot(x); if(findroot(y) != x) fa[x] = y;} void cut(int x, int y) {makeroot(x); if(findroot(y) == x &amp;&amp; fa[y] == x &amp;&amp; !ch[y][0]) {fa[y] = ch[x][1] = 0; pushup(x);}} KMP1 2 3 4 5 6 7 8 9 for(int i = 2, j = 0; i &lt;= n; ++i) { while(j &amp;&amp; s[i] != s[j+1]) j = nxt[j]; if(s[j+1] == s[i]) ++j; nxt[i] = j; } for(int i = 1, j = 0; i &lt;= m; ++i) { while(j &gt; 0 &amp;&amp; t[i] != s[j+1]) j = nxt[j]; if(s[j+1] == t[i]) ++j; if(j == n) printf(&#34;%d\n&#34;, i-n+1); } SAM1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 struct SoumAsuMire { int ch[MAXN][26], fa[MAXN], last, cnt, len[MAXN]; void insert(int c) { int p = last, np = ++cnt; last = np; len[np] = len[p] + 1; for(; p &amp;&amp; !ch[p][c]; ch[p][c] = np, p = fa[p]); if(!p) fa[np] = 1; else { int q = ch[p][c]; if(len[q] == len[p] + 1) fa[np] = q; else { int nq = ++cnt; len[nq] = len[p] + 1; memcpy(ch[nq], ch[q], sizeof ch[q]); fa[nq] = fa[q]; fa[q] = fa[np] = nq; for(; p &amp;&amp; ch[p][c] == q; ch[p][c] = nq, p = fa[p]); } } } void build(char *s) { int n = strlen(s+1); last = 1; for(int i = 1; i &lt;= n; ++i) insert(s[i] - &#39;a&#39;); } int getans() { int ans = 0; for(int i = 2; i &lt;= cnt; ++i) ans += len[i] - len[fa[i]]; return ans; } } SAM; LCA(ST)1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void dfsRMQ(int u, int p) { st[++idx][0] = u; dfn[u] = idx; dep[u] = dep[p] + 1; for(int v, i = h[u]; ~i; i = e[i].next) if((v = e[i].to) != p) dfsRMQ(v, u), st[++idx][0] = u; } void LCAinit() { for(int i = 2; i &lt;= (n &lt;&lt; 1); ++i) lg2[i] = lg2[i&gt;&gt;1] + 1; dep[1] = 1; dfsRMQ(rt, 0); for(int j = 1; j &lt; 20; ++j) for(int i = 1; i + (1 &lt;&lt; j) &lt;= (n &lt;&lt; 1); ++i) st[i][j] = Min(st[i][j-1], st[i+(1&lt;&lt;(j-1))][j-1]); } int LCA(int x, int y) { x = dfn[x]; y = dfn[y]; if(x &gt; y) swap(x, y); int k = lg2[y-x+1]; return Min(st[x][k], st[y-(1&lt;&lt;k)+1][k]); } mcmf1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bool SPFA() { memset(d, 63, sizeof d); memset(vis, 0, sizeof vis); memset(flow, 63, sizeof flow); queue &lt;int&gt; q; q.push(s); d[s] = 0; vis[s] = 1; while(!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for(int v, i = h[u]; ~i; i = e[i].next) if(d[v = e[i].to] &gt; d[u] + e[i].c &amp;&amp; e[i].f) { d[v] = d[u] + e[i].c; pos[v] = i; fa[v] = u; flow[v] = min(flow[u], e[i].f); if(!vis[v]) vis[v] = 1, q.push(v); } } return flow[s] != flow[t]; } void mcmf() { while(SPFA()) { mc += flow[t]; mf += flow[t] * d[t]; for(int u = t; u != s; u = fa[u]) e[pos[u]].f -= flow[t], e[pos[u]^1].f += flow[t]; } } AC自动机1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include &lt;bits/stdc++.h&gt; using namespace std; const int S = 2000050, T = 200050; struct Edge {int to, next;} e[T]; char s[S]; int n, h[T], cnt, ch[T][26], fail[T], match[T], siz[T], tot = 1, en; queue &lt;int&gt; q; void addedge(int u, int v) {e[en] = (Edge) {v, h[u]}; h[u] = en++;} void dfs(int u) { for(int v, i = h[u]; ~i; i = e[i].next) dfs(v = e[i].to), siz[u] += siz[v]; } int main() { scanf(&#34;%d&#34;, &amp;n); memset(h, -1, sizeof h); for(int i = 1; i &lt;= n; ++i) { scanf(&#34;%s&#34;, s); int u = 1, j; for(u = 1, j = 0; s[j]; ++j) { int c = s[j] - &#39;a&#39;; if(!ch[u][c]) ch[u][c] = ++tot; u = ch[u][c]; } match[i] = u; } for(int i = 0; i &lt; 26; ++i) ch[0][i] = 1; q.push(1); while(!q.empty()) { int u = q.front(); q.pop(); for(int i = 0; i &lt; 26; ++i) if(ch[u][i]) { fail[ch[u][i]] = ch[fail[u]][i]; q.push(ch[u][i]); } else ch[u][i] = ch[fail[u]][i]; } scanf(&#34;%s&#34;, s); for(int u = 1, i = 0; s[i]; ++i) ++siz[u = ch[u][s[i]-&#39;a&#39;]]; for(int i = 2; i &lt;= tot; ++i) addedge(fail[i], i); dfs(1); for(int i = 1; i &lt;= n; ++i) printf(&#34;%d\n&#34;, siz[match[i]]); puts(&#34;&#34;); } dijkstra1 2 3 4 5 6 7 8 9 10 11 12 13 void dijkstra() { memset(d, 0x3f, sizeof d); d[s] = 0; q.push((D) {s, 0}); while(!q.empty()) { int u = q.top().u; q.pop(); if(vis[u]) continue; vis[u] = 1; for(int v, i = h[u]; ~i; i = e[i].next) if(d[v = e[i].to] &gt; d[u] + e[i].w) { d[v] = d[u] + e[i].w; if(!vis[v]) q.push((D) {v, d[v]}); } } } 树哈希1 2 3 4 5 6 7 8 ull Hash(int u, int p) { ull q[MAXN], ans = X; int top = 0; for(int i = h[u]; ~i; i = e[i].next) if(e[i].to != p) q[++top] = Hash(e[i].to, u); sort(q+1, q+top+1); for(int i = 1; i &lt;= top; ++i) ans = ans * P + q[i]; return ans * P + X + 1; } CDQ分治1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 struct BITS { int t[MAXN]; void U(int x, int k) {for(; x &lt;= m; t[x] += k, x += x&amp;-x);} int Q(int x) {int res = 0; for(; x; res += t[x], x -= x&amp;-x); return res;} } T; void cdq(int l, int r) { if(l == r) return; int mid = (l + r) &gt;&gt; 1; cdq(l, mid); cdq(mid+1, r); sort(a+l, a+mid+1, cmpy); sort(a+mid+1, a+r+1, cmpy); int i = mid + 1, j = l; for(; i &lt;= r; ++i) { for(; a[j].y &lt;= a[i].y &amp;&amp; j &lt;= mid; ++j) T.U(a[j].z, a[j].w); a[i].ans += T.Q(a[i].z); } for(int k = l; k &lt; j; ++k) T.U(a[k].z, -a[k].w); } int main() { read(_n); read(m); for(int i = 1; i &lt;= _n; ++i) read(b[i].x), read(b[i].y), read(b[i].z); sort(b+1, b+_n+1, cmpx); for(int c = 0, i = 1; i &lt;= _n; ++i) { ++c; if(b[i].x != b[i+1].x || b[i].y != b[i+1].y || b[i].z != b[i+1].z) a[++n] = b[i], a[n].w = c, c = 0; } cdq(1, n); for(int i = 1; i &lt;= n; ++i) cnt[a[i].ans + a[i].w - 1] += a[i].w; for(int i = 0; i &lt; _n; ++i) printf(&#34;%d\n&#34;, cnt[i]); } Lucas1 2 3 4 5 6 7 8 int C(int n, int m) { if(m &gt; n) return 0; return 1ll * fac[n] * power(fac[m], P-2) * power(fac[n-m], P-2); } int Lucas(int n, int m) { if(m == 0) return 1; return 1ll * C(n%P, m%P) * Lucas(n/P, m/P) % P; } 二分图1 2 3 4 5 6 7 8 9 10 bool dfs(int u) { for(int v, i = h[u]; ~i; i = e[i].next) { if(vis[v = e[i].to] != tag) { vis[v] = tag; if(!match[v] || dfs(match[v])) { match[v] = u; return 1; } } } return 0; } 莫队二次离线1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include &lt;bits/stdc++.h&gt; using namespace std; const int MAXN = 100050; typedef long long lint; void read(int &amp;x) { char ch; while(ch = getchar(), ch &lt; &#39;!&#39;); x = ch - 48; while(ch = getchar(), ch &gt; &#39;!&#39;) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - 48; } struct Qry {int l, r, id; lint ans;} q[MAXN]; struct T{int l, r, id;}; int n, m, a[MAXN], siz[MAXN], k, blsz, bl[MAXN], t[MAXN], pref[MAXN]; vector &lt;int&gt; buc; vector &lt;T&gt; v[MAXN]; lint ans[MAXN]; int cmp(Qry a, Qry b) {return bl[a.l] == bl[b.l] ? a.r &lt; b.r : a.l &lt; b.l;} int main() { read(n); read(m); read(k); blsz = sqrt(n); if(k &gt; 14) {for(int i = 1; i &lt;= m; ++i) puts(&#34;0&#34;); return 0;} for(int i = 1; i &lt;= n; ++i) read(a[i]); for(int i = 0; i &lt; 16384; ++i) if((siz[i] = siz[(i&gt;&gt;1)] + (i&amp;1)) == k) buc.push_back(i); for(int i = 1; i &lt;= m; ++i) read(q[i].l), read(q[i].r), q[i].id = i; for(int i = 1; i &lt;= n; ++i) bl[i] = (i-1) / blsz + 1; sort(q+1, q+m+1, cmp); for(int i = 1; i &lt;= n; ++i) { for(int j = 0; j &lt; buc.size(); ++j) ++t[a[i]^buc[j]]; pref[i] = t[a[i+1]]; } for(int L = 1, R = 0, i = 1; i &lt;= m; ++i) { int l = q[i].l, r = q[i].r; if(L &lt; l) v[R].push_back((T) {L, l-1, -i}); while(L &lt; l) {q[i].ans += pref[L-1]; ++L;} if(L &gt; l) v[R].push_back((T) {l, L-1, i}); while(L &gt; l) {q[i].ans -= pref[L-2]; --L;} if(R &lt; r) v[L-1].push_back((T) {R+1, r, -i}); while(R &lt; r) {q[i].ans += pref[R]; ++R;} if(R &gt; r) v[L-1].push_back((T) {r+1, R, i}); while(R &gt; r) {q[i].ans -= pref[R-1]; --R;} } memset(t, 0, sizeof t); for(int l, r, id, i = 1; i &lt;= n; ++i) { for(int j = 0; j &lt; buc.size(); ++j) ++t[a[i]^buc[j]]; for(int o = 0; o &lt; v[i].size(); ++o) { l = v[i][o].l; r = v[i][o].r; id = v[i][o].id; for(int j = l, tmp = 0; j &lt;= r; ++j) { tmp = t[a[j]]; if(j &lt;= i &amp;&amp; !k) --tmp; if(id &gt; 0) q[id].ans += tmp; else q[-id].ans -= tmp; } } } for(int i = 1; i &lt;= m; ++i) q[i].ans += q[i-1].ans; for(int i = 1; i &lt;= m; ++i) ans[q[i].id] = q[i].ans; for(int i = 1; i &lt;= m; ++i) printf(&#34;%lld\n&#34;, ans[i]); } 莫比乌斯反演1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void GetMu() { mu[1] = 1; for(int i = 2; i &lt;= 10000000; ++i) { if(!vis[i]) p[++cnt] = i, mu[i] = -1; for(int j = 1; j &lt;= cnt &amp;&amp; p[j] * i &lt;= 10000000; ++j) { vis[p[j]*i] = 1; if(i % p[j]) mu[p[j]*i] = -mu[i]; } } for(int i = 1; i &lt;= cnt; ++i) for(int j = 1; j * p[i] &lt;= 10000000; ++j) f[j*p[i]] += mu[j]; for(int i = 1; i &lt;= 10000000; ++i) pref[i] = pref[i-1] + f[i]; } lint calc(int a, int b) { lint res = 0; if(a &gt; b) swap(a, b); for(int l = 1, r = 0; l &lt;= a; l = r + 1) { r = min(a/(a/l), b/(b/l)); res += (pref[r] - pref[l-1])*1ll*(a/l)*(b/l); } return res; } 树剖1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 void ADD(int u, int l, int r, int k) {t[u] = (t[u] + 1ll*k*(r-l+1)%P) % P; tag[u] = (tag[u] + k) % P;} void PD(int u, int l, int r) {ADD(L(u), l, mid, tag[u]); ADD(R(u), mid+1, r, tag[u]); tag[u] = 0;} void PU(int u) {t[u] = (t[L(u)] + t[R(u)]) % P;} void build(int u, int l, int r) { if(l == r) {t[u] = w[id[l]]; return; } build(L(u), l, mid); build(R(u), mid+1, r); PU(u); } void upd(int u, int l, int r, int tl, int tr, int k) { if(tr &lt; l || tl &gt; r) return; if(tl &lt;= l &amp;&amp; r &lt;= tr) ADD(u, l, r, k); else PD(u, l, r), upd(L(u), l, mid, tl, tr, k), upd(R(u), mid+1, r, tl, tr, k), PU(u); } int qry(int u, int l, int r, int tl, int tr) { if(tr &lt; l || tl &gt; r) return 0; if(tl &lt;= l &amp;&amp; r &lt;= tr) return t[u]; PD(u, l, r); return (qry(L(u), l, mid, tl, tr) + qry(R(u), mid+1, r, tl, tr)) % P; } void dfs1(int u, int p) { fa[u] = p; siz[u] = 1; dep[u] = dep[p] + 1; for(int v, i = h[u]; ~i; i = e[i].next) if((v = e[i].to) != p) { dfs1(v, u); siz[u] += siz[v]; if(siz[son[u]] &lt; siz[v]) son[u] = v; } } void dfs2(int u, int p) { id[dfn[u] = ++idx] = u; top[u] = p; if(son[u]) dfs2(son[u], p); for(int v, i = h[u]; ~i; i = e[i].next) if((v = e[i].to) != fa[u] &amp;&amp; v != son[u]) dfs2(v, v); } void addpath(int x, int y, int k) { for(; top[x] != top[y]; x = fa[top[x]]) { if(dep[top[x]] &lt; dep[top[y]]) swap(x, y); upd(1, 1, n, dfn[top[x]], dfn[x], k); } if(dep[x] &gt; dep[y]) swap(x, y); upd(1, 1, n, dfn[x], dfn[y], k); } int qrypath(int x, int y) { int res = 0; for(; top[x] != top[y]; x = fa[top[x]]) { if(dep[top[x]] &lt; dep[top[y]]) swap(x, y); res = (res + qry(1, 1, n, dfn[top[x]], dfn[x])) % P; } if(dep[x] &gt; dep[y]) swap(x, y); return (res + qry(1, 1, n, dfn[x], dfn[y])) % P; } void addroot(int x, int k) {upd(1, 1, n, dfn[x], dfn[x] + siz[x] - 1, k); } int qryroot(int x) {return qry(1, 1, n, dfn[x], dfn[x] + siz[x] - 1);} 主席树1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 struct JZM_T {int ch[2], v;} t[MAXN &lt;&lt; 6]; int cnt, rt[MAXN &lt;&lt; 6], o[MAXN], a[MAXN], n, m; void build(int &amp;u, int l, int r) { t[u = ++cnt].v = 0; if(l != r) build(L(u), l, mid), build(R(u), mid+1, r); } void update(int &amp;u, int v, int l, int r, int p, int k) { t[u = ++cnt] = t[v]; t[u].v += k; if(l != r) p &lt;= mid ? update(L(u), L(v), l, mid, p, k) : update(R(u), R(v), mid+1, r, p, k); } int query(int tl, int tr, int l, int r, int k) { if(l == r) return o[l]; int s = t[L(tr)].v - t[L(tl)].v; return k &lt;= s ? query(L(tl), L(tr), l, mid, k) : query(R(tl), R(tr), mid+1, r, k-s); } int main() { read(n); read(m); for(int i = 1; i &lt;= n; ++i) read(a[i]), o[i] = a[i]; sort(o+1, o+n+1); int _n = unique(o+1, o+n+1)-o-1; build(rt[0], 1, _n); for(int i = 1; i &lt;= n; ++i) update(rt[i], rt[i-1], 1, _n, lower_bound(o+1, o+_n+1, a[i])-o, 1); for(int l, r, k; m--; ) { read(l); read(r); read(k); printf(&#34;%d\n&#34;, query(rt[l-1], rt[r], 1, _n, k)); } } GCD-BlackMagic1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int gcd(int a, int b) { int g = 1; for(int tmp, i = 0; i &lt; 3; b /= tmp, g *= tmp, ++i) tmp = (k[a][i] &gt; siz) ? (b % k[a][i] == 0 ? k[a][i] : 1) : _gcd[k[a][i]][b%k[a][i]]; return g; } int main() { k[1][0] = k[1][1] = k[1][2] = 1; notp[1] = 1; for(int i = 2; i &lt;= V; ++i) { if(!notp[i]) p[++cnt] = i, k[i][2] = i, k[i][1] = k[i][0] = 1; for(int j = 1; p[j] * i &lt;= V; ++j) { notp[i * p[j]] = 1; int *t = k[i*p[j]]; t[0] = k[i][0] * p[j]; t[1] = k[i][1]; t[2] = k[i][2]; if(t[1] &lt; t[0]) swap(t[0], t[1]); if(t[2] &lt; t[1]) swap(t[1], t[2]); if(i % p[j] == 0) break; } } for(int i = 1; i &lt;= siz; ++i) _gcd[i][0] = _gcd[0][i] = i; for(int _max = 1; _max &lt;= siz; ++_max) for(int i = 1; i &lt;= _max; ++i) _gcd[i][_max] = _gcd[_max][i] = _gcd[_max % i][i]; FFT1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 struct Complex { double x, y; Complex(double xx = 0, double yy = 0) {x = xx; y = yy;} Complex operator + (Complex &amp;b) const {return Complex(x+b.x, y+b.y);} Complex operator - (Complex &amp;b) const {return Complex(x-b.x, y-b.y);} Complex operator * (Complex &amp;b) const {return Complex(x*b.x-y*b.y, y*b.x+x*b.y);} } a[MAXN], b[MAXN]; int r[MAXN], n, m, l, limit; void FFT (Complex *A, int t) { for(int i = 0; i &lt; limit; ++i) if(i &lt; r[i]) swap(A[i], A[r[i]]); for(int mid = 1; mid &lt; limit; mid &lt;&lt;= 1) { Complex Wn = Complex(cos(Pi/mid), t * sin(Pi/mid)); for(int R = mid&lt;&lt;1, j = 0; j &lt; limit; j += R) { Complex w = Complex(1, 0); for(int k = 0; k &lt; mid; ++k, w = w * Wn) { Complex x = A[j+k], y = w*A[j+mid+k]; A[j+k] = x+y; A[j+mid+k] = x-y; } } } } int main() { n = read(); m = read(); for(int i = 0; i &lt;= n; ++i) a[i].x = read(); for(int i = 0; i &lt;= m; ++i) b[i].x = read(); for(limit = 1; limit &lt;= n+m; limit &lt;&lt;= 1, ++l); for(int i = 0; i &lt; limit; ++i) r[i] = (r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1)); FFT(a, 1); FFT(b, 1); for(int i = 0; i &lt;= limit; ++i) a[i] = a[i]*b[i]; FFT(a, -1); for(int i = 0; i &lt;= n+m; ++i) printf(&#34;%d &#34;, (int)(a[i].x/limit+0.5)); puts(&#34;&#34;); } 多项式1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 #include&lt;bits/stdc++.h&gt; #define ll long long #define FIO &#34;loj150&#34; using namespace std; const int N=1e5+5,MOD=998244353,P=19,INV2=MOD+1&gt;&gt;1; inline int add(int a,const int &amp;b){if((a+=b)&gt;=MOD)a-=MOD;return a;} inline int sub(int a,const int &amp;b){if((a-=b)&lt;	0)a+=MOD;return a;} inline int mul(const int &amp;a,const int &amp;b){return 1ll*a*b%MOD;} inline void inc(int &amp;a,const int &amp;b=1){a=add(a,b);} inline void dec(int &amp;a,const int &amp;b=1){a=sub(a,b);} inline void pro(int &amp;a,const int &amp;b){a=mul(a,b);} inline int qpow(int a,int b){int c=1;for(;b;b&gt;&gt;=1,pro(a,a))if(b&amp;1)pro(c,a);return c;} int n,k,w[2][1&lt;&lt;P]; inline void pre(){ for(int i=1;i&lt;1&lt;&lt;P;i&lt;&lt;=1){ w[0][i]=w[1][i]=1; int wn1=qpow(3,(MOD-1)/(i&lt;&lt;1)),wn0=qpow(wn1,MOD-2); for(int j=1;j&lt;i;j++) w[0][i+j]=mul(w[0][i+j-1],wn0),w[1][i+j]=mul(w[1][i+j-1],wn1); } } #define poly vector&lt;int&gt; inline void read(poly &amp;a,const int &amp;n){ a.resize(n); for(int i=0;i&lt;n;i++)scanf(&#34;%d&#34;,&amp;a[i]); } inline void out(const poly &amp;a){ for(int i=0,n=a.size();i&lt;n;i++)printf(&#34;%d%c&#34;,a[i],i^n-1?&#39; &#39;:&#39;\n&#39;); } inline void clear(poly &amp;a){ int n=a.size(); while(n&gt;1&amp;&amp;!a[n-1])n--; a.resize(n); } inline poly operator +(poly a,const int &amp;b){inc(a[0],b);return a;} inline poly operator +(const int &amp;b,poly a){inc(a[0],b);return a;} inline poly operator -(poly a,const int &amp;b){dec(a[0],b);return a;} inline poly operator -(const int &amp;b,poly a){dec(a[0],b);return a;} inline poly operator +(poly a,const poly &amp;b){ if(a.size()&lt;b.size())a.resize(b.size()); for(int i=0,n=a.size();i&lt;n;i++)inc(a[i],b[i]); return a; } inline poly operator -(poly a,const poly &amp;b){ if(a.size()&lt;b.size())a.resize(b.size()); for(int i=0,n=a.size();i&lt;n;i++)dec(a[i],b[i]); return a; } inline void ntt(int *f,int opt,int l){ poly rev(l); for(int i=0;i&lt;l;i++){rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)*(l&gt;&gt;1));if(i&lt;rev[i])swap(f[i],f[rev[i]]);} for(int i=1;i&lt;l;i&lt;&lt;=1) for(int j=0;j&lt;l;j+=i&lt;&lt;1) for(int k=0;k&lt;i;k++){ int x=f[j+k],y=mul(f[i+j+k],w[opt][i+k]); f[j+k]=add(x,y); f[i+j+k]=sub(x,y); } if(opt)for(int i=0,inv=qpow(l,MOD-2);i&lt;l;i++)pro(f[i],inv); } inline poly operator *(poly a,poly b){ int n=a.size(),m=b.size(),l=1; while(l&lt;n+m)l&lt;&lt;=1; a.resize(l);b.resize(l); ntt(&amp;a[0],0,l);ntt(&amp;b[0],0,l); for(int i=0;i&lt;l;i++)pro(a[i],b[i]); ntt(&amp;a[0],1,l); clear(a); return a; } inline poly&amp; operator *=(poly &amp;a,const poly b){return a=a*b;} inline poly operator *(poly a,const int &amp;b){ for(int i=0,n=a.size();i&lt;n;i++)pro(a[i],b); return a; } inline poly inv(const poly &amp;a,const int &amp;n){ if(n==1)return poly(1,qpow(a[0],MOD-2)); int l=1;while(l&lt;=n&lt;&lt;1)l&lt;&lt;=1; poly b=inv(a,n+1&gt;&gt;1),c(l);b.resize(l); for(int i=0;i&lt;n;i++)c[i]=a[i]; ntt(&amp;b[0],0,l);ntt(&amp;c[0],0,l); for(int i=0;i&lt;l;i++)pro(b[i],sub(2,mul(b[i],c[i]))); ntt(&amp;b[0],1,l); b.resize(n); clear(b); return b; } inline poly inv(const poly &amp;a){return inv(a,a.size());} int B; #define pii pair&lt;int,int&gt; inline pii operator *(pii a,pii b){ return pii(add(mul(a.first,b.first),mul(mul(a.second,b.second),B)),add(mul(a.first,b.second),mul(a.second,b.first))); } inline pii qpow(pii a,int b){pii c=pii(1,0);for(;b;b&gt;&gt;=1,a=a*a)if(b&amp;1)c=c*a;return c;} inline int remain(int x){ if(x&lt;=1)return x; int a=mul(mul(rand(),rand()),rand()); while(qpow(B=sub(mul(a,a),x),MOD-1&gt;&gt;1)==1)a=mul(mul(rand(),rand()),rand()); pii A=pii(a,1),ans=qpow(A,MOD+1&gt;&gt;1); return min(ans.first,MOD-ans.first); } inline poly sqrt(const poly &amp;a,const int &amp;n){ if(n==1)return poly(1,remain(a[0])); int l=1;while(l&lt;=n&lt;&lt;1)l&lt;&lt;=1; poly b=sqrt(a,n+1&gt;&gt;1),c(l),d; b.resize(n);d=inv(b)*INV2; b.resize(l);d.resize(l); for(int i=0;i&lt;n;i++)c[i]=a[i]; ntt(&amp;b[0],0,l);ntt(&amp;c[0],0,l);ntt(&amp;d[0],0,l); for(int i=0;i&lt;l;i++)b[i]=mul(d[i],add(mul(b[i],b[i]),c[i])); ntt(&amp;b[0],1,l); b.resize(n); clear(b); return b; } inline poly sqrt(const poly &amp;a){return sqrt(a,a.size());} inline poly deri(poly a){ int n=a.size(); if(n==1)return poly(1,0); for(int i=0;i&lt;n;i++)a[i]=mul(a[i+1],i+1); a.resize(n-1); return a; } inline poly inte(poly a){ int n=a.size(); a.resize(n+1); for(int i=n;i;i--)a[i]=mul(a[i-1],qpow(i,MOD-2)); a[0]=0; return a; } inline poly ln(const poly &amp;a){ int n=a.size(); poly c=inv(a)*deri(a); c.resize(n-1); return inte(c); } inline poly exp(const poly &amp;a,const int &amp;n){ if(n==1)return poly(1,1); poly b=exp(a,n+1&gt;&gt;1),c; b.resize(n);c=ln(b); for(int i=0;i&lt;n;i++)c[i]=sub(a[i],c[i]); inc(c[0]); b*=c; b.resize(n); return b; } inline poly exp(const poly &amp;a){return exp(a,a.size());} inline poly qpow(poly a,const double &amp;b){return exp(ln(a)*b);} poly a; int main(){ srand(19260817); pre(); scanf(&#34;%d%d&#34;,&amp;n,&amp;k); read(a,1+n); a=deri(qpow(1+ln(2+a-a[0]-exp(inte(inv(sqrt(a))))),k)); a.resize(n); out(a); return 0; } 珂朵莉树1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //以防我忘了set迭代器怎么写 struct node { int l, r; mutable lint v; node(int L, int R = -1, lint V = 0) : l(L), r(R), v(V) {} bool operator &lt; (const node &amp;o) const { return l &lt; o.l; } }; set &lt;node&gt; s; IT spilit (int pos) { IT it = s.lower_bound(node(pos)); if(it != s.end() &amp;&amp; it-&gt;l == pos) return it; it--; int L = it -&gt; l, R = it -&gt; r; lint V = it-&gt;v; s.erase(it); s.insert(node(L, pos-1, V)); return s.insert(node(pos, R, V)).first; } void add(int l, int r, int val) { IT il = spilit(l), ir = spilit(r+1); for(; il != ir; il-&gt;v += val, il++); } void tp(int l, int r, int val = 0) { IT il = spilit(l), ir = spilit(r+1); s.erase(il, ir); s.insert(node(l, r, val)); } </div><div class="post-footer">
    <a href="/posts/templates/">Read More</a></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h2 class="single-title" itemprop="name headline"><a href="/posts/d3ctf2022/">D3CTF2022wp-BadW3ter &amp; D3bug</a>
  </h2><div class="post-meta"><span class="post-author"><span class="author"><img loading="lazy" src="/avr.png" alt="Shino" data-title="Shino" width="20" height="20" class="avatar" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/>&nbsp;Shino</span></span>&nbsp;<span class="post-publish" title='2022-03-05 17:10:52'>published on <time datetime="2022-03-05">2022-03-05</time></span></div><div class="content">BadW3ter当时打题目名字的时候也没有多想，后来发现Water拼错了，笑死。
</div><div class="post-footer">
    <a href="/posts/d3ctf2022/">Read More</a></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h2 class="single-title" itemprop="name headline"><a href="/posts/captcha/">记一次模拟登陆和验证码绕过</a>
  </h2><div class="post-meta"><span class="post-author"><span class="author"><img loading="lazy" src="/avr.png" alt="Shino" data-title="Shino" width="20" height="20" class="avatar" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/>&nbsp;Shino</span></span>&nbsp;<span class="post-publish" title='2022-02-07 17:12:57'>published on <time datetime="2022-02-07">2022-02-07</time></span></div><div class="content">目标需求因为某种原因，我需要实现一个验证某组用户名和密码是否可以成功登录网站的模块。
</div><div class="post-footer">
    <a href="/posts/captcha/">Read More</a></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h2 class="single-title" itemprop="name headline"><a href="/posts/api/">使用Flask&#43;nginx&#43;uwsgi在服务器上部署一个简单的API接口</a>
  </h2><div class="post-meta"><span class="post-author"><span class="author"><img loading="lazy" src="/avr.png" alt="Shino" data-title="Shino" width="20" height="20" class="avatar" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/>&nbsp;Shino</span></span>&nbsp;<span class="post-publish" title='2022-02-05 15:18:52'>published on <time datetime="2022-02-05">2022-02-05</time></span></div><div class="content">整体架构</div><div class="post-footer">
    <a href="/posts/api/">Read More</a></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h2 class="single-title" itemprop="name headline"><a href="/posts/matrix/">线性代数与空间解析几何 女娲补天复习笔记</a>
  </h2><div class="post-meta"><span class="post-author"><span class="author"><img loading="lazy" src="/avr.png" alt="Shino" data-title="Shino" width="20" height="20" class="avatar" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/>&nbsp;Shino</span></span>&nbsp;<span class="post-publish" title='2022-01-02 16:22:48'>published on <time datetime="2022-01-02">2022-01-02</time></span></div><div class="content">矩阵及其初等变换概念同型矩阵：A与B都是m*n矩阵，则称A与B是同型矩阵。 负矩阵：A的每个元换成它的相反数，记为-A 数量矩阵：$kI，k∈R$ 反称矩阵：$A^T=-A$ Conclusions$(AB)T=BTA^T$ $(AB){-1}=B{-1}A^{-1}$ AB为对称矩阵$\iff AB=BA$ 行初等变换左乘初等矩阵，列初等变换右乘。 $(AT){-1}=(A^{-1})^T$ 行列式Conclusions若行列式某两行对应元成比例， 行列式为零。 $|A^{-1}|=\frac{1}{|A|}$ $|A^{\star}|=|A|^{n-1}$ 范德蒙德行列式结论：$\prod_{1≤j&lt;i&lt;n}(x_i-x_j)$ $A^{\star}A=|A|I$ A可逆$\iff R(A)=n \iff AX=0$只有零解$\iff AX=b$有唯一解 $R(A)=R(B) \iff $ A与B等价（A与B是同型矩阵） 几何空间概念自由向量：不考虑起点的向量 方向角：向量与坐标轴的夹角 方向余弦：方向角的余弦 平面束：经过直线$l$的全体平面称为过$l$的平面束 Conclusions$Prj_u(\vec{a}+\vec{b})=Prj_u\vec{a}+Prj_u\vec{b}$ $[\vec{a}\ \vec{b}\ \vec{c}]=0 \iff \vec{a}\ \vec{b}\ \vec{c}$共面 n维向量空间概念子空间：设$V$是$Rn$的一个非空子集合，则$V$是$Rn$的一个子空间的充分必要条件是$V$对于$R^n$的加法和数乘运算是封闭的。 所有向量$\vec{a_1}\ \vec{a_2}\ \vec{a_3}\ &hellip; \vec{a_n}$线性组合的集合用$L(\vec{a_1},\vec{a_2},&hellip;,\vec{a_n})$表示。 只含零向量的向量组的秩为0。 Conclusions$A=(\vec{a_1},\vec{a_2},&hellip;,\vec{a_n})$，则$\vec{a_1},\vec{a_2},&hellip;,\vec{a_n}$线性相关$\iff AX=0$有非零解$\iff R(A)&lt;n\iff |A|=0$ $R(AB)≤min{R(A),R(B)}$ $R(A+B)≤R(A)+R(B)$ $max{R(A),R(B)}R[(A,B)]≤R(A)+R(B)$ $AX=0$的基础解系所含解向量个数为$n-R(A)$ $R(A)=n-1$则$R(A^{\star})=1$ 特征值与特征向量概念特征子空间：对于特征值$\lambda$的所有特征向量构成的子空间。 Conclusions$\lambda$是$A$的一个特征值，则$\frac{1}{\lambda}$是$A^{-1}$的一个特征值，特征向量相同。
</div><div class="post-footer">
    <a href="/posts/matrix/">Read More</a></div>
</article><ul class="pagination"><li class="page-item">
          <span class="page-link">
            <a href="/">1</a>
          </span>
        </li><li class="page-item">
          <span class="page-link">
            <a href="/page/2/">2</a>
          </span>
        </li><li class="page-item">
          <span class="page-link">
            <a href="/page/3/">3</a>
          </span>
        </li><li class="page-item active">
          <span class="page-link">
            <a href="/page/4/">4</a>
          </span>
        </li><li class="page-item">
          <span class="page-link">
            <a href="/page/5/">5</a>
          </span>
        </li><li class="page-item">
          <span class="page-link">
            <a href="/page/6/">6</a>
          </span>
        </li></ul></div></main><footer class="footer">
    <div class="footer-container"><div class="footer-line powered">Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreferrer" title="Hugo 0.144.2"><img class="hugo-icon" src="/images/hugo.min.svg" alt="Hugo logo" /> Hugo</a> | Theme - <a href="https://github.com/hugo-fixit/FixIt" target="_blank" rel="external" title="FixIt v0.3.17-8b402129"><img class="fixit-icon" src="/images/fixit.min.svg" alt="FixIt logo" /> FixIt</a>
        </div><div class="footer-line copyright" itemscope itemtype="http://schema.org/CreativeWork"><i class="fa-regular fa-copyright fa-fw" aria-hidden="true"></i>
            <span itemprop="copyrightYear">2020 - 2025</span><span class="author" itemprop="copyrightHolder">
              <a href="/">Shino</a></span></div></div>
  </footer></div><div class="widgets"><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role="button" aria-label="Back to Top"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden="true"></i><span class="variant-numeric d-none">0%</span>
        </div></div><div id="mask"></div><div class="reading-progress-bar" style="left: 0;top: 0;"></div><noscript>
    <div class="noscript-warning">This website works best with JavaScript enabled.</div>
  </noscript>
</div><link rel="preload" href="/lib/katex/katex.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/katex/katex.min.css"></noscript><script src="/lib/autocomplete/autocomplete.min.js" defer></script><script src="/lib/fuse/fuse.min.js" defer></script><script src="/lib/sharer/sharer.min.js" async defer></script><script src="/lib/typeit/index.umd.js" defer></script><script src="/lib/katex/katex.min.js" defer></script><script src="/lib/katex/auto-render.min.js" defer></script><script src="/lib/katex/copy-tex.min.js" defer></script><script src="/lib/katex/mhchem.min.js" defer></script><script>var postChatConfig={"addButton":true,"backgroundColor":"","blackDom":[".expiration-reminder","meting-js",".lnt"],"bottom":"","defaultChatQuestions":[],"defaultInput":false,"defaultSearchQuestions":[],"fill":"","frameHeight":"","frameWidth":"","height":"","left":"","showInviteLink":true,"upLoadWeb":false,"userDesc":"","userIcon":"","userMode":"magic","userTitle":"","width":""}</script><script src="https://ai.tianli0.top/static/public/postChatUser.min.js" defer data-postChat_key="94e33c8ca2fc6b925063d733c79bb98c27972f8f"></script><script>window.config={"code":{"copyTitle":"Copy to clipboard","editLockTitle":"Lock editable code block","editUnLockTitle":"Unlock editable code block","editable":true,"maxShownLines":10},"enablePWA":true,"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"distance":100,"findAllMatches":false,"fuseIndexURL":"/search.json","highlightTag":"em","ignoreFieldNorm":false,"ignoreLocation":false,"isCaseSensitive":false,"location":0,"maxResultLength":10,"minMatchCharLength":2,"noResultsFound":"No results found","snippetLength":30,"threshold":0.3,"type":"fuse","useExtendedSearch":false},"typeit":{"cursorChar":"|","cursorSpeed":1000,"duration":-1,"loop":false,"speed":100},"version":"v0.3.17-8b402129"};</script><script src="/js/theme.min.js" defer></script></body>
</html>
