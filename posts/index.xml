<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - Shino Channel</title>
        <link>http://sh11no.github.io/posts/</link>
        <description>所有文章 | Shino Channel</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 20 Aug 2021 13:36:08 &#43;0800</lastBuildDate><atom:link href="http://sh11no.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>CNSS2021夏令营游记</title>
    <link>http://sh11no.github.io/cnsssummer/</link>
    <pubDate>Fri, 20 Aug 2021 13:36:08 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://sh11no.github.io/cnsssummer/</guid>
    <description><![CDATA[写在前面 ​	第一次玩CTF属于是，萌新吓傻了。（更新中）
Web 0x01 第一次冒险 ​	按照网页提示操作，最后结合提示在cookie中得到一个字符串，使用base64解密得到flag
0x02 更简单的计算题 ​	算出来发现提交不了？F12修改输入框的长度限制和提交按钮的disable状态，提交得到flag
0x03 卖菜刀 ​	依照题目，使用工具中国菜刀，在网站根目录可以找到flag文件。
0x04 最好的语言？ ​	这个题有点难，搞了好久。具体就是利用php的反序列化漏洞，即最后会将GET到的interesting参数反序列化。而我们可以利用这一点在interesting变量中加入代码让它执行达到目的。
​	class中的wakeup()函数会在对象被反序列化的时候执行，destruct()函数会在对象被销毁时执行。观察一下当a=&lsquo;1&rsquo;,b=&lsquo;2&rsquo;,c=&lsquo;3&rsquo;时对象就会在被销毁时输出flag。（注意是字符类型的123）而wakeup()函数会把abc修改成数值类型的123。而众所周知，对象会在程序执行结束后被销毁。所以我们的目的就是：利用反序列化漏洞构造一个Flag类的参数t，并且绕过其反序列化时执行的wakeup()直接执行destruct()。
​	那么怎么绕过wakeup()呢？
​	百度搜索可以得知：在某些php版本中，如果表示对象属性个数的值大于真实的属性个数时就会跳过wakeup()的执行。写个代码看看对象序列化之后啥样：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Flag { public $a = &#39;1&#39;; protected $b = &#39;2&#39;; private $c = &#39;3&#39;; function __construct() { $this-&gt;a = &#39;1&#39;; $this-&gt;b = &#39;2&#39;; $this-&gt;c = &#39;3&#39;; } } $t = new Flag(); echo serialize($t);   得到结果：]]></description>
</item><item>
    <title>Helloworld</title>
    <link>http://sh11no.github.io/helloworld/</link>
    <pubDate>Fri, 20 Aug 2021 12:11:56 &#43;0800</pubDate>
    <author>作者</author>
    <guid>http://sh11no.github.io/helloworld/</guid>
    <description><![CDATA[Hello，world！
让我看看blog行不行]]></description>
</item></channel>
</rss>
